2022.04.09 01:57:25 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/lsp.trace.json or /home/wxrqw/.cache/metals/lsp.trace.json
2022.04.09 01:57:27 INFO  logging to file /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/metals.log
2022.04.09 01:57:27 INFO  Started: Metals version 0.11.2 in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main' for client Visual Studio Code 1.64.2.
2022.04.09 01:57:29 INFO  time: initialize in 2.77s
2022.04.09 01:57:31 WARN  Build server is not auto-connectable.
2022.04.09 01:57:31 WARN  no build tool detected in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. 
2022.04.09 01:57:32 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 01:57:38 INFO  no build target found for /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala. Using presentation compiler with project's scala-library version: 3.1.1
2022.04.09 01:57:47 INFO  time: code lens generation in 10s
2022.04.09 02:06:09 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
2022.04.09 02:06:09 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 02:06:55 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
2022.04.09 02:06:56 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 02:06:57 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
2022.04.09 02:06:58 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 02:07:17 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/Interrupts.scala
2022.04.09 02:07:17 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/RocketTile.scala
2022.04.09 02:07:49 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
2022.04.09 02:07:49 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/RocketTile.scala
2022.04.09 02:07:51 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 02:07:51 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/RocketTile.scala
2022.04.09 02:07:52 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 09, 2022 2:07:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 45
Apr 09, 2022 2:07:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 47
2022.04.09 02:07:53 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/RocketTile.scala
2022.04.09 02:07:56 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 02:09:04 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/Interrupts.scala
2022.04.09 02:09:04 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
2022.04.09 02:09:04 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 02:10:46 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
2022.04.09 02:10:47 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 03:25:29 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/RocketTile.scala
2022.04.09 03:25:29 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 04:00:18 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 04:00:50 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
2022.04.09 04:00:51 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 09, 2022 4:01:09 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2022.04.09 04:01:48 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 09, 2022 4:04:59 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2022.04.09 04:05:04 INFO  shutting down Metals
2022.04.09 04:05:26 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/lsp.trace.json or /home/wxrqw/.cache/metals/lsp.trace.json
2022.04.09 04:05:28 INFO  logging to file /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/metals.log
2022.04.09 04:05:28 INFO  Started: Metals version 0.11.2 in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main' for client Visual Studio Code 1.64.2.
2022.04.09 04:05:31 INFO  time: initialize in 3.01s
2022.04.09 04:05:32 WARN  Build server is not auto-connectable.
2022.04.09 04:05:32 WARN  no build tool detected in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. 
2022.04.09 04:05:33 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 04:05:38 INFO  no build target found for /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala. Using presentation compiler with project's scala-library version: 3.1.1
2022.04.09 04:05:48 INFO  time: code lens generation in 10s
2022.04.09 04:05:48 INFO  time: code lens generation in 7.9s
2022.04.09 04:08:57 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
2022.04.09 04:09:03 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/RocketTile.scala
2022.04.09 04:09:05 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/L1Cache.scala
Apr 09, 2022 4:11:02 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTrace
2022.04.09 04:15:10 INFO  shutting down Metals
2022.04.09 04:15:32 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/lsp.trace.json or /home/wxrqw/.cache/metals/lsp.trace.json
2022.04.09 04:15:34 INFO  logging to file /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/metals.log
2022.04.09 04:15:34 INFO  Started: Metals version 0.11.2 in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main' for client Visual Studio Code 1.64.2.
2022.04.09 04:15:36 INFO  time: initialize in 2.21s
2022.04.09 04:15:37 WARN  Build server is not auto-connectable.
2022.04.09 04:15:37 WARN  no build tool detected in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. 
2022.04.09 04:15:38 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 04:15:41 INFO  no build target found for /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala. Using presentation compiler with project's scala-library version: 3.1.1
2022.04.09 04:15:48 INFO  time: code lens generation in 6.5s
2022.04.09 04:16:06 INFO  shutting down Metals
2022.04.09 22:35:01 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/lsp.trace.json or /home/wxrqw/.cache/metals/lsp.trace.json
2022.04.09 22:35:03 INFO  logging to file /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/metals.log
2022.04.09 22:35:03 INFO  Started: Metals version 0.11.2 in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main' for client Visual Studio Code 1.64.2.
2022.04.09 22:35:05 INFO  time: initialize in 2.39s
2022.04.09 22:35:06 WARN  Build server is not auto-connectable.
2022.04.09 22:35:06 WARN  no build tool detected in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. 
2022.04.09 22:35:07 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.09 22:35:10 INFO  no build target found for /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala. Using presentation compiler with project's scala-library version: 3.1.1
2022.04.09 22:35:17 INFO  time: code lens generation in 10s
2022.04.09 22:35:26 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/Core.scala
2022.04.09 22:35:34 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/rocket/RocketCore.scala
2022.04.09 22:35:59 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/rocket/BTB.scala
2022.04.09 23:03:29 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 1:14:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 374
Apr 10, 2022 1:14:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 378
Apr 10, 2022 1:14:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 437
Apr 10, 2022 1:14:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 438
Apr 10, 2022 1:14:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 440
Apr 10, 2022 1:14:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 446
2022.04.10 01:14:16 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.10 01:14:18 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.10 01:49:32 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 3:57:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 640
Apr 10, 2022 4:00:51 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 691
Apr 10, 2022 4:01:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 811
Apr 10, 2022 4:01:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 814
2022.04.10 04:01:19 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 4:01:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 886
Apr 10, 2022 4:01:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 929
2022.04.10 04:01:39 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 4:03:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1032
Apr 10, 2022 4:03:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1035
Apr 10, 2022 4:03:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1043
Apr 10, 2022 4:03:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1046
Apr 10, 2022 4:03:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1047
Apr 10, 2022 4:03:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1108
Apr 10, 2022 4:03:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1111
2022.04.10 04:04:05 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 4:30:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1191
Apr 10, 2022 4:32:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1287
Apr 10, 2022 4:32:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1354
2022.04.10 04:32:48 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 4:33:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1406
Apr 10, 2022 4:33:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1556
2022.04.10 04:34:14 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 4:34:42 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1722
Apr 10, 2022 4:34:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1725
Apr 10, 2022 4:34:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1777
Apr 10, 2022 4:34:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1780
Apr 10, 2022 4:35:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1856
2022.04.10 04:35:15 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 5:21:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1912
Apr 10, 2022 5:25:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1957
Apr 10, 2022 5:26:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1978
2022.04.10 05:26:00 INFO  time: code lens generation in 5.59s
Apr 10, 2022 5:26:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1979
Apr 10, 2022 5:26:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1981
Apr 10, 2022 5:26:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1984
Apr 10, 2022 5:26:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1993
Apr 10, 2022 5:26:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1985
2022.04.10 05:26:03 INFO  time: code lens generation in 1.08s
Apr 10, 2022 5:26:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2005
Apr 10, 2022 5:26:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2025
Apr 10, 2022 5:26:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2057
Apr 10, 2022 5:26:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2092
Apr 10, 2022 5:26:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2100
2022.04.10 05:26:25 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.10 05:26:33 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 5:26:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2131
Apr 10, 2022 5:26:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2185
2022.04.10 05:26:57 INFO  time: code lens generation in 1.18s
Apr 10, 2022 5:26:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2192
Apr 10, 2022 5:26:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2199
2022.04.10 05:27:00 INFO  time: code lens generation in 1.13s
Apr 10, 2022 5:27:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2204
Apr 10, 2022 5:27:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2231
Apr 10, 2022 5:27:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2239
2022.04.10 05:27:09 INFO  time: code lens generation in 1.11s
Apr 10, 2022 5:27:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2245
2022.04.10 05:27:12 INFO  time: code lens generation in 1.17s
2022.04.10 05:27:12 INFO  time: code lens generation in 1.15s
Apr 10, 2022 5:27:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2284
Apr 10, 2022 5:27:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2287
Apr 10, 2022 5:27:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2310
2022.04.10 05:27:37 INFO  time: code lens generation in 1.15s
Apr 10, 2022 5:28:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2383
Apr 10, 2022 5:28:36 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2385
Apr 10, 2022 5:28:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2392
2022.04.10 05:28:38 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 5:28:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2387
Apr 10, 2022 5:28:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2394
Apr 10, 2022 5:28:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2395
Apr 10, 2022 5:28:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2397
Apr 10, 2022 5:28:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2396
Apr 10, 2022 5:28:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2400
Apr 10, 2022 5:28:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2403
Apr 10, 2022 5:28:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2402
Apr 10, 2022 5:28:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2415
Apr 10, 2022 5:29:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2446
2022.04.10 05:31:58 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/rocket/RocketCore.scala
Apr 10, 2022 5:32:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2565
Apr 10, 2022 5:32:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2572
Apr 10, 2022 5:32:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2580
Apr 10, 2022 5:32:24 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2596
2022.04.10 05:32:25 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Exception in thread "pool-1-thread-212" java.lang.OutOfMemoryError: GC overhead limit exceeded
	at java.util.Arrays.copyOf(Arrays.java:3181)
	at java.util.ArrayList.grow(ArrayList.java:267)
	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:241)
	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:233)
	at java.util.ArrayList.add(ArrayList.java:464)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$uncachedTokenize$1(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$uncachedTokenize$1$adapted(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$Lambda$1147/1896101102.apply(Unknown Source)
	at scala.meta.internal.tokenizers.LegacyScanner.foreach(LegacyScanner.scala:1129)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:24)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$Lambda$1144/1445610880.apply(Unknown Source)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:895)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:334)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.internal.parsing.Trees.tokenized(Trees.scala:112)
	at scala.meta.internal.parsing.TokenEditDistance$.$anonfun$apply$4(TokenEditDistance.scala:384)
	at scala.meta.internal.parsing.TokenEditDistance$$$Lambda$3602/1065067277.apply(Unknown Source)
	at scala.Option.flatMap(Option.scala:271)
	at scala.meta.internal.parsing.TokenEditDistance$.apply(TokenEditDistance.scala:383)
	at scala.meta.internal.metals.Buffers.tokenEditDistance(Buffers.scala:30)
	at scala.meta.internal.metals.DefinitionProvider.positionOccurrence(DefinitionProvider.scala:180)
	at scala.meta.internal.metals.DocumentHighlightProvider.$anonfun$documentHighlight$1(DocumentHighlightProvider.scala:33)
	at scala.meta.internal.metals.DocumentHighlightProvider$$Lambda$3472/714717653.apply(Unknown Source)
	at scala.collection.immutable.List.map(List.scala:293)
	at scala.meta.internal.metals.DocumentHighlightProvider.documentHighlight(DocumentHighlightProvider.scala:29)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$documentHighlights$1(MetalsLanguageServer.scala:1451)
	at scala.meta.internal.metals.MetalsLanguageServer$$Lambda$3471/1731028319.apply(Unknown Source)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$apply$2(CancelTokens.scala:26)
	at scala.meta.internal.metals.CancelTokens$$$Lambda$1063/219038903.apply(Unknown Source)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
Exception in thread "pool-1-thread-211" java.lang.OutOfMemoryError: GC overhead limit exceeded
Apr 10, 2022 5:33:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 656,
      "uri": "file:///home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala"
    },
    "contentChanges": [
      {
        "text": "// See LICENSE.Berkeley for license details.\n// See LICENSE.SiFive for license details.\n\npackage freechips.rocketchip.tile\n\nimport Chisel._\n\nimport freechips.rocketchip.config._\nimport freechips.rocketchip.subsystem._\nimport freechips.rocketchip.diplomacy._\nimport freechips.rocketchip.rocket._\nimport freechips.rocketchip.tilelink._\nimport freechips.rocketchip.util.InOrderArbiter\n\nimport chisel3.core.{Input, Output}\n\ncase object BuildRoCC extends Field[Seq[Parameters \u003d\u003e LazyRoCC]](Nil)\n\n//flang\nclass DFIPort(implicit p: Parameters) extends CoreBundle {\n\tval test \u003d Bits(width \u003d xLen)\n\tval taraddr \u003d Bits(width \u003d xLen)\n\tval ltaraddr \u003d Bits(width \u003d xLen)\n\tval staraddr \u003d Bits(width \u003d xLen)\n\tval cmd \u003d Bits(width \u003d xLen)\n\tval valid \u003d Bool(INPUT)\n\tval svalid \u003d Bool(INPUT)\n\tval lvalid \u003d Bool(INPUT)\n\tval priv \u003d Bits(width \u003d xLen)\n\tval cycle \u003d Bits(width \u003d xLen)\n\tval cycle_now \u003d Bits(width \u003d xLen)\n\tval threadptr \u003d Input(UInt(xLen.W))\n\tval funcretaddr \u003d Input(UInt(xLen.W))\n\tval funcstackaddr \u003d Input(UInt(xLen.W))\n\tval funcarg0 \u003d Input(UInt(xLen.W))\n\tval funcarg1 \u003d Input(UInt(xLen.W))\n\tval funcarg2 \u003d Input(UInt(xLen.W))\n\tval funcarg3 \u003d Input(UInt(xLen.W))\n\tval funcarg4 \u003d Input(UInt(xLen.W))\n\tval funcarg5 \u003d Input(UInt(xLen.W))\n\tval callvalid \u003d Bool(INPUT)\n\tval retvalid \u003d Bool(INPUT)\n\tval brtarget \u003d Input(SInt(xLen.W))\n}\n\n//wxrqw\nclass CFIPort(implicit p: Parameters) extends CoreBundle {\n\tval taken \u003d Bool(INPUT)\n\tval valid \u003d Bool(INPUT)\n\tval mispredict \u003d Bool(INPUT)\n\tval pc \u003d Input(UInt(40.W))\n\tval cfiType \u003d Input(UInt(2.W))\n\tval isCFI \u003d Bool(INPUT)\n}\n\n\n\nclass RoCCInstruction extends Bundle {\n  val funct \u003d Bits(width \u003d 7)\n  val rs2 \u003d Bits(width \u003d 5)\n  val rs1 \u003d Bits(width \u003d 5)\n  val xd \u003d Bool()\n  val xs1 \u003d Bool()\n  val xs2 \u003d Bool()\n  val rd \u003d Bits(width \u003d 5)\n  val opcode \u003d Bits(width \u003d 7)\n}\n\nclass RoCCCommand(implicit p: Parameters) extends CoreBundle()(p) {\n  val inst \u003d new RoCCInstruction\n  val rs1 \u003d Bits(width \u003d xLen)\n  val rs2 \u003d Bits(width \u003d xLen)\n  val status \u003d new MStatus\n}\n\nclass RoCCResponse(implicit p: Parameters) extends CoreBundle()(p) {\n  val rd \u003d Bits(width \u003d 5)\n  val data \u003d Bits(width \u003d xLen)\n}\n\nclass RoCCCoreIO(implicit p: Parameters) extends CoreBundle()(p) {\n  val cmd \u003d Decoupled(new RoCCCommand).flip\n  val resp \u003d Decoupled(new RoCCResponse)\n  val mem \u003d new HellaCacheIO\n  val busy \u003d Bool(OUTPUT)\n  val interrupt \u003d Bool(OUTPUT)\n  val exception \u003d Bool(INPUT)\n  //flang\n  val corestalled \u003d Bool(INPUT)\n  val corestall \u003d Bool(OUTPUT)\n  val coreexception \u003d Bool(OUTPUT)\n  val canexception \u003d Bool(INPUT)\n  val cmdvalid \u003d Bool(INPUT)\n  val test \u003d Bits(width \u003d xLen).flip\n  val dfi \u003d Decoupled(new DFIPort).flip\n  //wxrqw\n  val corestall_wxr \u003d Bool(OUTPUT)\n  val reg_id \u003d Bits(width\u003d5)\n  val reg_value \u003d Bits(width\u003d64)\n  val reg_valid \u003d Bool(OUTPUT)\n  val reg_ready \u003d Bool(INPUT)\n  val cfi \u003d Decoupled(new CFIPort).flip\n}\n\nclass RoCCIO(val nPTWPorts: Int)(implicit p: Parameters) extends RoCCCoreIO()(p) {\n  val ptw \u003d Vec(nPTWPorts, new TLBPTWIO)\n  val fpu_req \u003d Decoupled(new FPInput)\n  val fpu_resp \u003d Decoupled(new FPResult).flip\n}\n\n/** Base classes for Diplomatic TL2 RoCC units **/\nabstract class LazyRoCC(\n      val opcodes: OpcodeSet,\n      val nPTWPorts: Int \u003d 0,\n      val usesFPU: Boolean \u003d false\n    )(implicit p: Parameters) extends LazyModule {\n  val module: LazyRoCCModuleImp\n  val atlNode: TLNode \u003d TLIdentityNode()\n  val tlNode: TLNode \u003d TLIdentityNode()\n}\n\nclass LazyRoCCModuleImp(outer: LazyRoCC) extends LazyModuleImp(outer) {\n  val io \u003d IO(new RoCCIO(outer.nPTWPorts))\n}\n\n/** Mixins for including RoCC **/\n\ntrait HasLazyRoCC extends CanHavePTW { this: BaseTile \u003d\u003e\n  val roccs \u003d p(BuildRoCC).map(_(p))\n\n  roccs.map(_.atlNode).foreach { atl \u003d\u003e tlMasterXbar.node :\u003d* atl }\n  roccs.map(_.tlNode).foreach { tl \u003d\u003e tlOtherMastersNode :\u003d* tl }\n\n  nPTWPorts +\u003d roccs.map(_.nPTWPorts).foldLeft(0)(_ + _)\n  nDCachePorts +\u003d roccs.size\n}\n\ntrait HasLazyRoCCModule extends CanHavePTWModule\n    with HasCoreParameters { this: RocketTileModuleImp with HasFpuOpt \u003d\u003e\n\n  val (respArb, cmdRouter) \u003d if(outer.roccs.size \u003e 0) {\n    val respArb \u003d Module(new RRArbiter(new RoCCResponse()(outer.p), outer.roccs.size))\n    val cmdRouter \u003d Module(new RoccCommandRouter(outer.roccs.map(_.opcodes))(outer.p))\n    outer.roccs.zipWithIndex.foreach { case (rocc, i) \u003d\u003e\n      ptwPorts ++\u003d rocc.module.io.ptw\n      rocc.module.io.cmd \u003c\u003e cmdRouter.io.out(i)\n      val dcIF \u003d Module(new SimpleHellaCacheIF()(outer.p))\n      dcIF.io.requestor \u003c\u003e rocc.module.io.mem\n      dcachePorts +\u003d dcIF.io.cache\n      respArb.io.in(i) \u003c\u003e Queue(rocc.module.io.resp)\n    }\n\n    fpuOpt foreach { fpu \u003d\u003e\n      val nFPUPorts \u003d outer.roccs.filter(_.usesFPU).size\n      if (usingFPU \u0026\u0026 nFPUPorts \u003e 0) {\n        val fpArb \u003d Module(new InOrderArbiter(new FPInput()(outer.p), new FPResult()(outer.p), nFPUPorts))\n        val fp_rocc_ios \u003d outer.roccs.filter(_.usesFPU).map(_.module.io)\n        fpArb.io.in_req \u003c\u003e fp_rocc_ios.map(_.fpu_req)\n        fp_rocc_ios.zip(fpArb.io.in_resp).foreach {\n          case (rocc, arb) \u003d\u003e rocc.fpu_resp \u003c\u003e arb\n        }\n        fpu.io.cp_req \u003c\u003e fpArb.io.out_req\n        fpArb.io.out_resp \u003c\u003e fpu.io.cp_resp\n      } else {\n        fpu.io.cp_req.valid :\u003d Bool(false)\n        fpu.io.cp_resp.ready :\u003d Bool(false)\n      }\n    }\n    (Some(respArb), Some(cmdRouter))\n  } else {\n    (None, None)\n  }\n}\n\n//flang++++++++++++++++\n\nclass DFIFIFO(depth: Int, datawidth: Int)(implicit p: Parameters) extends Module {\n\tval io \u003d new Bundle{\n\t\tval rst \u003d Bool(INPUT)\n\t\tval write \u003d Bool(INPUT)\n\t\tval datain \u003d Bits(width \u003d datawidth).flip\n\t\tval read \u003d Bool(INPUT)\n\t\tval dataout \u003d Bits(width \u003d datawidth)\n\t\tval full \u003d Bool(OUTPUT)\n\t\tval empty \u003d Bool(OUTPUT)\n\t}\n\tval head \u003d Reg(init \u003d Bits(0,width \u003d 12))\n\tval tail \u003d Reg(init \u003d Bits(0,width \u003d 12))\n\tval addrwidth \u003d log2Up(depth)\n\t//val buffer\u003dReg(init \u003d Vec.fill(depth){Bits(0,width \u003d datawidth)})\n\tval buffer\u003dMem(depth,Bits(width \u003d datawidth))\n\t\n\tval nowfull \u003d ((head(addrwidth-1,0) \u003d\u003d\u003d tail(addrwidth-1,0)) \u0026\u0026 (head(addrwidth) \u003d/\u003d tail(addrwidth)))\n\tval willfull \u003d io.write \u0026\u0026 (head(addrwidth-1,0) \u003d\u003d\u003d (tail+Bits(1))(addrwidth-1,0)) \u0026\u0026 (head(addrwidth) \u003d/\u003d (tail+Bits(1))(addrwidth))\n\tval nowempty \u003d ((head(addrwidth-1,0) \u003d\u003d\u003d tail(addrwidth-1,0)) \u0026\u0026 (head(addrwidth) \u003d\u003d\u003d tail(addrwidth)))\n\tval willempty \u003d (io.read \u0026\u0026 ((head+Bits(1))(addrwidth-1,0) \u003d\u003d\u003d tail(addrwidth-1,0)) \u0026\u0026 ((head+Bits(1))(addrwidth) \u003d\u003d\u003d tail(addrwidth)))\n\tio.full :\u003d nowfull || willfull\n\tio.empty :\u003d nowempty || willempty\n\t\n\t//val outbuf\u003dReg(init \u003d Bits(0,width \u003d datawidth))\n\t\n\twhen(io.rst){\n\t\thead :\u003d Bits(0)\n\t\ttail :\u003d Bits(0)\n\t}\n\twhen(!io.rst \u0026\u0026 io.write){\n\t\twhen(!nowfull){\n\t\t\tbuffer(tail(addrwidth-1,0)) :\u003d io.datain\n\t\t\ttail :\u003d tail + Bits(1)\n\t\t}.otherwise{}\n\t}\n\twhen(!io.rst \u0026\u0026 io.read){\n\t\twhen(!nowempty){\n\t\t\thead :\u003d head + Bits(1)\n\t\t}.otherwise{}\n\t}.otherwise{}\n\tio.dataout :\u003d buffer(head(addrwidth-1,0))\n}\n\nclass DFI_stoptbuf(size: Int, addrwidth: Int)(implicit p: Parameters) extends Module {\n\tval io \u003d new Bundle {\n\t\tval rst \u003d Bool(INPUT)\n\t\tval rw \u003d Bits(width \u003d 1)\n\t\tval id \u003d Bits(width \u003d 16)\n\t\tval taraddr \u003d Bits(width \u003d addrwidth)\n\t\tval red \u003d Bool(OUTPUT)\n\t}\n}\n\nclass DFILdOptBuf(size: Int, addrwidth: Int)(implicit p: Parameters) extends Module {\n\tval io \u003d new Bundle{\n\t\tval rst \u003d Bool(INPUT)\n\t\tval rw \u003d Bits(width \u003d 1).flip\n\t\tval id \u003d Bits(width \u003d 16).flip\n\t\tval taraddr \u003d Bits(width \u003d addrwidth).flip\n\t\tval red \u003d Bool(OUTPUT)\n\t}\n\tval buf_id\u003dReg(init \u003d Vec.fill(size){Bits(0,width \u003d 16)})\n\tval buf_taraddr\u003dReg(init \u003d Vec.fill(size){Bits(0,width \u003d addrwidth)})\n\t\n\tval sameid\u003dVec.fill(size){Bool(false)}\n\tval sametaraddr\u003dVec.fill(size){Bool(false)}\n\t\n\tfor (i\u003c- 0 to size-1){\n\t\tsameid(i) :\u003d (io.id \u003d\u003d\u003d buf_id(i))\n\t\tsametaraddr(i) :\u003d (io.taraddr \u003d\u003d\u003d buf_taraddr(i))\n\t}\n\t\n\tbuf_id(0) :\u003d Mux(io.rst,Bits(0),Mux(io.rw \u003d\u003d\u003d Bits(1), io.id, buf_id(0)))\n\tbuf_taraddr(0) :\u003d Mux(io.rst,Bits(0),Mux(io.rw \u003d\u003d\u003d Bits(1), io.taraddr, buf_taraddr(0)))\n\tfor (i\u003c- 1 to size-1){\n\t\tbuf_id(i) :\u003d Mux(io.rst,Bits(0),Mux(io.rw \u003d\u003d\u003d Bits(1), buf_id(i-1), Mux(sametaraddr(i), Bits(0), buf_id(i))))\n\t\tbuf_taraddr(i) :\u003d Mux(io.rst,Bits(0),Mux(io.rw \u003d\u003d\u003d Bits(1), buf_taraddr(i-1), Mux(sametaraddr(i), Bits(0), buf_taraddr(i))))\n\t}\n\t\n\tval sameboth\u003dVec.fill(size){Bool(false)}\n\tfor (i\u003c- 0 to size-1){\n\t\tsameboth(i) :\u003d (sameid(i)\u0026\u0026sametaraddr(i))\n\t}\n\t\n\tval midre\u003dVec.fill(size){Vec.fill(size){Bool(false)}}\n\tfor (i\u003c- 0 to log2Up(size)-1){\n\t\tfor (j\u003c- 0 to (1\u003c\u003ci)-1){\n\t\t\tif(i\u003clog2Up(size)-1){\n\t\t\t\tmidre(i)(j) :\u003d midre(i+1)(j\u003c\u003c1) | midre(i+1)((j\u003c\u003c1)+1)\n\t\t\t}else{\n\t\t\t\tmidre(i)(j) :\u003d sameboth(j\u003c\u003c1) | sameboth((j\u003c\u003c1)+1)\n\t\t\t}\n\t\t}\n\t}\n\tio.red :\u003d midre(0)(0)\n}\n\nclass  DFIcheck(opcodes: OpcodeSet)(implicit p: Parameters) extends LazyRoCC(opcodes) {\n  override lazy val module \u003d new DFIcheckImp(this)\n}\n\nclass DFIcheckImp2(outer: DFIcheck)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n    with HasCoreParameters {\n}\n\nclass DFIcheckImp(outer: DFIcheck)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n    with HasCoreParameters {\n\t//IMPORTANT!!!!!: this module works under the assumption that the lowest 3 bits of rdsaddr, rdtaddr and debugaddr are all 0\n\t//info format:\n\t//21-20 \u003d 0 : 19 \u003d 0 : 16:st/ld, 15-0: id\n\t//21-20 \u003d 0 : 19 \u003d 1 : 18:ld?, 17:st?, 16:call/ret? 15-0: id\n\t//21-20 \u003d 1 : rdt addr\n\t//21-20 \u003d 2 : rds addr\n\t//21-20 \u003d 3 : debug addr, 19 \u003d 1 : run with debug\n\t//21-20 \u003d 3 : debug addr, 18 \u003d 1 : write debug\n\t//21-20 \u003d 3 : debug addr, 17 \u003d 1 : func signal\n\t\n\tdef SIMULATION: Bool \u003d Bool(false)\n\t\n\tdef fifostldsize: Int \u003d 64\n\tdef fifofuncsize: Int \u003d 8\n\t\n\tdef ldopbufsize: Int \u003d 64\n\t\n\tdef shdstacksize: Int \u003d 1024\n\t\n\tdef bufsize: Int \u003d 8\n\t\n\tdef addrshift: Int \u003d 2\n\t\n\tdef rdscacheaddrwidth: Int \u003d 10\n\tdef rdsaddrwidth: Int \u003d 16 //log(how many entry), not how many bytes\n\tdef rdscacheaddrmask: UInt \u003d UInt((1\u003c\u003crdscacheaddrwidth)-1)\n\t\n\tdef rdsmapcacheaddrwidth: Int \u003d 10\n\tdef rdsmapaddrwidth: Int \u003d 16 //log(how many entry), not how many bytes\n\tdef rdsmapcacheaddrmask: UInt \u003d UInt((1\u003c\u003crdsmapcacheaddrwidth)-1)\n\t\n\t//def rdtcacheaddrwidth: Int \u003d 5\n\t//def rdtaddrwidth: Int \u003d 8 //log(how many entry), not how many bytes\n\tdef rdtcacheaddrwidth: Int \u003d 10\n\tdef rdtaddrwidth: Int \u003d 25 //log(how many entry), not how many bytes\n\tdef addrmask: Int \u003d (1\u003c\u003crdtaddrwidth)-1\n\tdef rdtcacheaddrmask: UInt \u003d UInt((1\u003c\u003crdtcacheaddrwidth)-1)\n\t\n\tval addrrdt \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval addrrds \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval addrdebug \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//target address acuqire\n\tval saddrbuf \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval scyclebuf \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval saddrbuf_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval laddrbuf \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval lcyclebuf \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval laddrbuf_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval staraddrs \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval staraddrs_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval ltaraddrs \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval ltaraddrs_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval staraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval ltaraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//DFI shared\n\tval count \u003d Reg(init \u003d Bits(0,width \u003d 8))\n\tval countreq \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval countresp \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval countstinflight \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval matched \u003d Reg(init \u003d Bool(true))\n\tval info_debug \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval infor \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval haserror \u003d Reg(init \u003d Bool(false))\n\tval waitresp \u003d Reg(init \u003d Bool(false))\n\t\n\t//st/ld DFI\n\tval slneedprocess \u003d Reg(init \u003d Bits(0,width \u003d 2))\n\tval taraddr \u003d Reg(init \u003d Vec.fill(2){Bits(0,width \u003d xLen)})\n\tval rw \u003d Reg(init \u003d Bits(0,width \u003d 1))\n\tval id \u003d Reg(init \u003d Vec.fill(3){Bits(0,width \u003d xLen)})\n\tval prevwid \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdsid \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdsp \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdse \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//func DFI\n\tval brneedprocess \u003d Reg(init \u003d Vec.fill(2){Bool(false)})\n\tval waitingcall \u003d Reg(init \u003d Bool(false))\n\tval repcall \u003d Reg(init \u003d Bool(false))\n\tval callremain \u003d Reg(init \u003d Vec.fill(3){Bool(false)})\n\tval brremain \u003d Reg(init \u003d Vec.fill(2){Bool(false)})\n\tval brtarget \u003d Reg(init \u003d Vec.fill(2){SInt(0,width \u003d xLen)})\n\tval funcretaddr \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg0 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg1 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg2 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg3 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg4 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg5 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcretpointer \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcmode \u003d Reg(init \u003d Vec.fill(3){Bits(0,width \u003d 2)})//000: normal call; 001: lib call, w; 010: lib call, r; 011: lib call, w+r; 100: ret \n\tval funciscall \u003d Reg(init \u003d Vec.fill(2){Bool(false)})\n\tval funccount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalfunccount \u003d Reg(init \u003d Vec.fill(2){Bits(0,width \u003d xLen)})\n\t\n\t//for stop\n\tval stop_call_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval stop_call_count_all \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval stop_call_count_max \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval stop_call_count_keep \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval stop_repcall \u003d Reg(init \u003d Bool(false))\n\tval stop_brtarget \u003d Reg(init \u003d SInt(0,width \u003d xLen))\n\tval stop_coreexception \u003d Reg(init \u003d Bool(false))\n\tio.coreexception :\u003d stop_coreexception\n\t\n\t//for debug\n\tval opst_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval opld_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval uprdt_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdrdt_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdrdsmap_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdrds_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval chk_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg0 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg1 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg2 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg3 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg4 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg5 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibretaddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibretptr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxliblen \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalldopt \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalldnoopt \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdtcachehit \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdsmapcachehit \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdscachehit \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdtcachemiss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdsmapcachemiss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdscachemiss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval idle_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval total_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocuspush_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncpush_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocuspop_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncpop_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusbranchpush \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusbranchpop \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncbranchpush \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncbranchpop \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncloss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestinfo \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlossinfo \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlossrecord \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlosscuscount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlossfunccount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusmax \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncmax \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlosstaraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatesttaraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval shdstackmax \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalstcount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalldcount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalcallcount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalcallexceptioncount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\tval rdtreaddebug_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//latency check\n\t/*\n\tval lat_st_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ld_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ret_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_call_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libst_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libld_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libstld_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_st_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ld_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_call_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libst_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libld_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libstld_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ret_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_st_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_st_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ld_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ld_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ret_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ret_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_call_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_call_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libst_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libst_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libld_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libld_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libstld_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libstld_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_cate \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t*/\n\t//latency check FSM parameters\n\tdef LAT_IDLE: Int \u003d 0\n\tdef LAT_WAIT_ENQ: Int \u003d 1\n\tdef LAT_WAIT_POP: Int \u003d 2\n\tdef LAT_WAIT_END: Int \u003d 3\n\t\n\t//timeout\n\tval timeout \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tdef maxtimeout: Int \u003d 300\n\t\n\t//record\n\tval violations\u003dReg(init \u003d Bits(0,width \u003d 16))\n\tval errorcount\u003dReg(init \u003d Bits(0,width \u003d 32))\n\tval totalcount\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//opt buf\n\tval ldoptbuf \u003d Module(new DFILdOptBuf(ldopbufsize, xLen)(outer.p))\n\tval ldopt_rst \u003d Reg(init \u003d Bool(false))\n\tval ldopt_rw \u003d Reg(init \u003d Bits(0,width \u003d 1))\n\tval ldopt_id \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval ldopt_taraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tldoptbuf.io.rst :\u003d ldopt_rst\n\tldoptbuf.io.rw :\u003d ldopt_rw\n\tldoptbuf.io.id :\u003d ldopt_id\n\tldoptbuf.io.taraddr :\u003d ldopt_taraddr\n\tval ldopt_red \u003d Reg(init \u003d Bool(false))\n\n\t//shadow stack\n\t//not use yet\n\t//val shdstack \u003d Mem(shdstacksize, Bits(width \u003d xLen))\n\tval shdstkaddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval shdstkcount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval shdstkdatain \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t//val shdstkdataout \u003d shdstack(shdstkaddr - Bits(1))\n\t//shdstack(shdstkaddr) :\u003d shdstkdatain\n\t\n\t//FIFO\n\tval fifocustom \u003d Module(new Queue(Bits(width \u003d 64+22), fifostldsize))\n\tval fifocusenqvalid \u003d Reg(init \u003d Bool(false))\n\tval fifocusdeqready \u003d Reg(init \u003d Bool(false))\n\tval fifocusdatain \u003d Reg(init \u003d Bits(0,width \u003d 64+22))\n\tfifocustom.io.enq.valid :\u003d fifocusenqvalid\n\tfifocustom.io.enq.bits :\u003d fifocusdatain\n\tfifocustom.io.deq.ready :\u003d fifocusdeqready\n\tval fifocuscount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval waitinginfifocus \u003d Reg(init \u003d Bool(false))\n\t\n\tval fifofunc \u003d Module(new Queue(Bits(width \u003d 2+1+1+16+64+64*3), fifofuncsize))\n\tval fifofuncenqvalid \u003d Reg(init \u003d Bool(false))\n\tval fifofuncdeqready \u003d Reg(init \u003d Bool(false))\n\tval fifofuncdatain \u003d Reg(init \u003d Bits(0,width \u003d 2+1+1+16+64+64*3))\n\tfifofunc.io.enq.valid :\u003d fifofuncenqvalid\n\tfifofunc.io.enq.bits :\u003d fifofuncdatain\n\tfifofunc.io.deq.ready :\u003d fifofuncdeqready\n\tval fifofunccount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval waitinginfifofunc \u003d Reg(init \u003d Bool(false))\n\tval waitingcallfifo \u003d Reg(init \u003d Bool(false))\n\t\n\t/*\n\tval testfifo \u003d Module(new Queue(Bits(width \u003d 8), 4))\n\tval fifotestvalid \u003d Reg(init \u003d Bool(false))\n\tval fifotestready \u003d Reg(init \u003d Bool(false))\n\tval fifotestdatain \u003d Reg(init \u003d Bits(0,width \u003d 8))\n\ttestfifo.io.enq.valid :\u003d fifotestvalid\n\ttestfifo.io.enq.bits :\u003d fifotestdatain\n\ttestfifo.io.deq.ready :\u003d fifotestready\n\tval fifostate \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\twhen(fifostate\u003cBits(4)){\n\t\twhen(testfifo.io.enq.fire()){\n\t\t\tprintf(\"enq data %x\\n\",fifotestdatain)\n\t\t\tfifostate :\u003d fifostate + Bits(1)\n\t\t\tfifotestvalid :\u003d Bool(false)\n\t\t}.otherwise{\n\t\t\tfifotestvalid :\u003d Bool(true)\n\t\t\tfifotestdatain :\u003d fifostate + Bits(1)\n\t\t}\n\t}.otherwise{\n\t\twhen(testfifo.io.deq.fire()){\n\t\t\tprintf(\"deq data %x\\n\",testfifo.io.deq.bits)\n\t\t}.otherwise{\n\t\t\tfifotestready :\u003d Bool(true)\n\t\t}\n\t}\n\t*/\n\t/*\n\tval fifocustom\u003dMem(4,Bits(width \u003d 32))\n\tval fifocusaddrwidth\u003dlog2Up(4)\n\tval fifocushead \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocustail \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusdatain \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tfifocustom(fifocustail(fifocusaddrwidth-1,0)) :\u003d fifocusdatain\n\tval fifocusdataout\u003dfifocustom(fifocushead(fifocusaddrwidth-1,0))\n\t*/\n\t/*\n\tval fifocustom \u003d Module(new DFIFIFO(4, 32)(outer.p))\n\tval fifocusrst \u003d Reg(init \u003d Bool(false))\n\tval fifocuswrite \u003d Reg(init \u003d Bool(false))\n\tval fifocusdatain \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusread \u003d Reg(init \u003d Bool(false))\n\tfifocustom.io.rst :\u003d fifocusrst\n\tfifocustom.io.write :\u003d fifocuswrite\n\tfifocustom.io.datain :\u003d fifocusdatain\n\tfifocustom.io.read :\u003d fifocusread\n\t\n\tval fifostate \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\tfifostate :\u003d fifostate + Bits(1)\n\t\n\twhen(fifostate \u003c\u003d Bits(20)){\n\twhen(!fifocustom.io.full){\n\t\tfifocuswrite :\u003d Bool(true)\n\t\tfifocusdatain :\u003d io.dfi.bits.cycle_now+Bits(1)\n\t\tprintf(\"FIFO write %x\\n\",io.dfi.bits.cycle_now+Bits(1))\n\t}.otherwise{\n\t\tfifocuswrite :\u003d Bool(false)\n\t}\n\t\n\twhen(!fifocustom.io.empty){\n\t\tfifocusread :\u003d Bool(true)\n\t\tfifocusdatain :\u003d io.dfi.bits.cycle_now\n\t\tprintf(\"not empty FIFO read %x\\n\",fifocustom.io.dataout)\n\t}.otherwise{\n\t\tprintf(\"FIFO read %x\\n\",fifocustom.io.dataout)\n\t\tfifocusread :\u003d Bool(false)\n\t}\n\t}\n\t*/\n\t/*\n\twhen(fifostate\u003d\u003d\u003dBits(0)){\n\t\twhen(!fifocustom.io.full){\n\t\t\tfifocuswrite :\u003d Bool(true)\n\t\t\tfifocusdatain :\u003d io.dfi.bits.cycle_now+Bits(1)\n\t\t\tprintf(\"FIFO write %x\\n\",io.dfi.bits.cycle_now+Bits(1))\n\t\t}.otherwise{\n\t\t\tfifocuswrite :\u003d Bool(false)\n\t\t\tfifostate :\u003d Bits(1)\n\t\t}\n\t}.elsewhen(fifostate\u003c\u003dBits(15)){\n\t\twhen(!fifocustom.io.empty){\n\t\t\tfifocusread :\u003d Bool(true)\n\t\t\tfifocusdatain :\u003d io.dfi.bits.cycle_now\n\t\t\tprintf(\"not empty FIFO read %x\\n\",fifocustom.io.dataout)\n\t\t}.otherwise{\n\t\t\tprintf(\"FIFO read %x\\n\",fifocustom.io.dataout)\n\t\t\tfifocusread :\u003d Bool(false)\n\t\t\tfifostate :\u003d fifostate + Bits(1)\n\t\t}\n\t}\n\t*/\n\t/*\n\t//funcmode 2, iscall 1, retpointer 64, arg0-2 64*3,\n\tval fifofunc \u003d Module(new DFIFIFO(4, 2+1+64+64*3)(outer.p))\n\tval fifofuncrst \u003d Reg(init \u003d Bool(false))\n\tval fifofuncwrite \u003d Reg(init \u003d Bool(false))\n\tval fifofuncdatain \u003d Reg(init \u003d Bits(0,width \u003d 2+1+64+64*3))\n\tval fifofuncread \u003d Reg(init \u003d Bool(false))\n\tfifofunc.io.rst :\u003d fifofuncrst\n\tfifofunc.io.write :\u003d fifofuncwrite\n\tfifofunc.io.datain :\u003d fifofuncdatain\n\tfifofunc.io.read :\u003d fifofuncread\n\t*/\n\t\n\t//FSM parameters\n\tdef IDLE: Int \u003d 0\n\tdef WAIT: Int \u003d 1\n\tdef WRITERDT: Int \u003d 2\n\tdef READRDT: Int \u003d 3\n\tdef READRDSMAP: Int \u003d 4\n\tdef READRDS: Int \u003d 5\n\tdef CHECK: Int \u003d 6\n\tdef FUNCSTATE: Int \u003d 7\n\tdef WRITELDTRACE: Int \u003d 8\n\tdef WRITEDEBUG: Int \u003d 9\n\tdef ERROR: Int \u003d 10\n\tdef REPORT: Int \u003d 11\n\tdef READRDTRDSMAP: Int \u003d 12\n\tdef READRDTCACHE: Int \u003d 13\n\tdef READRDSMAPCACHE: Int \u003d 14\n\tdef CACHERESET: Int \u003d 15\n\tdef READSTOPCOND: Int \u003d 16\n\t\n\tval state \u003d Reg(init \u003d Bits(IDLE,width \u003d 8))\n\tval nstate \u003d Reg(init \u003d Bits(IDLE,width \u003d 8))\n\tval pstate \u003d Reg(init \u003d Bits(IDLE,width \u003d 8))\n\t\n\tval ldstate \u003d Reg(init \u003d Bits(IDLE,width \u003d 8))\n\t\n\t//control\n\tval busystld \u003d Reg(init \u003d Bool(false))\n\tval busyfunc \u003d Reg(init \u003d Bool(false))\n\tval stallfunc \u003d Reg(init \u003d Bool(false))\n\tval stallstld \u003d Reg(init \u003d Bool(false))\n\t\n    io.corestall :\u003d stallfunc || stallstld\n\t//val cmd \u003d Queue(io.cmd)\n\tval cmd \u003d io.cmd\n\tcmd.ready :\u003d !(busystld || busyfunc) //\u0026\u0026 (violations \u003d\u003d\u003d Bits(0))\n\t\n\t//wb, not use\n\tio.resp.valid :\u003d Bool(false)//cmd.valid \u0026\u0026 cmd.bits.inst.xd \u0026\u0026 io.mem.req.ready\n\tio.resp.bits.rd :\u003d cmd.bits.inst.rd\n\tio.resp.bits.data :\u003d Bits(0)//wdata\n\tio.busy :\u003d Bool(false) //cmd.valid || busy\n\tio.interrupt :\u003d Bool(false)\n\t\n\t//get the DFI info\n\tval info\u003d(cmd.bits.inst.funct\u003c\u003c15)|(cmd.bits.inst.rs2\u003c\u003c10)|(cmd.bits.inst.rs1\u003c\u003c5)|(cmd.bits.inst.rd)\n\t\n\t//memory control\n\tval memvalid \u003d Reg(init \u003d Bool(false))\n\tval memaddr\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval memaddrmod\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval memtag \u003d Reg(init \u003d Bits(0,width \u003d xLen))//used for record the memtype of the request\n\tval memdatain\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval memdataout\u003dMux(memtag(1) \u003d\u003d\u003d Bits(1),Mux(memtag(0) \u003d\u003d\u003d Bits(1), io.mem.resp.bits.data, io.mem.resp.bits.data(31,0)), Mux(memtag(0) \u003d\u003d\u003d Bits(1), io.mem.resp.bits.data(15,0), io.mem.resp.bits.data(7,0)))\n\tval memw\u003dReg(init \u003d Bool(false))\n\tval memtype\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\t\n\tval pmemaddr\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval pmemdatain\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval pmemw\u003dReg(init \u003d Bool(false))\n\tval pmemtype\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//val memaddrfix \u003d Mux((memaddr\u003e\u003dBits(0xf4084000L) \u0026\u0026 memaddr\u003cBits(0xf4084000L+0x6000000L)), memaddr, Bits(0xf4084000L+0x4400000L))\n\tval memaddrfix \u003d memaddr\n\t\n\tval memoffdata \u003d memdatain\u003c\u003c(((memaddrfix(2,0))\u003c\u003c3))\n\t\n\tio.mem.req.valid :\u003d memvalid//cmd.valid \u0026\u0026 ((funct \u003d\u003d\u003d UInt(1)) || (funct \u003d\u003d\u003d UInt(2))) // \u0026\u0026 !busy\n\tio.mem.req.bits.addr :\u003d memaddrfix\n\tio.mem.req.bits.tag :\u003d memtag\n\tio.mem.req.bits.cmd :\u003d Mux(memw,M_XWR,M_XRD)//M_XRD // perform a load (M_XWR for stores)\n\tio.mem.req.bits.typ :\u003d Mux(memtype(1) \u003d\u003d\u003d Bits(1),Mux(memtype(0) \u003d\u003d\u003d Bits(1), MT_D, MT_W), Mux(memtype(0) \u003d\u003d\u003d Bits(1), MT_H, MT_B))//memtype // D \u003d 8 bytes, W \u003d 4, H \u003d 2, B \u003d 1\n\tio.mem.req.bits.data :\u003d memoffdata\n\tio.mem.req.bits.phys :\u003d Mux(SIMULATION,Bool(false),Bool(true))//Bool(true)\n\t\n\t//caches\n\tval rdtcache \u003d Mem((1\u003c\u003crdtcacheaddrwidth), Bits(width \u003d rdtaddrwidth-rdtcacheaddrwidth+64))\n\tval rdtcwaddr \u003d Reg(init \u003d Bits(0,width \u003d rdtcacheaddrwidth))\n\tval rdtcraddr \u003d Reg(init \u003d Bits(0,width \u003d rdtcacheaddrwidth))\n\tval rdtcdatain \u003d Reg(init \u003d Bits(0,width \u003d rdtaddrwidth-rdtcacheaddrwidth-2+64))\n\tval rdtcdataout \u003d rdtcache(rdtcraddr)\n\trdtcache(rdtcwaddr) :\u003d rdtcdatain\n\tval rdtcprobing \u003d Reg(init \u003d Bool(false))\n\t\n\tval rdsmapcache \u003d Mem((1\u003c\u003crdsmapcacheaddrwidth), Bits(width \u003d rdsmapaddrwidth-rdsmapcacheaddrwidth+64))\n\tval rdsmapcwaddr \u003d Reg(init \u003d Bits(0,width \u003d rdsmapcacheaddrwidth))\n\tval rdsmapcraddr \u003d Reg(init \u003d Bits(0,width \u003d rdsmapcacheaddrwidth))\n\tval rdsmapcdatain \u003d Reg(init \u003d Bits(0,width \u003d rdsmapaddrwidth-rdsmapcacheaddrwidth+64))\n\tval rdsmapcdataout \u003d rdsmapcache(rdsmapcraddr)\n\trdsmapcache(rdsmapcwaddr) :\u003d rdsmapcdatain\n\tval rdsmapcprobing \u003d Reg(init \u003d Bool(false))\n\t\n\tval rdscache \u003d Mem((1\u003c\u003crdscacheaddrwidth), Bits(width \u003d rdsaddrwidth-rdscacheaddrwidth+64))\n\tval rdscwaddr \u003d Reg(init \u003d Bits(0,width \u003d rdscacheaddrwidth))\n\tval rdscraddr \u003d Reg(init \u003d Bits(0,width \u003d rdscacheaddrwidth))\n\tval rdscdatain \u003d Reg(init \u003d Bits(0,width \u003d rdsaddrwidth-rdscacheaddrwidth+64))\n\tval rdscdataout \u003d rdscache(rdscraddr)\n\trdscache(rdscwaddr) :\u003d rdscdatain\n\tval rdscprobing \u003d Reg(init \u003d Bool(false))\n\t\n\t//dfi check\n\tval checkmatch0\u003d(rdsp)\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp)\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 io.mem.resp.bits.data(15,0) \u003d\u003d\u003d prevwid\n\tval checkmatch1\u003d(rdsp+Bits(1))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(1))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 io.mem.resp.bits.data(31,16) \u003d\u003d\u003d prevwid\n\tval checkmatch2\u003d(rdsp+Bits(2))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(2))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 io.mem.resp.bits.data(47,32) \u003d\u003d\u003d prevwid\n\tval checkmatch3\u003d(rdsp+Bits(3))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(3))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 io.mem.resp.bits.data(63,48) \u003d\u003d\u003d prevwid\n\tval onematched\u003d(checkmatch0 || checkmatch1) || (checkmatch2 || checkmatch3)\n\t\n\tval ccheckmatch0\u003d(rdsp)\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp)\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 rdscdataout(15,0) \u003d\u003d\u003d prevwid\n\tval ccheckmatch1\u003d(rdsp+Bits(1))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(1))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 rdscdataout(31,16) \u003d\u003d\u003d prevwid\n\tval ccheckmatch2\u003d(rdsp+Bits(2))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(2))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 rdscdataout(47,32) \u003d\u003d\u003d prevwid\n\tval ccheckmatch3\u003d(rdsp+Bits(3))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(3))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 rdscdataout(63,48) \u003d\u003d\u003d prevwid\n\tval conematched\u003d(ccheckmatch0 || ccheckmatch1) || (ccheckmatch2 || ccheckmatch3)\n\t\n\twhen(io.dfi.bits.valid){\n\t\twhen(io.dfi.bits.cmd\u003d\u003d\u003dM_XWR){\n\t\t\tsaddrbuf(saddrbuf_p(log2Up(bufsize)-1,0)) :\u003d io.dfi.bits.taraddr\n\t\t\tscyclebuf(saddrbuf_p(log2Up(bufsize)-1,0)) :\u003d io.dfi.bits.cycle\n\t\t\tsaddrbuf_p :\u003d saddrbuf_p + Bits(1)\n\t\t}\n\t\t.elsewhen(io.dfi.bits.cmd\u003d\u003d\u003dM_XRD){\n\t\t\tladdrbuf(laddrbuf_p(log2Up(bufsize)-1,0)) :\u003d io.dfi.bits.taraddr\n\t\t\tlcyclebuf(laddrbuf_p(log2Up(bufsize)-1,0)) :\u003d io.dfi.bits.cycle\n\t\t\tladdrbuf_p :\u003d laddrbuf_p + Bits(1)\n\t\t}.otherwise{}\n\t}.otherwise{}\n\n\t//this is for debug\n\twhen(cmd.fire()){\n\t\tstaraddrs(staraddrs_p(log2Up(bufsize)-1,0)) :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\tstaraddrs_p :\u003d staraddrs_p + Bits(1)\n\t\t\n\t\tltaraddrs(ltaraddrs_p(log2Up(bufsize)-1,0)) :\u003d laddrbuf(laddrbuf_p-Bits(1))\n\t\tltaraddrs_p :\u003d ltaraddrs_p + Bits(1)\n\t}.otherwise{}\n\t\n\tval taraddr_recorded\u003dReg(init \u003d Bool(false))\n\twhen(cmd.valid \u0026\u0026 cmd.ready){\n\t\twhen(!taraddr_recorded){\n\t\t\tstaraddr :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\tltaraddr :\u003d laddrbuf(laddrbuf_p-Bits(1))\n\t\t}\n\t\ttaraddr_recorded :\u003d Bool(false)\n\t}.elsewhen(cmd.valid \u0026\u0026 !cmd.ready){\n\t\twhen(!taraddr_recorded){\n\t\t\ttaraddr_recorded :\u003d Bool(true)\n\t\t\tstaraddr :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\tltaraddr :\u003d laddrbuf(laddrbuf_p-Bits(1))\n\t\t}\n\t}.otherwise{}\n\t\n\t//recieve func request\n\t//note that func req and st/ld req may come at the same cycle, accually it is func req is earlier than st/ld req, because the delay\n\t//funcmode 2, iscall 1, callremain 1, id 16, retpointer 64, arg0-2 64*3,\n\twhen(fifofuncmax \u003c fifofunccount){\n\t\tfifofuncmax :\u003d fifofunccount\n\t}.otherwise{}\n\t\n\twhen(fifofunc.io.enq.fire() \u0026\u0026 fifofunc.io.deq.fire()){\n\t}.elsewhen(fifofunc.io.enq.fire()){\n\t\tfifofunccount :\u003d fifofunccount + Bits(1)\n\t}.elsewhen(fifofunc.io.deq.fire()){\n\t\twhen(fifofunccount \u003e Bits(0)){\n\t\t\tfifofunccount :\u003d fifofunccount - Bits(1)\n\t\t}\n\t}.otherwise{}\n\n\twhen(fifofunc.io.enq.fire()){\n\t\tfifofuncpush_cycle :\u003d fifofuncpush_cycle + Bits(1)\n\t\tfifofuncenqvalid :\u003d Bool(false)\n\t\twaitinginfifofunc :\u003d Bool(false)\n\t\tbusyfunc :\u003d Bool(false)\n\t}.elsewhen(waitinginfifofunc){\n\t\tfifofuncpush_cycle :\u003d fifofuncpush_cycle + Bits(1)\n\t\tbusyfunc :\u003d Bool(true)\n\t}.otherwise{\n\t\tbusyfunc :\u003d Bool(false)\n\t}\n\t//receive func FIFO\n\twhen(fifofunc.io.deq.fire()){\n\t\tfifofuncbranchpop :\u003d fifofuncbranchpop + Bits(1)\n\t\tfifofuncdeqready :\u003d Bool(false)\n\t\twaitingcallfifo :\u003d Bool(false)\n\t\twhen(fifofunc.io.deq.bits(64*4+17) \u003d\u003d\u003d Bits(1)){//call\n\t\t\twhen((fifofunc.io.deq.bits(64*3-1,64*2) \u0026 UInt((1\u003c\u003caddrshift)-1)) \u003e UInt(0)){\n\t\t\t\ttotalfunccount(0) :\u003d (fifofunc.io.deq.bits(64*3-1,64*2)\u003e\u003eaddrshift)+UInt(1)\n\t\t\t}.otherwise{\n\t\t\t\ttotalfunccount(0) :\u003d (fifofunc.io.deq.bits(64*3-1,64*2)\u003e\u003eaddrshift)\n\t\t\t}\n\t\t\t\n\t\t\tid(1):\u003dfifofunc.io.deq.bits(64*4+16-1,64*4)\n\t\t\tfuncmode(1) :\u003d fifofunc.io.deq.bits(64*4+19,64*4+18)\n\t\t\tcallremain(1) :\u003d fifofunc.io.deq.bits(64*4+16)\n\t\t\tfunciscall(0) :\u003d Bool(true)\n\t\t\tfuncarg0(0) :\u003d fifofunc.io.deq.bits(64*1-1,0)\n\t\t\tfuncarg1(0) :\u003d fifofunc.io.deq.bits(64*2-1,64*1)\n\t\t\tfuncarg2(0) :\u003d fifofunc.io.deq.bits(64*3-1,64*2)\n\t\t\t//funcretaddr(0) :\u003d io.dfi.bits.funcretaddr\n\t\t\tfuncretpointer(0) :\u003d fifofunc.io.deq.bits(64*4-1,64*3) //return address\u0027s pointer\n\t\t\tbrremain(0) :\u003d Bool(true)\n\t\t\t\n\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 2.5 func FIFO OUT, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"function call, from FIFO, %x\\n\",fifofunc.io.deq.bits)\n\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 2.5\\n\")\n\t\t\tbrneedprocess(0) :\u003d Bool(true)\n\t\t}.otherwise{//ret\n\t\t\t\n\t\t\tfuncmode(1) :\u003d fifofunc.io.deq.bits(64*4+19,64*4+18)\n\t\t\tcallremain(1) :\u003d fifofunc.io.deq.bits(64*4+16)\n\t\t\tfunciscall(0) :\u003d Bool(false)\n\t\t\tfuncarg0(0) :\u003d UInt(0)\n\t\t\tfuncarg1(0) :\u003d UInt(0)\n\t\t\tfuncarg2(0) :\u003d UInt(0)\n\t\t\tfuncretpointer(0) :\u003d fifofunc.io.deq.bits(64*4-1,64*3) //return address\u0027s pointer\n\t\t\tbrremain(0) :\u003d Bool(true)\n\t\t\t\n\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 2.5 func FIFO OUT, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"function ret, from FIFO, %x\\n\",fifofunc.io.deq.bits)\n\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 2.5\\n\")\n\t\t\tbrneedprocess(0) :\u003d Bool(true)\n\t\t}\n\t}\n\t.otherwise{\n\t\twhen(state \u003d\u003d\u003d Bits(IDLE) \u0026\u0026 slneedprocess \u003d\u003d\u003d Bits(0) \u0026\u0026 !brneedprocess(0) \u0026\u0026 waitingcallfifo){\n\t\t\tfifofuncdeqready :\u003d Bool(true)\n\t\t}.otherwise{\n\t\t\tfifofuncdeqready :\u003d Bool(false)\n\t\t}\n\t\t/*\n\t\twhen(fifofuncdeqready \u0026\u0026 timeout\u003cUInt(maxtimeout)){\n\t\t\ttimeout :\u003d timeout + Bits(1)\n\t\t}.elsewhen(fifofuncdeqready \u0026\u0026 timeout\u003e\u003dUInt(maxtimeout)){\n\t\t\tfifofuncdeqready :\u003d Bool(false)\n\t\t\twaitingcallfifo :\u003d Bool(false)\n\t\t\tfifofuncloss :\u003d fifofuncloss + Bits(1)\n\t\t\tfifofunclatestlossinfo :\u003d fifofunclatestinfo\n\t\t\tfifofunclatestlosstaraddr :\u003d fifofunclatesttaraddr\n\t\t\tfifofunclatestlosscuscount :\u003d fifocuscount\n\t\t\tfifofunclatestlossfunccount :\u003d fifofunccount\n\t\t\tfifofunclatestlossrecord :\u003d (fifofuncdeqready\u003c\u003c28)|(fifofuncenqvalid\u003c\u003c27)|(fifocusdeqready\u003c\u003c26)|(fifocusenqvalid\u003c\u003c25)|(waitinginfifofunc\u003c\u003c24)|(waitinginfifocus\u003c\u003c23)|(stallfunc\u003c\u003c22)|(busystld\u003c\u003c21)|(brneedprocess(0)\u003c\u003c20)|(slneedprocess\u003c\u003c18)|(waitingcallfifo\u003c\u003c17)|(waitingcall\u003c\u003c16)|state\n\t\t\ttimeout :\u003d Bits(0)\n\t\t}.otherwise{\n\t\t\ttimeout :\u003d Bits(0)\n\t\t}*/\n\t}\n\t\n\t//receive st/ld request\n\twhen(fifocusmax \u003c fifocuscount){\n\t\tfifocusmax :\u003d fifocuscount\n\t}.otherwise{}\n\t\n\twhen(fifocustom.io.enq.fire() \u0026\u0026 fifocustom.io.deq.fire()){\n\t}.elsewhen(fifocustom.io.enq.fire()){\n\t\tfifocuscount :\u003d fifocuscount + Bits(1)\n\t}.elsewhen(fifocustom.io.deq.fire()){\n\t\twhen(fifocuscount \u003e Bits(0)){\n\t\t\tfifocuscount :\u003d fifocuscount - Bits(1)\n\t\t}\n\t}.otherwise{}\n\t\n\twhen(fifocustom.io.enq.fire()){\n\t\tfifocuspush_cycle :\u003d fifocuspush_cycle + Bits(1)\n\t\tfifocusenqvalid :\u003d Bool(false)\n\t\twaitinginfifocus :\u003d Bool(false)\n\t\tbusystld :\u003d Bool(false)\n\t}.elsewhen(waitinginfifocus){\n\t\tfifocuspush_cycle :\u003d fifocuspush_cycle + Bits(1)\n\t\tbusystld :\u003d Bool(true)\n\t}.otherwise{\n\t\tbusystld :\u003d Bool(false)\n\t}\n\twhen(cmd.fire()){\n\t\tfifocuspush_cycle :\u003d fifocuspush_cycle + Bits(1)\n\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\twhen(!SIMULATION){\n\t\t\t\t//addrrdt :\u003d Bits(0xe0400000L)\n\t\t\t\taddrrdt :\u003d Bits(0xf4084000L+0x400000L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\taddrrdt :\u003d staraddr//saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\tprintf(\"rdt: %x, (now cycle: %x)\\n\", staraddr,io.dfi.bits.cycle_now)//saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t}.otherwise{\n\t\t\t\t\taddrrdt :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\tprintf(\"rdt: %x, (now cycle: %x)\\n\", saddrbuf(saddrbuf_p-Bits(1)),io.dfi.bits.cycle_now)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\twhen(!SIMULATION){\n\t\t\t\t//addrrds :\u003d Bits(0xe4400000L)\n\t\t\t\taddrrds :\u003d Bits(0xf4084000L+0x4400000L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\taddrrds :\u003d staraddr//saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\tprintf(\"rds: %x\\n\", staraddr)//saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t}.otherwise{\n\t\t\t\t\taddrrds :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\tprintf(\"rds: %x\\n\", saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t}\n\t\t\t}\n\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\twhen(info(17) \u003d\u003d\u003d Bits(1)){\n\t\t\t\t\n\t\t\t}.elsewhen(info(18) \u003d\u003d\u003d Bits(1)){\n\t\t\t\tfifocusdatain :\u003d info\n\t\t\t\twaitinginfifocus :\u003d Bool(true)\n\t\t\t\tfifocusenqvalid :\u003d Bool(true)\n\t\t\t\tbusystld :\u003d Bool(true)\n\t\t\t}.otherwise{\n\t\t\t\twhen(!SIMULATION){\n\t\t\t\t\t//addrdebug :\u003d Bits(0xe0000000L)\n\t\t\t\t\taddrdebug :\u003d Bits(0xf4084000L)\n\t\t\t\t}.otherwise{\n\t\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\t\taddrdebug :\u003d staraddr//saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\t\tprintf(\"debug buffer: %x\\n\", staraddr)//saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\taddrdebug :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\t\tprintf(\"debug buffer: %x\\n\", saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfifocusdatain :\u003d info\n\t\t\t\twaitinginfifocus :\u003d Bool(true)\n\t\t\t\tfifocusenqvalid :\u003d Bool(true)\n\t\t\t\tbusystld :\u003d Bool(true)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 1 ld/st FIFO IN, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\t\tprintf(\"DFI request recieved\\n\")\n\t\t\t\tprintf(\"info: %x\\n\",info)\n\t\t\t\tprintf(\"thread pointer %x\\n\",io.dfi.bits.threadptr)\n\t\t\t\tprintf(\"%x/%x DFI process errors\\n\",errorcount,totalcount)\n\t\t\t\tprintf(\"return address: %x, stack address: %x, func arg0: %x, func arg1: %x, func arg2: %x\\n\",io.dfi.bits.funcretaddr,io.dfi.bits.funcstackaddr,io.dfi.bits.funcarg0,io.dfi.bits.funcarg1,io.dfi.bits.funcarg2)\n\t\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 1 \\n\")\n\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\tfifocusbranchpush :\u003d fifocusbranchpush + Bits(1)\n\t\t\t\t\tfifocusdatain :\u003d (((fifofuncdeqready\u003c\u003c28)|(fifofuncenqvalid\u003c\u003c27)|(fifocusdeqready\u003c\u003c26)|(fifocusenqvalid\u003c\u003c25)|(waitinginfifofunc\u003c\u003c24)|(waitinginfifocus\u003c\u003c23)|(stallfunc\u003c\u003c22)|(busystld\u003c\u003c21)|(brneedprocess(0)\u003c\u003c20)|(slneedprocess\u003c\u003c18)|(waitingcallfifo\u003c\u003c17)|(waitingcall\u003c\u003c16)|state)\u003c\u003c(22+8))|(fifocuscount\u003c\u003c22)|info\n\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){\n\t\t\t\t\t\tfifofuncbranchpush :\u003d fifofuncbranchpush + Bits(1)\n\t\t\t\t\t\tfifofuncdatain :\u003d (info(18,17)\u003c\u003c(64*4+18))|(Bits(1)\u003c\u003c(64*4+17))|(Mux(info(18,17) \u003e Bits(0),Bits(1),Bits(0))\u003c\u003c(64*4+16))|(info(15,0)\u003c\u003c(64*4))|((io.dfi.bits.funcstackaddr - UInt(8))\u003c\u003c(64*3))|(io.dfi.bits.funcarg2\u003c\u003c(64*2))|(io.dfi.bits.funcarg1\u003c\u003cUInt(64))|(io.dfi.bits.funcarg0)\n\t\t\t\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 1.5 func FIFO IN, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\t\t\t\tprintf(\"function call, to %x\\n\",io.dfi.bits.brtarget)\n\t\t\t\t\t\tprintf(\"return address: %x, stack address: %x, func arg0: %x, func arg1: %x, func arg2: %x\\n\",io.dfi.bits.funcretaddr,io.dfi.bits.funcstackaddr,io.dfi.bits.funcarg0,io.dfi.bits.funcarg1,io.dfi.bits.funcarg2)\n\t\t\t\t\t\tprintf(\"push to FIFO: %x\\n\",(info(18,17)\u003c\u003c(64*4+18))|(Bits(1)\u003c\u003c(64*4+17))|(Mux(info(18,17) \u003e Bits(0),Bits(1),Bits(0))\u003c\u003c(64*4+16))|(info(15,0)\u003c\u003c(64*4))|((io.dfi.bits.funcstackaddr - UInt(8))\u003c\u003c(64*3))|(io.dfi.bits.funcarg2\u003c\u003c(64*2))|(io.dfi.bits.funcarg1\u003c\u003cUInt(64))|(io.dfi.bits.funcarg0))\n\t\t\t\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 1.5\\n\")\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tfifofuncbranchpush :\u003d fifofuncbranchpush + Bits(1)\n\t\t\t\t\t\tfifofuncdatain :\u003d (info(18,17)\u003c\u003c(64*4+18))|(Bits(0)\u003c\u003c(64*4+17))|(Mux(info(18,17) \u003e Bits(0),Bits(1),Bits(0))\u003c\u003c(64*4+16))|(info(15,0)\u003c\u003c(64*4))|((io.dfi.bits.funcstackaddr - UInt(8))\u003c\u003c(64*3))\n\t\t\t\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 1.5 func FIFO IN, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\t\t\t\tprintf(\"function return, to %x\\n\",io.dfi.bits.brtarget)\n\t\t\t\t\t\tprintf(\"return address: %x, stack address: %x, func arg0: %x, func arg1: %x, func arg2: %x\\n\",io.dfi.bits.funcretaddr,io.dfi.bits.funcstackaddr,io.dfi.bits.funcarg0,io.dfi.bits.funcarg1,io.dfi.bits.funcarg2)\n\t\t\t\t\t\tprintf(\"push to FIFO: %x\\n\",(info(18,17)\u003c\u003c(64*4+18))|(Bits(0)\u003c\u003c(64*4+17))|(Mux(info(18,17) \u003e Bits(0),Bits(1),Bits(0))\u003c\u003c(64*4+16))|(info(15,0)\u003c\u003c(64*4))|((io.dfi.bits.funcstackaddr - UInt(8))\u003c\u003c(64*3)))\n\t\t\t\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 1.5\\n\")\n\t\t\t\t\t}\n\t\t\t\t\twaitinginfifofunc :\u003d Bool(true)\n\t\t\t\t\tfifofuncenqvalid :\u003d Bool(true)\n\t\t\t\t\tbusyfunc :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0) \u0026\u0026 info(18,17) \u003e Bits(0) \u0026\u0026 maxliblen\u003c(io.dfi.bits.funcarg2\u003e\u003eaddrshift)){\n\t\t\t\t\t\tmaxlibarg0 :\u003d io.dfi.bits.funcarg0\n\t\t\t\t\t\tmaxlibarg1 :\u003d io.dfi.bits.funcarg1\n\t\t\t\t\t\tmaxlibarg2 :\u003d io.dfi.bits.funcarg2\n\t\t\t\t\t\tmaxlibarg3 :\u003d io.dfi.bits.funcarg3\n\t\t\t\t\t\tmaxlibarg4 :\u003d io.dfi.bits.funcarg4\n\t\t\t\t\t\tmaxlibarg5 :\u003d info\n\t\t\t\t\t\tmaxlibretaddr :\u003d io.dfi.bits.funcretaddr\n\t\t\t\t\t\tmaxlibretptr :\u003d io.dfi.bits.funcstackaddr\n\t\t\t\t\t\tmaxliblen :\u003d io.dfi.bits.funcarg2\u003e\u003eaddrshift\n\t\t\t\t\t}.otherwise{}\n\t\t\t\t\t\n\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\t\tfifocusdatain :\u003d (staraddr\u003c\u003c22)|info\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tfifocusdatain :\u003d (saddrbuf(saddrbuf_p-Bits(1))\u003c\u003c22)|info\n\t\t\t\t\t}\n\t\t\t\t}.otherwise{//ld\n\t\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\t\tfifocusdatain :\u003d (ltaraddr\u003c\u003c22)|info\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tfifocusdatain :\u003d (laddrbuf(laddrbuf_p-Bits(1))\u003c\u003c22)|info\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twaitinginfifocus :\u003d Bool(true)\n\t\t\t\tfifocusenqvalid :\u003d Bool(true)\n\t\t\t\tbusystld :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\t//receive st/ld FIFO\n\twhen(fifocustom.io.deq.fire()){\n\t\tfifocusdeqready :\u003d Bool(false)\n\t\twhen(fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t}.elsewhen(fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t}.elsewhen(fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 2 FUNC FIFO OUT, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"info: %x\\n\",fifocustom.io.deq.bits)\n\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 2\\n\")\n\t\t\twhen(fifocustom.io.deq.bits(18)){\n\t\t\t\tinfor :\u003d fifocustom.io.deq.bits\n\t\t\t\tslneedprocess :\u003d Bits(2)\n\t\t\t}.otherwise{\n\t\t\t\tinfor :\u003d fifocustom.io.deq.bits\n\t\t\t\trdsmapcwaddr :\u003d Bits(0)//ready to reset rdsmapcache\n\t\t\t\trdsmapcdatain :\u003d Bits(0)\n\t\t\t\trdtcwaddr :\u003d Bits(0)\n\t\t\t\trdtcdatain :\u003d Bits(0)\n\t\t\t\trdscwaddr :\u003d Bits(0)\n\t\t\t\trdscdatain :\u003d Bits(0)\n\t\t\t\tfifocusbranchpush :\u003d Bits(0)\n\t\t\t\tfifocusbranchpop :\u003d Bits(0)\n\t\t\t\tfifofuncbranchpush :\u003d Bits(0)\n\t\t\t\tfifofuncbranchpop :\u003d Bits(0)\n\t\t\t\tfifofuncloss :\u003d Bits(0)\n\t\t\t\tfifocusmax :\u003d Bits(0)\n\t\t\t\tfifofuncmax :\u003d Bits(0)\n\t\t\t\tstop_call_count :\u003d Bits(0)\n\t\t\t\t\n\t\t\t\tslneedprocess :\u003d Bits(2)\n\t\t\t\t\n\t\t\t\twhen(fifocustom.io.deq.bits(19) \u003d\u003d\u003d UInt(1)){//debug\n\t\t\t\t\tprintf(\"WRTIE LOAD TRACE\\n\")\n\t\t\t\t\tldstate :\u003d Bits(WRITELDTRACE)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tldstate :\u003d Bits(READRDSMAP)\n\t\t\t\t}\n\t\t\t\trdtreaddebug_p :\u003d Bits(0)\n\t\t\t}\n\t\t}.elsewhen(fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 2 FUNC FIFO OUT, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"info: %x\\n\",fifocustom.io.deq.bits)\n\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 2\\n\")\n\t\t\tinfor :\u003d fifocustom.io.deq.bits\n\t\t\twhen(fifocustom.io.deq.bits(19,17) \u003e UInt(0)){\n\t\t\t\tfifocusbranchpop :\u003d fifocusbranchpop + Bits(1)\n\t\t\t\twaitingcallfifo :\u003d Bool(true)\n\t\t\t\tfifofunclatestinfo :\u003d fifocustom.io.deq.bits(21,0)\n\t\t\t\tfifofunclatesttaraddr :\u003d fifocustom.io.deq.bits(22+64-1,22)\n\t\t\t}.elsewhen(fifocustom.io.deq.bits(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\ttaraddr(0) :\u003d fifocustom.io.deq.bits(64+22-1,22)\n\t\t\t\tslneedprocess :\u003d Bits(2)\n\t\t\t}.otherwise{//ld\n\t\t\t\ttaraddr(0) :\u003d fifocustom.io.deq.bits(64+22-1,22)\n\t\t\t\tslneedprocess :\u003d Bits(2)\n\t\t\t}\n\t\t}\n\t\t.otherwise{}\n\t}\n\t.otherwise{\n\t\twhen(state \u003d\u003d\u003d Bits(IDLE) \u0026\u0026 slneedprocess \u003d\u003d\u003d Bits(0) \u0026\u0026 !brneedprocess(0) \u0026\u0026 !waitingcallfifo){\n\t\t\tfifocusdeqready :\u003d Bool(true)\n\t\t}.otherwise{\n\t\t\tfifocusdeqready :\u003d Bool(false)\n\t\t}\n\t}\n\t/*\n\t//lat check\n\t//1st lat check----------call\n\twhen(lat_call_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t\twhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//normal call\n\t\t\t\t\t\t\t\tlat_cate :\u003d Bits(0)\n\t\t\t\t\t\t\t\tlat_call_count :\u003d lat_call_count + Bits(1)\n\t\t\t\t\t\t\t\tlat_call_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_call_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_call_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_call_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_call_cycles :\u003d lat_call_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_call_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_call_fifo_red :\u003d lat_call_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_call_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_call_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_call_cycles :\u003d lat_call_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_call_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_call_fifo_red :\u003d lat_call_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_call_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_call_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_call_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_call_cycles :\u003d lat_call_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_call_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_call_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//2nd lat check----------libst\n\twhen(lat_libst_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t\twhen(info(17)\u003d\u003d\u003dUInt(1) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//write\n\t\t\t\t\t\t\t\tlat_cate :\u003d Bits(1)\n\t\t\t\t\t\t\t\tlat_libst_count :\u003d lat_libst_count + Bits(1)\n\t\t\t\t\t\t\t\tlat_libst_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_libst_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_libst_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libst_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libst_cycles :\u003d lat_libst_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libst_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libst_fifo_red :\u003d lat_libst_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_libst_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_libst_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libst_cycles :\u003d lat_libst_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libst_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libst_fifo_red :\u003d lat_libst_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_libst_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_libst_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libst_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libst_cycles :\u003d lat_libst_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_libst_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_libst_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//3rd lat check----------libld\n\twhen(lat_libld_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t\twhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//normal call\n\t\t\t\t\t\t\t}.elsewhen(info(17)\u003d\u003d\u003dUInt(1) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//write\n\t\t\t\t\t\t\t}.elsewhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(1)){//read\n\t\t\t\t\t\t\t\tlat_cate :\u003d Bits(2)\n\t\t\t\t\t\t\t\tlat_libld_count :\u003d lat_libld_count + Bits(1)\n\t\t\t\t\t\t\t\tlat_libld_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_libld_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_libld_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libld_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libld_cycles :\u003d lat_libld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libld_fifo_red :\u003d lat_libld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_libld_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_libld_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libld_cycles :\u003d lat_libld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libld_fifo_red :\u003d lat_libld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_libld_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_libld_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libld_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libld_cycles :\u003d lat_libld_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_libld_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_libld_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//4th lat check----------libstld\n\twhen(lat_libstld_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t\twhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//normal call\n\t\t\t\t\t\t\t}.elsewhen(info(17)\u003d\u003d\u003dUInt(1) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//write\n\t\t\t\t\t\t\t}.elsewhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(1)){//read\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_cate :\u003d Bits(3)\n\t\t\t\t\t\t\t\tlat_libstld_count :\u003d lat_libstld_count + Bits(1)\n\t\t\t\t\t\t\t\tlat_libstld_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_libstld_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_libstld_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libstld_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libstld_cycles :\u003d lat_libstld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libstld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libstld_fifo_red :\u003d lat_libstld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_libstld_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_libstld_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libstld_cycles :\u003d lat_libstld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libstld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libstld_fifo_red :\u003d lat_libstld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_libstld_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_libstld_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libstld_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libstld_cycles :\u003d lat_libstld_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_libstld_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_libstld_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//5th lat check----------ret\n\twhen(lat_ret_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_ret_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_ret_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlat_cate :\u003d Bits(4)\n\t\t\t\t\t\t\tlat_ret_count :\u003d lat_ret_count + Bits(1)\n\t\t\t\t\t\t\tlat_ret_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_ret_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ret_cycles :\u003d lat_ret_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_ret_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_ret_fifo_red :\u003d lat_ret_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_ret_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_ret_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ret_cycles :\u003d lat_ret_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_ret_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_ret_fifo_red :\u003d lat_ret_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_ret_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_ret_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_ret_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ret_cycles :\u003d lat_ret_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_ret_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_ret_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//6th lat check----------st\n\twhen(lat_st_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\tlat_st_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\tlat_st_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlat_cate :\u003d Bits(5)\n\t\t\t\t\t\tlat_st_count :\u003d lat_st_count + Bits(1)\n\t\t\t\t\t\tlat_st_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_st_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_st_cycles :\u003d lat_st_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_st_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_st_fifo_red :\u003d lat_st_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_st_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_st_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_st_cycles :\u003d lat_st_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_st_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_st_fifo_red :\u003d lat_st_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_st_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_st_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_st_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_st_cycles :\u003d lat_st_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_st_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_st_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//7th lat check----------ld\n\twhen(lat_ld_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\tlat_ld_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\tlat_ld_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlat_cate :\u003d Bits(6)\n\t\t\t\t\t\tlat_ld_count :\u003d lat_ld_count + Bits(1)\n\t\t\t\t\t\tlat_ld_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_ld_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ld_cycles :\u003d lat_ld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_ld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_ld_fifo_red :\u003d lat_ld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_ld_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_ld_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ld_cycles :\u003d lat_ld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_ld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_ld_fifo_red :\u003d lat_ld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_ld_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_ld_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_ld_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ld_cycles :\u003d lat_ld_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_ld_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_ld_state :\u003d Bits(LAT_IDLE)\n\t}\n\t*/\n\t//ldopt\n\twhen(fifofunc.io.deq.fire()){\n\t\tldopt_rst :\u003d Bool(true)\n\t\tldopt_red :\u003d Bool(false)\n\t}.elsewhen(fifocustom.io.deq.fire() \u0026\u0026 fifocustom.io.deq.bits(21,20) \u003d/\u003d UInt(0)){\n\t\tldopt_rst :\u003d Bool(true)\n\t\tldopt_red :\u003d Bool(false)\n\t}.elsewhen(fifocustom.io.deq.fire() \u0026\u0026 fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\tldopt_rst :\u003d Bool(false)\n\t\tldopt_rw :\u003d fifocustom.io.deq.bits(16)\n\t\tldopt_id :\u003d fifocustom.io.deq.bits(15,0)\n\t\twhen(fifocustom.io.deq.bits(16)\u003d\u003d\u003dBits(0)){\n\t\t\tldopt_taraddr :\u003d fifocustom.io.deq.bits(64+22-1,22)\n\t\t}.otherwise{\n\t\t\tldopt_taraddr :\u003d fifocustom.io.deq.bits(64+22-1,22)\n\t\t}\n\t\tldopt_red :\u003d Bool(false)\n\t}.otherwise{\n\t\twhen(ldoptbuf.io.red \u0026\u0026 ldopt_id \u003d/\u003d Bits(0)){\n\t\t\tldopt_red :\u003d Bool(true)\n\t\t\tprintf(\"!!!!!!!! redundant ld\\n\")\n\t\t}\n\t\tldopt_rst :\u003d Bool(false)\n\t\tldopt_rw :\u003d Bits(0)\n\t\tldopt_id :\u003d Bits(0)\n\t\tldopt_taraddr :\u003d Bits(0)\n\t}\n\t\n\twhen(cmd.fire() \u0026\u0026 info(21,20) \u003d\u003d\u003d UInt(3) \u0026\u0026 info(18) \u003d/\u003d Bits(1)){\n\t\ttotal_cycle :\u003d Bits(0)\n\t}.otherwise{\n\t\ttotal_cycle :\u003d total_cycle + Bits(1)\n\t}\n\t\n\twhen(cmd.fire() \u0026\u0026 info(21,20) \u003d\u003d\u003d UInt(3) \u0026\u0026 info(18) \u003d/\u003d Bits(1)){\n\t\tidle_cycle :\u003d Bits(0)\n\t}.elsewhen(state \u003d\u003d\u003d Bits(IDLE)){\n\t\tidle_cycle :\u003d idle_cycle + Bits(1)\n\t}.otherwise{}\n\t\n\twhen(shdstkaddr\u003eshdstackmax){\n\t\tshdstackmax :\u003d shdstkaddr\n\t}.otherwise{}\n\t\n\t//stop the program\n\twhen(cmd.fire() \u0026\u0026 info(21,20) \u003d\u003d\u003d UInt(3) \u0026\u0026 info(17) \u003d\u003d\u003d UInt(1)){\n\t\tprintf(\"CALL COUNT SIGNAL\\n\")\n\t\twhen(stop_call_count_max \u003e Bits(0)){\n\t\t\tprintf(\"current stop count: %x\\n\",stop_call_count)\n\t\t\tstop_call_count :\u003d stop_call_count + Bits(1)\n\t\t\tstop_call_count_all :\u003d stop_call_count_all + Bits(1)\n\t\t}\n\t}\n\t/*\n\twhen(io.dfi.bits.callvalid \u0026\u0026 (!stop_repcall || stop_brtarget \u003d/\u003d io.dfi.bits.brtarget)){\n\t\tstop_repcall :\u003d Bool(true)\n\t\tstop_brtarget :\u003d io.dfi.bits.brtarget\n\t\twhen(stop_call_count_max \u003e Bits(0)){\n\t\t\tstop_call_count :\u003d stop_call_count + Bits(1)\n\t\t\tstop_call_count_all :\u003d stop_call_count_all + Bits(1)\n\t\t}\n\t}.elsewhen(io.dfi.bits.retvalid \u0026\u0026 (!stop_repcall || stop_brtarget \u003d/\u003d io.dfi.bits.brtarget)){\n\t\tstop_repcall :\u003d Bool(false)\n\t\tstop_brtarget :\u003d io.dfi.bits.brtarget\n\t}.elsewhen(!io.dfi.bits.callvalid \u0026\u0026 !io.dfi.bits.retvalid){\n\t\tstop_repcall :\u003d Bool(true)\n\t}.otherwise{}\n\t*/\n\twhen(stop_call_count_max \u003e Bits(0) \u0026\u0026 stop_call_count \u003e\u003d stop_call_count_max){\n\t\tstop_call_count_max :\u003d Bits(0)\n\t\tstop_call_count :\u003d Bits(0)\n\t\tprintf(\"EXCEPTION!!!\\n\")\n\t\tstop_coreexception :\u003d Bool(true)\n\t}\n\t.elsewhen(stop_coreexception){\n\t\tprintf(\"WAIT FOR NEXT CUSTOM TO STOP\\n\")\n\t\twhen(io.canexception){\n\t\t\tstop_coreexception :\u003d Bool(false)\n\t\t}.otherwise{}\n\t}\n\t/*.elsewhen(stop_coreexception \u0026\u0026 stop_call_count_keep \u003c Bits(5)){\n\t\tstop_call_count_keep :\u003d stop_call_count_keep + Bits(1)\n\t}*/\n\t.otherwise{\n\t\tstop_call_count_keep :\u003d Bits(0)\n\t\tstop_coreexception :\u003d Bool(false)\n\t}\n\t\n\t//++++++++++++++++++++++FSM++++++++++++++++++\n\twhen(state \u003d\u003d\u003d Bits(IDLE)){\n\t\tstallfunc :\u003d Bool(false)\n\t\tmemtag :\u003d Bits(0)\n\t\tmemtype :\u003d Bits(3)\n\t\tcount :\u003d Bits(0)\n\t\tmemvalid :\u003d Bool(false)\n\t\tmemw :\u003d Bool(false)\n\t\tnstate :\u003d Bits(IDLE)\n\t\tpstate :\u003d Bits(IDLE)\n\t\tmatched :\u003d Bool(true)\n\t\twaitresp :\u003d Bool(false)\n\t\twhen(~matched){\n\t\t\tviolations :\u003d violations + Bits(1)\n\t\t\tprintf(\"IDLESTATE: violation\\n\");\n\t\t}.otherwise{}\n\t\twhen(haserror){\n\t\t\terrorcount :\u003d errorcount + Bits(1)\n\t\t\thaserror :\u003d Bool(false)\n\t\t}\n\t\t\n\t\twhen(brneedprocess(0)){//need to process a function call\n\t\t\tbrneedprocess(0) :\u003d Bool(false)\n\t\t\tbrneedprocess(1) :\u003d brneedprocess(0)\n\t\t\t\n\t\t\ttotalcount :\u003d totalcount + Bits(1)\n\t\t\ttotalcallcount :\u003d totalcallcount + Bits(1)\n\t\t\tprintf(\"---------------DFI process begin --------FUNC, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"normal function call/ret? %x, is call? %x, is lib? %x, mode: %x\\n\",brremain(0),funciscall(0),callremain(1),funcmode(1))\n\t\t\tprintf(\"return address pointer: %x arg0: %x, arg1: %x, arg2: %x\\n\",funcretpointer(0),funcarg0(0),funcarg1(0),funcarg2(0))\n\t\t\tprintf(\"custom inst fire? %x\\n\",cmd.fire())\n\t\t\tprintf(\"%x/%x DFI process errors\\n\",errorcount,totalcount)\n\t\t\t\n\t\t\tid(2):\u003did(1)\n\t\t\tfunccount :\u003d totalfunccount(0)\n\t\t\ttotalfunccount(1) :\u003d totalfunccount(0)\n\t\t\tfuncmode(2) :\u003d funcmode(1)\n\t\t\tcallremain(2) :\u003d callremain(1)\n\t\t\tfunciscall(1) :\u003d funciscall(0)\n\t\t\tbrtarget(1) :\u003d brtarget(0)\n\t\t\tfuncarg0(1) :\u003d funcarg0(0)\n\t\t\tfuncarg1(1) :\u003d funcarg1(0)\n\t\t\tfuncarg2(1) :\u003d funcarg2(0)\n\t\t\tfuncretaddr(1) :\u003d funcretaddr(0)\n\t\t\tfuncretpointer(1) :\u003d funcretpointer(0)\n\t\t\tbrremain(1) :\u003d brremain(0)\n\t\t\t\n\t\t\twhen(brremain(0)){\n\t\t\t\twhen(funciscall(0)){\n\t\t\t\t\twhen(funcmode(1) \u003e\u003d Bits(2)){\n\t\t\t\t\t\t//stallfunc :\u003d Bool(true)\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\tshdstkaddr :\u003d shdstkaddr + Bits(1)\n\t\t\t\t\twhen(shdstkcount \u003c shdstacksize){\n\t\t\t\t\t\tshdstkaddr :\u003d shdstkcount\n\t\t\t\t\t\tshdstkcount :\u003d shdstkcount + Bits(1)\n\t\t\t\t\t\tsdhstkdatain :\u003d \n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\n\t\t\t\t\t}*/\n\t\t\t\t\tval rdtentry \u003d (((funcretpointer(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\n\t\t\t\t\tmemaddr :\u003d addrrdt+(((funcretpointer(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\tmemdatain :\u003d Bits(0xffff)\n\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdtentry \u003d (((funcretpointer(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\trdtcprobing :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\tval realaddr \u003d addrrdt+(((funcretpointer(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(READRDT)//skip READRDSMAP because no need\n\t\t\t\t}\n\t\t\t}.otherwise{}\n\t\t}.otherwise{}\n\t\t\n\t\twhen(!brneedprocess(0) \u0026\u0026 slneedprocess \u003d\u003d\u003d Bits(2)){\n\t\t\tprintf(\"---------------DFI process begin, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"info: %x\\n\",infor)\n\t\t\tbrneedprocess(1) :\u003d Bool(false)\n\t\t\ttotalcount :\u003d totalcount + Bits(1)\n\t\t\t/*\n\t\t\tprintf(\"sbuf_p %d +++\\n\", saddrbuf_p(log2Up(bufsize)-1,0))\n\t\t\tfor (i\u003c- 0 to bufsize-1)\n\t\t\tprintf(\"sbuf %d value: %x, cycle %x\\n\", UInt(i), saddrbuf(UInt(i)), scyclebuf(UInt(i)))\n\t\t\t\n\t\t\tprintf(\"lbuf_p %d +++\\n\", laddrbuf_p(log2Up(bufsize)-1,0))\n\t\t\tfor (i\u003c- 0 to bufsize-1)\n\t\t\tprintf(\"lbuf %d value: %x, cycle %x\\n\", UInt(i), laddrbuf(UInt(i)), lcyclebuf(UInt(i)))\n\t\t\t*/\n\t\t\tslneedprocess :\u003d Bits(0)\n\t\t\tcount :\u003d Bits(0)\n\t\t\trw :\u003d infor(16)\n\t\t\tid(2) :\u003d infor(15,0)\n\t\t\tinfo_debug :\u003d infor\n\t\t\twhen(infor(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\twhen(infor(18)){\n\t\t\t\t\tprintf(\"write report ---\\n\")\n\t\t\t\t\tcount :\u003d Bits(0)\n\t\t\t\t\tstate :\u003d Bits(REPORT)\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tprintf(\"reset rdsmap cache ---\\n\")\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t\tstate :\u003d Bits(CACHERESET)\n\t\t\t\t}\n\t\t\t}.elsewhen(infor(19,17) \u003e UInt(0)){\n\t\t\t\t\n\t\t\t}.elsewhen(infor(16) \u003d\u003d\u003d UInt(0)){//store\n\t\t\t\ttotalstcount :\u003d totalstcount + Bits(1)\n\t\t\t\tval rdtentry \u003d (((taraddr(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\n\t\t\t\tmemaddr :\u003d addrrdt+(((taraddr(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\tmemdatain :\u003d infor(15,0)\n\t\t\t\t\n\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\ttaraddr(1) :\u003d taraddr(0)\n\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t}.otherwise{//load\n\t\t\t\ttotalldcount :\u003d totalldcount + Bits(1)\n\t\t\t\twhen((ldopt_red || (ldoptbuf.io.red \u0026\u0026 ldopt_id \u003d/\u003d Bits(0)))){\n\t\t\t\t\ttotalldopt :\u003d totalldopt + Bits(1)\n\t\t\t\t\tprintf(\"LD redundant\\n\")\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t}.otherwise{\n\t\t\t\t\ttotalldnoopt :\u003d totalldnoopt + Bits(1)\n\t\t\t\t\twhen(ldstate \u003d\u003d\u003d Bits(READRDSMAP)){\n\t\t\t\t\t\tval rdsmapentry \u003d infor(15,0)\n\t\t\t\t\t\trdsmapcraddr :\u003d rdsmapentry\u0026rdsmapcacheaddrmask\n\t\t\t\t\t\trdsmapcprobing :\u003d Bool(true)\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrds+(infor(15,0)\u003c\u003c3)\n\t\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t//memvalid :\u003d Bool(true)\n\t\t\t\t\t\t\n\t\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t\t\ttaraddr(1) :\u003d taraddr(0)\n\t\t\t\t\t\tstate :\u003d Bits(READRDSMAP)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t\t\ttaraddr(1) :\u003d taraddr(0)\n\t\t\t\t\t\tstate :\u003d Bits(WRITELDTRACE)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(CACHERESET)){\n\t\twhen(rdsmapcwaddr\u003cBits((1\u003c\u003crdsmapcacheaddrwidth)-1)){\n\t\t\trdsmapcwaddr :\u003d rdsmapcwaddr + Bits(1)\n\t\t\trdsmapcdatain :\u003d Bits(0)\n\t\t}.otherwise{}\n\t\twhen(rdtcwaddr\u003cBits((1\u003c\u003crdtcacheaddrwidth)-1)){\n\t\t\trdtcwaddr :\u003d rdtcwaddr + Bits(1)\n\t\t\trdtcdatain :\u003d Bits(0)\n\t\t}.otherwise{}\n\t\twhen(rdscwaddr\u003cBits((1\u003c\u003crdscacheaddrwidth)-1)){\n\t\t\trdscwaddr :\u003d rdscwaddr + Bits(1)\n\t\t\trdscdatain :\u003d Bits(0)\n\t\t}.otherwise{}\n\t\twhen(rdsmapcwaddr \u003d\u003d\u003d Bits((1\u003c\u003crdsmapcacheaddrwidth)-1) \u0026\u0026 rdtcwaddr \u003d\u003d\u003d Bits((1\u003c\u003crdtcacheaddrwidth)-1) \u0026\u0026 rdscwaddr \u003d\u003d\u003d Bits((1\u003c\u003crdscacheaddrwidth)-1)){\n\t\t\tprintf(\"cache reset done\\n\")\n\t\t\t//state :\u003d Bits(IDLE)\n\t\t\tmemaddr :\u003d addrdebug\n\t\t\tmemw :\u003d Bool(false)\n\t\t\tmemtype :\u003d Bits(3)\n\t\t\tmemtag :\u003d Bits(2)\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\tstate :\u003d Bits(READSTOPCOND)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}.otherwise{}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(READSTOPCOND)){\n\t\twhen(io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)){\n\t\t\tstop_call_count_max :\u003d io.mem.resp.bits.data\n\t\t\tprintf(\"stop condition (call) is: %x\\n\",io.mem.resp.bits.data)\n\t\t\tstate :\u003d Bits(IDLE)\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(WAIT)){\n\t\twhen(io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)){\n\t\t\tstate :\u003d nstate\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(WRITERDT)){\n\t\tuprdt_cycle :\u003d uprdt_cycle + Bits(1)\n\t\twhen(!waitresp){\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\tval cachehit \u003d rdtcdataout \u003d/\u003d Bits(0) \u0026\u0026 (rdtcdataout\u003e\u003e64) \u003d\u003d\u003d ((memaddr-addrrdt)\u003e\u003e3)\u003e\u003erdtcacheaddrwidth\n\t\t\t\twhen(cachehit){\n\t\t\t\t\trdtcwaddr :\u003d rdtcraddr\n\t\t\t\t\trdtcdatain :\u003d (rdtcdataout\u0026(~(Bits(0xffff)\u003c\u003c(memaddr(2,1)\u003c\u003c4))))|((memdatain\u0026Bits(0xffff))\u003c\u003c(memaddr(2,1)\u003c\u003c4))\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twaitresp :\u003d Bool(true)\n\t\t\t\tprintf(\"w addr: %x, data: %x, id: %x, RDT entry: %x\\n\",memaddr,memdatain,id(2),(memaddr-addrrdt)\u003e\u003e1)\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)){\n\t\t\t\topst_count :\u003d opst_count + Bits(1)\n\t\t\t\twaitresp :\u003d Bool(false)\n\t\t\t\twhen(brremain(1) \u0026\u0026 funciscall(1)){\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\twhen(callremain(2)){\n\t\t\t\t\t\twhen(funccount \u003d\u003d\u003d Bits(0) || funccount \u003e\u003d Bits(0xf0000000L)){\n\t\t\t\t\t\t\ttotalcallexceptioncount :\u003d totalcallexceptioncount + Bits(1)\n\t\t\t\t\t\t\tprintf(\"WARNING, lib func length incorrect\\n\")\n\t\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t}.elsewhen(funcmode(2) \u003d\u003d\u003d Bits(2) || funcmode(2) \u003d\u003d\u003d Bits(3)){\n\t\t\t\t\t\t\tval rdsmapentry \u003d id(2)\n\t\t\t\t\t\t\trdsmapcraddr :\u003d rdsmapentry\u0026rdsmapcacheaddrmask\n\t\t\t\t\t\t\trdsmapcprobing :\u003d Bool(true)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmemaddr :\u003d addrrds+(id(2)\u003c\u003c3)\n\t\t\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t\t//memvalid :\u003d Bool(true)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstate :\u003d Bits(READRDSMAP)\n\t\t\t\t\t\t}.elsewhen(funcmode(2) \u003d\u003d\u003d Bits(1)){\n\t\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\t}.otherwise{}\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.elsewhen(!callremain(2)){\n\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t}.elsewhen(callremain(2) \u0026\u0026 funccount \u003c\u003d Bits(1)){\n\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+funccount-Bits(2))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\n\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+funccount-Bits(2))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\tfunccount :\u003d funccount - Bits(1)\n\t\t\t\t}\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(READRDSMAP)){\n\t\trdrdsmap_cycle :\u003d rdrdsmap_cycle + Bits(1)\n\t\trdsid :\u003d Bits(0)\n\t\tmatched :\u003d Bool(false)\n\t\twhen(waitresp || rdsmapcprobing){\n\t\t\tval cachehit \u003d rdsmapcdataout \u003d/\u003d Bits(0) \u0026\u0026 (rdsmapcdataout\u003e\u003e64) \u003d\u003d\u003d ((memaddr-addrrds)\u003e\u003e3)\u003e\u003erdsmapcacheaddrwidth\n\t\t\tval memresp \u003d io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)\n\t\t\twhen(cachehit || memresp){\n\t\t\t\twhen(waitresp){\n\t\t\t\t\tval rdsmapentry \u003d ((memaddr-addrrds)\u003e\u003e3)\n\t\t\t\t\trdsmapcwaddr :\u003d rdsmapentry\u0026rdsmapcacheaddrmask\n\t\t\t\t\trdsmapcdatain :\u003d ((rdsmapentry\u003e\u003erdsmapcacheaddrwidth)\u003c\u003c64)|io.mem.resp.bits.data(63,0)\n\t\t\t\t}.otherwise{}\n\t\t\t\t\n\t\t\t\twaitresp :\u003d Bool(false)\n\t\t\t\trdsmapcprobing :\u003d Bool(false)\n\t\t\t\t\n\t\t\t\twhen(waitresp){\n\t\t\t\t\ttotalrdsmapcachemiss :\u003d totalrdsmapcachemiss + Bits(1)\n\t\t\t\t\tprintf(\"rds range: %x, %x\\n\",io.mem.resp.bits.data(31,0),io.mem.resp.bits.data(63,32))\n\t\t\t\t\trdss :\u003d io.mem.resp.bits.data(31,0)\n\t\t\t\t\trdsp :\u003d io.mem.resp.bits.data(31,0)\n\t\t\t\t\trdse :\u003d io.mem.resp.bits.data(63,32)\n\t\t\t\t}.otherwise{\n\t\t\t\t\ttotalrdsmapcachehit :\u003d totalrdsmapcachehit + Bits(1)\n\t\t\t\t\tprintf(\"RDSMAPCACHEHIT, rdsmapcache data: %x (%x, %x)\\n\",rdsmapcdataout,(rdsmapcdataout\u003e\u003e64),((memaddr-addrrds)\u003e\u003e3)\u003e\u003erdsmapcacheaddrwidth)\n\t\t\t\t\tprintf(\"rds range: %x, %x\\n\",rdsmapcdataout(31,0),rdsmapcdataout(63,32))\n\t\t\t\t\trdss :\u003d rdsmapcdataout(31,0)\n\t\t\t\t\trdsp :\u003d rdsmapcdataout(31,0)\n\t\t\t\t\trdse :\u003d rdsmapcdataout(63,32)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhen(waitresp \u0026\u0026 (io.mem.resp.bits.data(31,0) \u003d\u003d\u003d io.mem.resp.bits.data(63,32)) || rdsmapcprobing \u0026\u0026 (rdsmapcdataout(31,0) \u003d\u003d\u003d rdsmapcdataout(63,32))){//not need to check if rds is empty\n\t\t\t\t\tmatched :\u003d Bool(true)\n\t\t\t\t\twhen(!callremain(2)){\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen(callremain(2) \u0026\u0026 (funcmode(2) \u003d\u003d\u003d Bits(1) || funcmode(2) \u003d\u003d\u003d Bits(3))){\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\tfunccount :\u003d totalfunccount(1)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdtentry0 \u003d (((funcretpointer(1)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\tval rdtentry1 \u003d ((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\tval rdtentry2 \u003d (((taraddr(1)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\n\t\t\t\t\twhen(brremain(1)){\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry0\u0026rdtcacheaddrmask\n\t\t\t\t\t}.elsewhen(callremain(2)){\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry1\u0026rdtcacheaddrmask\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry2\u0026rdtcacheaddrmask\n\t\t\t\t\t}\n\t\t\t\t\trdtcprobing :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\twhen(brremain(1)){\n\t\t\t\t\t\tval realaddr \u003d addrrdt+(((funcretpointer(1)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t}.elsewhen(callremain(2)){\n\t\t\t\t\t\tval realaddr \u003d addrrdt+((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tval realaddr \u003d addrrdt+(((taraddr(1)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t}\n\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(READRDT)\n\t\t\t\t}\n\t\t\t}.elsewhen(rdsmapcprobing \u0026\u0026 !cachehit){\n\t\t\t\tprintf(\"rdsmap not hit, access rdt in memory\\n\")\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\trdsmapcprobing :\u003d Bool(false)\n\t\t\t}\n\t\t\t.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\twaitresp :\u003d Bool(true)\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(READRDT)){\n\t\trdsp :\u003d rdss\n\t\trdrdt_cycle :\u003d rdrdt_cycle + Bits(1)\n\t\twhen(waitresp || rdtcprobing){\n\t\t\tval cachehit \u003d rdtcdataout \u003d/\u003d Bits(0) \u0026\u0026 (rdtcdataout\u003e\u003e64) \u003d\u003d\u003d ((memaddr-addrrdt)\u003e\u003e3)\u003e\u003erdtcacheaddrwidth\n\t\t\tval memresp \u003d io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)\n\t\t\twhen(cachehit || memresp){\n\t\t\t\topld_count :\u003d opld_count + Bits(1)\n\t\t\t\twhen(memresp){\n\t\t\t\t\tval rdtentry \u003d ((memaddr-addrrdt)\u003e\u003e3)\n\t\t\t\t\trdtcwaddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\trdtcdatain :\u003d ((rdtentry\u003e\u003erdtcacheaddrwidth)\u003c\u003c64)|io.mem.resp.bits.data\n\t\t\t\t}.otherwise{}\n\t\t\t\t\n\t\t\t\twaitresp :\u003d Bool(false)\n\t\t\t\trdtcprobing :\u003d Bool(false)\n\t\t\t\t\n\t\t\t\tval previdfmem \u003d (io.mem.resp.bits.data\u003e\u003e(memaddrmod(2,1)\u003c\u003c4))\u0026Bits(0xffff)\n\t\t\t\tval previdfcache \u003d (rdtcdataout\u003e\u003e(memaddrmod(2,1)\u003c\u003c4))\u0026Bits(0xffff)\n\t\t\t\t\n\t\t\t\twhen(waitresp){\n\t\t\t\t\ttotalrdtcachemiss :\u003d totalrdtcachemiss + Bits(1)\n\t\t\t\t\tprintf(\"latest write id: %d\\n\",previdfmem(15,0))\n\t\t\t\t\tprevwid :\u003d previdfmem(15,0)\n\t\t\t\t}.otherwise{\n\t\t\t\t\ttotalrdtcachehit :\u003d totalrdtcachehit + Bits(1)\n\t\t\t\t\tprintf(\"RDTCACHEHIT, rdtcache data: %x, tag: %x, latest write id: %d\\n\",rdtcdataout(63,0),(rdtcdataout\u003e\u003e64),previdfcache(15,0))\n\t\t\t\t\tprevwid :\u003d previdfcache\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhen(memresp \u0026\u0026 previdfmem \u003d\u003d\u003d Bits(0) || cachehit \u0026\u0026 previdfcache \u003d\u003d\u003d Bits(0)){//not need to check if rdt\u003d0\n\t\t\t\t\tmatched :\u003d Bool(true)\n\t\t\t\t\twhen(!callremain(2)){//no other check\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen((callremain(2) \u0026\u0026 funccount \u003c\u003d Bits(1) \u0026\u0026 (funcmode(2) \u003d\u003d\u003d Bits(1) || funcmode(2) \u003d\u003d\u003d Bits(3)) )){//lib read finished, go to lib write\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\tfunccount :\u003d totalfunccount(1)\n\t\t\t\t\t}.elsewhen(callremain(2)){//lib read unfinished, continue\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\trdtcprobing :\u003d Bool(true)\n\t\t\t\t\t\t\n\t\t\t\t\t\tval realaddr \u003d addrrdt+((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(READRDT)\n\t\t\t\t\t\tfunccount :\u003d funccount - Bits(1)\n\t\t\t\t\t}.otherwise{//OTW, finish DFI process\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.elsewhen(brremain(1)){//if stack pointer needs to be check\n\t\t\t\t\tmatched :\u003d (memresp \u0026\u0026 previdfmem \u003d\u003d\u003d Bits(0xffff)) || (cachehit \u0026\u0026 previdfcache \u003d\u003d\u003d Bits(0xffff))\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\tstate :\u003d Bits(IDLE)//this is a function return, callremain must \u003d 0\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdsentry \u003d (rdss\u003c\u003c1)(61,3)\n\t\t\t\t\trdscraddr :\u003d rdsentry\u0026rdscacheaddrmask\n\t\t\t\t\trdscprobing :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\tmemaddr :\u003d ((addrrds+(rdss\u003c\u003c1))(61,3))\u003c\u003c3\n\t\t\t\t\tmemaddrmod :\u003d (addrrds+(rdss\u003c\u003c1))(2,0)\n\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(READRDS)\n\t\t\t\t}\n\t\t\t}.elsewhen(rdtcprobing \u0026\u0026 !cachehit){\n\t\t\t\tprintf(\"not hit, access rdt in memory\\n\")\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\trdtcprobing :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\twaitresp :\u003d Bool(true)\n\t\t\t\tprintf(\"r addr: %x, id: %x, RDT entry: %x\\n\",memaddr,id(2),(memaddr-addrrdt)\u003e\u003e1)\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(READRDS)){\n\t\trdrds_cycle :\u003d rdrds_cycle + Bits(1)\n\t\twhen(waitresp || rdscprobing){\n\t\t\tval cachehit \u003d rdscdataout \u003d/\u003d Bits(0) \u0026\u0026 (rdscdataout\u003e\u003e64) \u003d\u003d\u003d ((memaddr-addrrds)\u003e\u003e3)\u003e\u003erdscacheaddrwidth\n\t\t\tval memresp \u003d io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)\n\t\t\twhen(cachehit || memresp){\n\t\t\t\twhen(memresp){\n\t\t\t\t\tval rdsentry \u003d ((memaddr-addrrds)\u003e\u003e3)\n\t\t\t\t\trdscwaddr :\u003d rdsentry\u0026rdscacheaddrmask\n\t\t\t\t\trdscdatain :\u003d ((rdsentry\u003e\u003erdscacheaddrwidth)\u003c\u003c64)|io.mem.resp.bits.data\n\t\t\t\t}.otherwise{}\n\t\t\t\t\n\t\t\t\twaitresp :\u003d Bool(false)\n\t\t\t\trdscprobing :\u003d Bool(false)\n\t\t\t\t\n\t\t\t\twhen(waitresp){\n\t\t\t\t\tprintf(\"rds id: %d, %d, %d, %d\\n\",io.mem.resp.bits.data(15,0),io.mem.resp.bits.data(31,16),io.mem.resp.bits.data(47,32),io.mem.resp.bits.data(63,48))\n\t\t\t\t\ttotalrdscachemiss :\u003d totalrdscachemiss + Bits(1)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tprintf(\"RDSCACHEHIT, rds id: %d, %d, %d, %d\\n\",rdscdataout(15,0),rdscdataout(31,16),rdscdataout(47,32),rdscdataout(63,48))\n\t\t\t\t\ttotalrdscachehit :\u003d totalrdscachehit + Bits(1)\n\t\t\t\t}\n\t\t\t\tprintf(\"mem side pass? %x, cache side pass? %x\\n\",onematched,conematched)\n\t\t\t\trdsp:\u003drdsp+Bits(4)\n\t\t\t\twhen((onematched \u0026\u0026 memresp) || (conematched \u0026\u0026 cachehit)){//check pass\n\t\t\t\t\tmatched :\u003d Bool(true)\n\t\t\t\t\twhen(!callremain(2)){//this is not a lib call check, then finish DFI\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen((callremain(2) \u0026\u0026 funccount \u003c\u003d Bits(1) \u0026\u0026 (funcmode(2) \u003d\u003d\u003d Bits(1) || funcmode(2) \u003d\u003d\u003d Bits(3)) )){//this is a call, finished, check if needs write\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\tfunccount :\u003d totalfunccount(1)\n\t\t\t\t\t}.elsewhen(callremain(2) \u0026\u0026 funccount \u003c\u003d Bits(1) \u0026\u0026 funcmode(2) \u003d\u003d\u003d Bits(2)){\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen(callremain(2)){\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\trdtcprobing :\u003d Bool(true)\n\t\t\t\t\t\t\n\t\t\t\t\t\tval realaddr \u003d addrrdt+((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(READRDT)\n\t\t\t\t\t\tfunccount :\u003d funccount - Bits(1)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.elsewhen(rdsp+Bits(4)\u003e\u003drdse){//check not pass\n\t\t\t\t\tmatched :\u003d Bool(false)\n\t\t\t\t\twhen(!callremain(2)){\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen(callremain(2) \u0026\u0026 (funcmode(2) \u003d\u003d\u003d Bits(1) || funcmode(2) \u003d\u003d\u003d Bits(3))){//one of the data readed by lib is violated, no need to check the following data\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\tfunccount :\u003d totalfunccount(1)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdsentry \u003d (rdsp+Bits(4)\u003c\u003c1)(61,3)\n\t\t\t\t\trdscraddr :\u003d rdsentry\u0026rdscacheaddrmask\n\t\t\t\t\trdscprobing :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\tmemaddr :\u003d ((addrrds+(rdsp+Bits(4)\u003c\u003c1))(61,3))\u003c\u003c3\n\t\t\t\t\tmemaddrmod :\u003d (addrrds+(rdsp+Bits(4)\u003c\u003c1))(2,0)\n\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(READRDS)\n\t\t\t\t}\n\t\t\t}.elsewhen(rdscprobing \u0026\u0026 !cachehit){\n\t\t\t\tprintf(\"not hit, access rds in memory\\n\")\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\trdscprobing :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\tprintf(\"r rds: %x\\n\",((addrrds+(rdsp\u003c\u003c1))(61,3))\u003c\u003c3);\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\twaitresp :\u003d Bool(true)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(WRITELDTRACE)){\n\t\tmemtag :\u003d Bits(2)\n\t\tmemaddr :\u003d addrdebug+Bits(800)+(rdtreaddebug_p\u003c\u003c3)\n\t\tmemw :\u003d Bool(true)\n\t\tmemdatain :\u003d taraddr(1)\n\t\tmemtype :\u003d Bits(3)\n\t\t\n\t\twhen(io.mem.req.fire()){\n\t\t\tprintf(\"rdttrace write to addr: %x, trace %x\\n\",addrdebug+Bits(800)+(rdtreaddebug_p\u003c\u003c3),taraddr(1));\n\t\t\twhen(rdtreaddebug_p\u003e\u003dBits(0x7ff00)){\n\t\t\t\trdtreaddebug_p :\u003d Bits(0)\n\t\t\t}.otherwise{\n\t\t\t\trdtreaddebug_p :\u003d rdtreaddebug_p + Bits(1)\n\t\t\t}\n\n\t\t\tstate :\u003d Bits(WAIT)\n\t\t\t\n\t\t\tval rdsmapentry \u003d id(2)\n\t\t\trdsmapcraddr :\u003d rdsmapentry\u0026rdsmapcacheaddrmask\n\t\t\trdsmapcprobing :\u003d Bool(true)\n\t\t\t\n\t\t\tmemaddr :\u003d addrrds+(id(2)\u003c\u003c3)\n\t\t\tmemw :\u003d Bool(false)\n\t\t\tmemtype :\u003d Bits(3)\n\t\t\tmemtag :\u003d Bits(2)\n\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\n\t\t\tnstate :\u003d Bits(READRDSMAP)\n\t\t\tpstate :\u003d Bits(WRITELDTRACE)\n\t\t}.otherwise{\n\t\t\tmemvalid :\u003d Bool(true)\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(REPORT)){\n\t\tmemtag :\u003d Bits(2)\n\t\tmemaddr :\u003d addrdebug+(count\u003c\u003c3)\n\t\tmemw :\u003d Bool(true)\n\t\twhen(count \u003d\u003d\u003d Bits(0)){\n\t\t\tmemdatain :\u003d violations\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(1)){\n\t\t\tmemdatain :\u003d errorcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(2)){\n\t\t\tmemdatain :\u003d totalcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(3)){\n\t\t\tmemdatain :\u003d funcarg0(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(4)){\n\t\t\tmemdatain :\u003d funcarg1(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(5)){\n\t\t\tmemdatain :\u003d funcarg2(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(6)){\n\t\t\tmemdatain :\u003d funcretpointer(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(7)){\n\t\t\tmemdatain :\u003d totalfunccount(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(8)){\n\t\t\tmemdatain :\u003d opst_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(9)){\n\t\t\tmemdatain :\u003d opld_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(10)){\n\t\t\tmemdatain :\u003d uprdt_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(11)){\n\t\t\tmemdatain :\u003d rdrdt_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(12)){\n\t\t\tmemdatain :\u003d rdrdsmap_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(13)){\n\t\t\tmemdatain :\u003d rdrds_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(14)){\n\t\t\tmemdatain :\u003d chk_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(15)){\n\t\t\tmemdatain :\u003d maxlibarg0\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(16)){\n\t\t\tmemdatain :\u003d maxlibarg1\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(17)){\n\t\t\tmemdatain :\u003d maxlibarg2\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(18)){\n\t\t\tmemdatain :\u003d maxlibarg3\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(19)){\n\t\t\tmemdatain :\u003d maxlibretaddr\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(20)){\n\t\t\tmemdatain :\u003d maxlibretptr\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(21)){\n\t\t\tmemdatain :\u003d maxliblen\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(22)){\n\t\t\tmemdatain :\u003d totalldopt\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(23)){\n\t\t\tmemdatain :\u003d totalldnoopt\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(24)){\n\t\t\tmemdatain :\u003d totalrdtcachehit\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(25)){\n\t\t\tmemdatain :\u003d totalrdsmapcachehit\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(26)){\n\t\t\tmemdatain :\u003d rdtcdataout\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(27)){\n\t\t\tmemdatain :\u003d rdsmapcdataout\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(28)){\n\t\t\tmemdatain :\u003d totalrdscachehit\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(29)){\n\t\t\tmemdatain :\u003d totalrdtcachemiss\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(30)){\n\t\t\tmemdatain :\u003d totalrdsmapcachemiss\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(31)){\n\t\t\tmemdatain :\u003d totalrdscachemiss\n\t\t/*\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(32)){\n\t\t\tmemdatain :\u003d lat_call_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(33)){\n\t\t\tmemdatain :\u003d lat_call_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(34)){\n\t\t\tmemdatain :\u003d lat_libst_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(35)){\n\t\t\tmemdatain :\u003d lat_libst_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(36)){\n\t\t\tmemdatain :\u003d lat_libld_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(37)){\n\t\t\tmemdatain :\u003d lat_libld_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(38)){\n\t\t\tmemdatain :\u003d lat_libstld_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(39)){\n\t\t\tmemdatain :\u003d lat_libstld_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(40)){\n\t\t\tmemdatain :\u003d lat_ret_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(41)){\n\t\t\tmemdatain :\u003d lat_ret_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(42)){\n\t\t\tmemdatain :\u003d lat_st_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(43)){\n\t\t\tmemdatain :\u003d lat_st_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(44)){\n\t\t\tmemdatain :\u003d lat_ld_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(45)){\n\t\t\tmemdatain :\u003d lat_ld_cycles\n\t\t*/\n\t\t\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(32)){\n\t\t\tmemdatain :\u003d idle_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(33)){\n\t\t\tmemdatain :\u003d total_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(34)){\n\t\t\tmemdatain :\u003d fifocuspush_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(35)){\n\t\t\tmemdatain :\u003d fifofuncpush_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(36)){\n\t\t\tmemdatain :\u003d fifocusbranchpush\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(37)){\n\t\t\tmemdatain :\u003d fifocusbranchpop\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(38)){\n\t\t\tmemdatain :\u003d fifofuncbranchpush\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(39)){\n\t\t\tmemdatain :\u003d fifofuncbranchpop\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(40)){\n\t\t\tmemdatain :\u003d fifofuncloss\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(41)){\n\t\t\tmemdatain :\u003d fifofunclatestlossinfo\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(42)){\n\t\t\tmemdatain :\u003d fifofunclatestlosscuscount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(43)){\n\t\t\tmemdatain :\u003d fifofunclatestlossfunccount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(44)){\n\t\t\tmemdatain :\u003d fifofunclatestlossrecord\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(45)){\n\t\t\tmemdatain :\u003d fifofunclatestlosstaraddr\n\t\t\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(46)){\n\t\t\tmemdatain :\u003d fifocusmax\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(47)){\n\t\t\tmemdatain :\u003d fifofuncmax\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(48)){\n\t\t\tmemdatain :\u003d shdstackmax\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(49)){\n\t\t\tmemdatain :\u003d stop_call_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(50)){\n\t\t\tmemdatain :\u003d stop_call_count_all\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(51)){\n\t\t\tmemdatain :\u003d stop_call_count_max\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(52)){\n\t\t\tmemdatain :\u003d stop_coreexception\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(53)){\n\t\t\tmemdatain :\u003d totalstcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(54)){\n\t\t\tmemdatain :\u003d totalldcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(55)){\n\t\t\tmemdatain :\u003d totalcallcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(56)){\n\t\t\tmemdatain :\u003d totalcallexceptioncount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(57)){\n\t\t\tmemdatain :\u003d Bits(0)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(58)){\n\t\t\tmemdatain :\u003d Bits(0)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(59)){\n\t\t\tmemdatain :\u003d Bits(0x11122233)\n\t\t}\n\t\t.otherwise{}\n\t\t\n\t\tmemtype :\u003d Bits(3)\n\t\twhen(io.mem.req.fire()){\n\t\t\t//printf(\"report write to addr: %x\\n\",addrdebug+((count+Bits(6))\u003c\u003c2));\n\t\t\tmemvalid :\u003d Bool(false)\n\t\t\tstate :\u003d Bits(WAIT)\n\t\t\twhen(count \u003c Bits(59)){\n\t\t\t\tnstate :\u003d Bits(REPORT)\n\t\t\t}.otherwise{\n\t\t\t\tnstate :\u003d Bits(IDLE)\n\t\t\t}\n\t\t\tpstate :\u003d Bits(REPORT)\n\t\t\tcount :\u003d count + Bits(1)\n\t\t}.otherwise{\n\t\t\tmemvalid :\u003d Bool(true)\n\t\t}\n\t}\n\t.otherwise{}\n\t\n}\n//flang----------------\n\n\n//wxr++++++++++++\n\n\n\n/*\nHere are some reasons:\n\t1.Locality 2.History\n\tWe use the shiftreg to hold the history message\n*/\nclass Redundant_Buffer(Depth:Int)(implicit p: Parameters) extends Module {\n\tval io \u003d IO(new Bundle{\n\t\t//fifo signals\n\t\tval fifo_read \u003d Bool(OUTPUT)\n\t\tval fifo_empty \u003d Bool(INPUT)\n\t\tval fifo_data \u003d Input(UInt(64.W))\n\t\t//redundant signals out\n\t\tval info_req \u003d Bool(INPUT)\n\t\tval info_resp \u003d Bool(OUTPUT)\n\t\tval info_data \u003d Output(UInt(64.W))\n\t\t//configure siganls\n\t\tval conf_valid \u003d Bool(INPUT)\n\t\tval group_num \u003d Input(UInt(3.W)) //how many 64, load from the fifo\n\t\tval group_realtion \u003d Input(UInt(1.W)) // 0 || ; 1 \u0026\u0026\n\t\tval conditions \u003d Input(UInt(2.W)) //8 shiftregs, need 2 conditions bit \u003c \u003e \u003d\n\t})\n\n\n}\n\n\n//This module is memory in the micro-core\n\n\nclass mem_rw(implicit p:Parameters) extends CoreBundle{\n\tval addr \u003d Input(UInt(width  \u003d 32))\n\tval write \u003d Bool(INPUT)\n\tval data_w \u003d Input(UInt(64.W))\n\tval busy \u003d Bool(OUTPUT)\n\tval burst \u003d Input(UInt(4.W)) //0000:no burst\n\tval out \u003d Output(UInt(64.W))\n}\n\n/*\nclass micro_core_mem(Depth:Int)(implicit p: Parameters) extends Module {\n\tval io \u003d IO(new Bundle {\n\t\tval initial \u003d new HellaCacheIO \n\t\tval initial_done \u003d Bool(OUTPUT)\n\t\tval initial_valid \u003d Bool(INPUT)\n\t\tval initial_addr \u003d Input(UInt(64.W))\n\t\tval initial_len \u003d Input(UInt(16.W))\n\n\t\tval rw \u003d new mem_rw\n\t})\n\n\tval mem \u003d Mem(64, Bits(width \u003d 1\u003c\u003cDepth)) \n\tval initial_done \u003d Reg(Bool(false))\n\tio.initial_done :\u003d initial_done \n\n\t//rw signal\n\tval out_r \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval busy_r \u003d Reg(Bool(false))\n\tio.rw.out :\u003d out_r\n\tio.rw.busy :\u003d busy_r\n\t\n\t//cache io\n\tval mem_state \u003d Reg(init \u003d Bits(0,width \u003d 4))\n\tval req_valid \u003d Reg(Bool(false))\n\tval initial_done_r \u003d Reg(Bool(false))\n\tio.initial.req.valid :\u003d req_valid\n\tio.initial.req.addr :\u003d dma_addr + dma_cnt * 8.U\n\tio.initial_done :\u003d initial_done_r\n\t\n\n\tswitch(mem_state){\n\t\tis(UInt(0)){\n\t\t\twhen(io.initial_valid \u0026\u0026 !initial_done){\n\t\t\t\tdma_len  :\u003d io.initial_len\n\t\t\t\tdma_addr :\u003d io.initial_addr\n\t\t\t\tmem_state :\u003d 1.U\n\t\t\t}\n\t\t}\n\t\tis(UInt(1)){\n\t\t\treq_valid :\u003d Bool(true)\n\t\t\twhen(io.initial.req.fire()){\n\t\t\t\tmem_state :\u003d 2.U\n\t\t\t\treq_valid :\u003d Bool(false)\n\t\t\t}\n\t\t}\n\t\tis(UInt(2)){\n\t\t\twhen(io.initial.resp.valid){\n\t\t\t\tdma_cnt :\u003d Mux(dma_cnt \u003d\u003d dma_len-1.U ,0.U ,dma_cnt+1.U )\n\t\t\t\tmem_state :\u003d Mux(dma_cnt \u003d\u003d dma_len -1.U,3.U ,1.U)\n\t\t\t\tmem(dma_cnt) :\u003d io.initial.resp.bits.data\n\t\t\t}\n\t\t}\n\t\tis(UInt(3)){\n\t\t\tinitial_done_r :\u003d Bool(true)\n\t\t\twhen(io.rw.write){\n\t\t\t\t\t\tmem(io.rw.addr) :\u003d io.rw.data_w\n\t\t\t\t}\n\n\t\t\t}.otherwise{\n\t\t\t\t\t\tout_r :\u003d mem(io.rw.addr)\n\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n*/\n\nclass mem_initial(implicit p:Parameters) extends CoreBundle{\n\tval valid \u003d Input(Bool())\n\tval addr \u003d Input(UInt(width  \u003d 32))\n\tval len \u003d Input(UInt(64.W))\n\tval load_done \u003d Output(Bool())\n}\n\n\n\n//This class bundle the message come from hardware\nclass info(implicit p:Parameters) extends CoreBundle{\n\tval cfi \u003d Decoupled(new CFIPort).flip\n}\n\n\n\n//shadow stack\n/*\nThis stack has 16 entries, each entry has 64bits. At the same time\n, when the stack is full, the lastest push entry will be replaced \nby the newest entry\n*/\nclass stack(implicit p: Parameters) extends Module {\n\tval io \u003d IO(new Bundle{\n\t\tval push \u003d Bool(INPUT)\n\t\tval pop \u003d Bool(INPUT)\n\t\tval data_in \u003d Input(UInt(64.W))\n\t\tval data_out \u003d Output(UInt(64.W))\n\t\tval empty \u003d Bool(OUTPUT)\n\t})\n\n\tval mem \u003d Mem(16,Bits(width\u003d64))\n\tval top \u003d Reg(init \u003d Bits(0,width\u003d5))\n\tval bottom \u003d Reg(init \u003d Bits(0,width\u003d5))\n\tio.empty :\u003d top \u003d\u003d\u003d bottom\n\tval full \u003d ( Mux(top\u003ebottom,top-bottom,bottom-top )\u003d\u003d\u003d 15.U )\n\tval data_out_reg \u003d Reg(init \u003d Bits(0,width\u003d64))\n\tio.data_out :\u003d data_out_reg\n\twhen(io.push \u0026\u0026 io.pop){\n\t\tdata_out_reg :\u003d mem(top)\n\t\tmem(top) :\u003d io.data_in\n\t}.elsewhen(io.push){\n\t\ttop :\u003d top+1.U\n\t\tbottom :\u003d Mux(full,bottom + 1.U,bottom)\n\t\tmem(top+1.U) :\u003d io.data_in\n\t}.elsewhen(io.pop){\n\t\ttop :\u003d Mux(io.empty,top,top-1.U) //maybe there is bug\n\t\tdata_out_reg :\u003d mem(top)\n\t}\n\n}\n\n\n//This trait describe some const\ntrait co_core_const{\n\tdef CO_JUMP       \u003d UInt(\"b000001\")\n\tdef CO_FIFO_INPUT \u003d UInt(\"b000010\")\n\tdef CO_LOAD       \u003d UInt(\"b000011\")\n\tdef CO_STORE      \u003d UInt(\"b000100\")\n\tdef CO_CMP        \u003d UInt(\"b000101\")\n\tdef CO_ADD        \u003d UInt(\"b000110\")\n\tdef CO_MUL        \u003d UInt(\"b000111\")\n\tdef CO_MINUS      \u003d UInt(\"b001000\")\n\tdef CO_WReg       \u003d UInt(\"b001001\")\n\tdef CO_DO_UNTIL   \u003d UInt(\"b001010\")\n\tdef CO_R_BUF      \u003d UInt(\"b001011\")  //read the message from buffer\n\tdef CO_R_FIFO     \u003d UInt(\"b001100\")\n\tdef CO_SL         \u003d UInt(\"b001101\")\n\tdef CO_RL         \u003d UInt(\"b001110\")\n\tdef CO_BIT_AND    \u003d UInt(\"b001111\")\n\tdef CO_IF         \u003d UInt(\"b010000\")\n\tdef CO_POP        \u003d UInt(\"b010001\")\n\tdef CO_PUSH       \u003d UInt(\"b010010\")\n\tdef CO_S_LOAD     \u003d UInt(\"b010011\")\n\n}\n\n\n\n//This module describe the pipeline of the micro-core\n/*\n@first stage : fetch the inst from IMem, IMem is limited in 50 instructions(6 bits address)\n@second stage: decode and if needed fetch the memeroy data to normal-reg and do some computation\n*/\nclass micro_core(mem_Depth:Int)(implicit p: Parameters) extends Module with co_core_const {\n\tval io \u003d IO(new Bundle{\n\t\tval stall \u003d Bool(INPUT)\n\t\tval stalled \u003d Bool(OUTPUT)\n\t\tval main_core_stall \u003d Bool(OUTPUT)\n\t\tval mem_initial \u003d new mem_initial\n\t\tval mem_p \u003d new HellaCacheIO\n\t\tval info \u003d new info\n\t})\n\n\t//input and output\n\tval fifo_r \u003d Reg(init \u003d Bool(false)) \n\tval stalled_vec \u003d Reg(init \u003d Vec.fill(2){Bool(false)}) \n\tval stalled_fifo_empty \u003d Reg(init \u003d Bool(false))\n\tval stalled_s_pop \u003d Reg(init \u003d Bool(false))\n\tval stalled_r \u003d stalled_vec(0) || stalled_vec(1) || stalled_fifo_empty || fifo_r || stalled_s_pop\n\t//some situation, we need to stall the fifo\n\tio.stalled :\u003d stalled_r\n\t\n\n\t//some utils like reg, CSRs and fifo\n\t//the 16-31 is the CSR register\n\tval reg \u003d Reg(init \u003d Vec.fill(32){Bits(0,width \u003d 64)})\n\n\tval fifo \u003dModule(new DFIFIFO(1024,64))\n\tfifo.io.read :\u003d fifo_r\n\n\n\n\tval initial_done_w \u003d Wire(Bool())\n\tval cfi_en_w \u003d Wire(Bool())\n\tval mem_state_w \u003d Wire(UInt(4.W))\n\t//stall the main core with some situation\n\tio.main_core_stall :\u003d fifo.io.full || (io.mem_initial.valid || mem_state_w \u003d/\u003d 0.U) || (initial_done_w \u0026\u0026 !cfi_en_w  )\n\n\t//shadow stack\n\tval stack \u003d Module(new stack)\n\n/****************\n * initial instruction memory\n****************/\n\tval i_mem \u003d Mem(64, Bits(width \u003d 64)) \n\tval mem_state \u003d Reg(init \u003d Bits(0,width \u003d 4))\n\tmem_state_w :\u003d mem_state\n\tval dma_len \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval dma_addr \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval dma_cnt \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval req_valid_init \u003d Reg(init \u003d Bool(false))\n\tval initial_done_r \u003d Reg(init \u003d Bool(false))\n\tio.mem_initial.load_done :\u003d initial_done_r\n\tinitial_done_w :\u003d initial_done_r\n\n\tswitch(mem_state){\n\t\tis(UInt(0)){\n\t\t\twhen(io.mem_initial.valid \u0026\u0026 !initial_done_r){\n\t\t\t\tdma_len  :\u003d io.mem_initial.len\n\t\t\t\tdma_addr :\u003d io.mem_initial.addr\n\t\t\t\tmem_state :\u003d 1.U\n\t\t\t}\n\t\t}\n\t\tis(UInt(1)){\n\t\t\treq_valid_init :\u003d Bool(true)\n\t\t\twhen(io.mem_p.req.fire()){\n\t\t\t\tmem_state :\u003d 2.U\n\t\t\t\treq_valid_init :\u003d Bool(false)\n\t\t\t}\n\t\t}\n\t\tis(UInt(2)){\n\t\t\twhen(io.mem_p.resp.valid){\n\t\t\t\tdma_cnt :\u003d Mux(dma_cnt \u003d\u003d\u003d dma_len-1.U ,0.U ,dma_cnt+1.U )\n\t\t\t\tmem_state :\u003d Mux(dma_cnt \u003d\u003d\u003d dma_len -1.U,0.U ,1.U)\n\t\t\t\tinitial_done_r :\u003d Mux(dma_cnt \u003d\u003d\u003d dma_len -1.U,Bool(true) ,Bool(false))\n\t\t\t\ti_mem(dma_cnt) :\u003d io.mem_p.resp.bits.data\n\t\t\t}\n\t\t}\n\t}\n\n\n\n/***********\n * stage 1\n***********/\n\t//@fetch stage: fetch the inst from the Mem the begin address is 0x0\n\tval inst \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval pc \u003d Reg(init \u003d Bits(0,width \u003d 8))\n\t//Do util signal\n\tval do_util \u003d Reg(init \u003d Bool(false))\n\tval do_util_invalid \u003d Reg(init \u003d Bool(false))\n\tval co_pc1 \u003d Reg(init \u003d Bits(0,width\u003d6))\n\tval co_pc2 \u003d Reg(init \u003d Bits(0,width\u003d6))\n\tval co_new_pc \u003d Reg(init \u003d Bits(0,width\u003d6))\n\tval co_do_util_happen \u003d Reg(init \u003d Bool(false))\n\t//if decode_invald signal\n\tval if_en_w \u003d Wire(Bool())\n\tval if_new_pc_w \u003d Wire(UInt(6.W))\n\t\n\tval pc_flush \u003d Reg(init \u003d Bool(false))\n\tval co_event_happen_w \u003d Wire(Bool())\n\tval decode_invalid \u003d  pc_flush || RegNext(pc_flush) || do_util_invalid || RegNext(do_util_invalid) || co_do_util_happen || co_event_happen_w || RegNext(if_en_w)\n\t\n\tval new_pc \u003d Reg(UInt(40.W))\n\t//PC GEN, generate the pc\n    val pc_en \u003d !io.stall \u0026\u0026 !stalled_r \u0026\u0026 initial_done_r \n\twhen(pc_en){\n\t\twhen(if_en_w){\n\t\t\tpc :\u003d if_new_pc_w\n\t\t}\n\t\t.elsewhen(!do_util){\n\t\t\tpc :\u003d Mux(pc_flush,new_pc, Mux (co_do_util_happen,co_new_pc ,pc+1.U))\n\t\t}.otherwise{\n\t\t\twhen(do_util_invalid){\n\t\t\t\tpc :\u003d co_pc1\n\t\t\t}.otherwise{\n\t\t\t\tpc :\u003d Mux(pc_flush , new_pc,Mux(pc \u003d\u003d\u003d co_pc2,co_pc1,pc+1.U ))\n\t\t\t}\n\n\t\t}\n\t\tinst :\u003d i_mem(pc)\n\t}\n\n/*********\n * stage 2\n@Decode and exe stage\n*********/\n\t////////////////////////////////////////////////////////////////////co-jump\n\tpc_flush :\u003d (inst(5,0) \u003d\u003d\u003d CO_JUMP) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tnew_pc :\u003d inst(11,6)\n\n\t////////////////////////////////////////////////////////////////////co-if\n\tval co_if \u003d (inst(5,0) \u003d\u003d\u003d CO_IF) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tval if_en \u003d reg(inst(11,6)) \u003d\u003d\u003d inst(17,12) \u0026\u0026 co_if\n\tval if_new_pc \u003d inst(23,18)\n\tif_en_w :\u003d if_en\n\tif_new_pc_w :\u003d if_new_pc\n\n\t////////////////////////////////////////////////////////////////////shadow pop/push/load\n\tval s_pop \u003d (inst(5,0) \u003d\u003d\u003d CO_POP) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tval s_push \u003d (inst(5,0) \u003d\u003d\u003d CO_PUSH) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tval s_load \u003d (inst(5,0) \u003d\u003d\u003d CO_S_LOAD) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tval s_pop_id \u003d Reg(init \u003d Bits(0,width\u003d6))\n\tval stack_status \u003d Mux(stack.io.empty,1.U,0.U) \n\ts_pop_id :\u003d Mux(s_pop,inst(11,6),s_pop_id)\n\tstalled_s_pop :\u003d s_pop\n\tstack.io.push :\u003d s_push\n\tstack.io.pop :\u003d s_pop\n\tstack.io.data_in :\u003d reg(inst(11,6))\n\t\n\n\n\t////////////////////////////////////////////////////////////////////co-fifo\n\t/*\n\tval io \u003d new Bundle{\n\t\tval rst \u003d Bool(INPUT)\n\t\tval write \u003d Bool(INPUT)\n\t\tval datain \u003d Bits(width \u003d datawidth).flip\n\t\tval read \u003d Bool(INPUT)\n\t\tval dataout \u003d Bits(width \u003d datawidth)\n\t\tval full \u003d Bool(OUTPUT)\n\t\tval empty \u003d Bool(OUTPUT)\n\t}\n\tinst(11,6) -\u003e the info, 000000-\u003ecfi, 0000001-\u003edfi\n\t*/\n\t/*\n\t1.CFI situation\n\t\tThe isCFI \u0026\u0026 valid is the branch or other jump instruction\n\t\tand we need to hold the next correct instrution then\n\t\n\t*/\n\tval cfi_pc_r_1 \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval cfi_pc_r_2 \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\twhen(io.info.cfi.bits.valid){\n\t\tcfi_pc_r_2 :\u003d cfi_pc_r_1\n\t\tcfi_pc_r_1 :\u003d io.info.cfi.bits.pc\n\t}\n\tval pc_NoChange \u003d cfi_pc_r_1 \u003d\u003d\u003d cfi_pc_r_2\n\n\tval cfi_en \u003d Reg(init \u003d Bool(false))\n\tcfi_en_w :\u003d cfi_en\n\tval cfi_target_valid \u003d io.info.cfi.bits.valid \u0026\u0026 !io.info.cfi.bits.mispredict\n\tval cfi_wait_target \u003d Reg(init \u003d Bool(false))\n\tval isCFI_valid \u003d (io.info.cfi.bits.valid \u0026\u0026 io.info.cfi\n\twhen(isCFI_valid){\n\t\tcfi_wait_target :\u003d Bool(true)\n\t}.elsewhen(cfi_wait_target){\n\t\twhen(io.info.cfi.bits.valid \u0026\u0026 !io.info.cfi.bits.mispredict){\n\t\t\tcfi_wait_target :\u003d Bool(false)\n\t\t}\n\t}.otherwise{\n\t\tcfi_wait_target :\u003d Bool(false)\n\t}\n\tval cfi_valid \u003d (isCFI_valid || (cfi_wait_target \u0026\u0026 cfi_target_valid  ) ) \u0026\u0026 !pc_NoChange\n\n\tfifo.io.write :\u003d Mux(cfi_en,cfi_valid,Bool(false))\n\tfifo.io.datain :\u003dMux(cfi_en,Mux(isCFI_valid,(io.info.cfi.bits.pc | (io.info.cfi.bits.cfiType\u003c\u003c40) ),io.info.cfi.bits.pc),0.U) //add the cfiType to the fifo data\n\t\t\n\n\twhen(inst(5,0) \u003d\u003d\u003d CO_FIFO_INPUT \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r){\n\t\tswitch( inst(11,6) ){\n\t\t\tis(0.U){\n\t\t\t\tcfi_en :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\n\n\t///////////////////////////////////////////////////////////////co-load/store\n\t/*\n\tstore the reg to mem just need one cycle\n\tinst(11,6) is the reg id, the inst (17,12)is reg base add ,inst(23,18) \n\n\tload the mem to reg need 2 cycles. cycle read the mem to tmp\n\tinst(11,6) is the tmp reg id\n\t*/\n\tval store_en \u003d inst(5,0) \u003d\u003d\u003d CO_STORE \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval req_valid_store \u003d Reg(init \u003d Bool(false))\n\tval load_en \u003d inst(5,0) \u003d\u003d\u003d CO_LOAD \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval req_valid_load \u003d Reg(init \u003d Bool(false))\n\tval offset_addr_s \u003d Reg(init \u003d Bits(0,width \u003d64))\n\tval offset_addr_l \u003d Reg(init \u003d Bits(0,width \u003d64))\n\tval base_addr_s \u003d Reg(init \u003d Bits(0,width \u003d64))\n\tval base_addr_l \u003d Reg(init \u003d Bits(0,width \u003d64))\n\n\n\tval store_id \u003d Reg(init \u003d Bits(0,width \u003d6))\n\tval load_id \u003d Reg(init \u003d Bits(0,width \u003d6))\n\n\twhen(store_en){\n\t\tstalled_vec(0) :\u003d Bool(true)\n\t\treq_valid_store :\u003d Bool(true)\n\t\tbase_addr_s :\u003d reg(inst(17,12))\n\t\toffset_addr_s :\u003d reg(inst(23,18))\n\t\tstore_id :\u003d inst(11,6)\n\t}.elsewhen(stalled_vec(0) \u0026\u0026 io.mem_p.req.fire()){\n\t\treq_valid_store :\u003d Bool(false)\n\t}.elsewhen(io.mem_p.resp.fire()){\n\t\tstalled_vec(0) :\u003d Bool(false)\n\t}\n\t\t\n\twhen(load_en){\n\t\tstalled_vec(1) :\u003d Bool(true)\n\t\treq_valid_load :\u003d Bool(true)\n\t\tbase_addr_l :\u003d reg(inst(17,12))\n\t\toffset_addr_l :\u003d reg(inst(23,18))\n\t\tload_id :\u003d inst(11,6)\n\t}.elsewhen(stalled_vec(1) \u0026\u0026 io.mem_p.req.fire()){\n\t\treq_valid_load :\u003d Bool(false)\n\t}.elsewhen(io.mem_p.resp.fire()){\n\t\tstalled_vec(1) :\u003d Bool(false)\n\t}\n\n\n\t///////////////////////////////////////////////////////////////ALU\n\t//inst(11,6) rs1 inst(17,12) rs2, inst(23,18) rd\n\tval Add \u003d inst(5,0) \u003d\u003d\u003d CO_ADD \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval Minus \u003d inst(5,0) \u003d\u003d\u003d CO_MINUS \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval Cmp \u003d inst(5,0) \u003d\u003d\u003d CO_CMP \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval SL \u003d inst(5,0) \u003d\u003d\u003d CO_SL \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval RL \u003d inst(5,0) \u003d\u003d\u003d CO_RL \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval BIT_ADD \u003d inst(5,0) \u003d\u003d\u003d CO_BIT_AND \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\n\t\n\tval Add_res \u003d reg(inst(11,6))+reg(inst(17,12))\n\tval Minus_res \u003d reg(inst(11,6))-reg(inst(17,12))\n\tval Cmp_res \u003d Mux(reg(inst(11,6))\u003d\u003d\u003dreg(inst(17,12)),1.U,0.U)\n\tval SL_res \u003d reg(inst(11,6)) \u003c\u003c reg(inst(17,12))(6,0)\n\tval RL_res \u003d reg(inst(11,6)) \u003e\u003e reg(inst(17,12))(6,0)\n\tval BA_res \u003d reg(inst(11,6)) \u0026 reg(inst(17,12))\n\n\n\t///////////////////////////////////////////////////////////////Wreg\n\tval w_reg \u003d inst(5,0) \u003d\u003d\u003d CO_WReg \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval w_reg_data \u003d inst(63,12)\n\n\t///////////////////////////////////////////////////////////////read buffer\n\t//This instruction will stalled the co-core util read the proper message\n\tval r_buf \u003d inst(5,0) \u003d\u003d\u003d CO_R_BUF \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\n\n\n\t///////////////////////////////////////////////////////////////read fifo \n\tval r_fifo \u003d inst(5,0) \u003d\u003d\u003d CO_R_FIFO \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval r_fifo_rd \u003d Reg(init \u003d Bits(0,width \u003d6))\n//\tval fifo_r_data \u003d\n\twhen(r_fifo){\n\t\tstalled_fifo_empty :\u003d Bool(true)\n\t\tr_fifo_rd :\u003d inst(11,6)\n\t\tfifo_r :\u003d Bool(false)\n\t}.elsewhen(stalled_fifo_empty){\n\t\twhen(fifo.io.empty){\n\t\t\tstalled_fifo_empty :\u003d Bool(true)\n\t\t\tfifo_r :\u003d Bool(false)\n\t\t}.otherwise{\n\t\t\tfifo_r :\u003d Bool(true)\n\t\t\tstalled_fifo_empty :\u003d Bool(false)\n\t\t}\n\t}.otherwise{\n\t\tfifo_r :\u003d Bool(false)\n\t}\n\n\t////////////////////////////////////////////////////////////////DO-until\n\t/*\n\tthis instruction used to keep the hardware loop without the jump\n\t*/\n\tval Do_Util \u003d inst(5,0) \u003d\u003d\u003d CO_DO_UNTIL \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval co_event \u003d Reg(init \u003d Bits(0,width\u003d4))\n\tval co_event_value \u003d Reg(init \u003d Bits(0,width\u003d4))\n\tco_event_happen_w :\u003d Mux(co_event\u003d\u003d\u003d0.U,reg(16)\u003d\u003d\u003dco_event_value ,Bool(false) ) \u0026\u0026 do_util //Because of the reg write need one more cycle\n\twhen(Do_Util){\n\t\tdo_util :\u003d Bool(true)\n\t\tco_pc1 :\u003d inst(11,6)\n\t\tco_pc2 :\u003d inst(17,12)\n\t\tco_new_pc :\u003d inst(23,18)\n\t\tco_event :\u003d inst(27,24)\n\t\tco_event_value :\u003d inst(32,28)\n\t\tdo_util_invalid :\u003d Bool(true)\n\t\tco_do_util_happen :\u003d Bool(false)\n\t}.elsewhen(do_util){\n\t\tdo_util_invalid :\u003d Bool(false)\n\t\tswitch(co_event){\n\t\t\tis(0.U){\n\t\t\t\t//event0 : register16\n\t\t\t\twhen(reg(16) \u003d\u003d\u003d co_event_value){\n\t\t\t\t\tdo_util :\u003d Bool(false)\n\t\t\t\t\tco_do_util_happen :\u003d Bool(true)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}.otherwise{\n\t\tdo_util_invalid :\u003d Bool(false)\n\t\tco_do_util_happen :\u003d Bool(false)\n\t}\n\n\n\n/***********\nreg IO\n***********/\n\tval reg_w_id \u003d Mux(stalled_vec(1),load_id, Mux( fifo_r, r_fifo_rd, Mux(w_reg||s_load,inst(11,6),Mux( stalled_s_pop ,s_pop_id,inst(23,18)) ) ))\n\tval reg_w_en \u003d io.mem_p.resp.fire() || Add || Minus || Cmp || SL || RL || BIT_ADD || w_reg || fifo_r || stalled_s_pop || s_load\n\twhen(reg_w_en){\n\t\treg(reg_w_id) :\u003d Mux(stalled_vec(1),io.mem_p.resp.bits.data,Mux(Add,Add_res, Mux(Minus,Minus_res, Mux(Cmp,Cmp_res,Mux(w_reg,w_reg_data,\n\t\t\t\t\t\t\t\tMux(fifo_r, fifo.io.dataout , Mux(SL,SL_res , Mux(RL,RL_res, Mux(BIT_ADD, BA_res, Mux(stalled_s_pop, stack.io.data_out, Mux(s_load ,stack_status ,reg(reg_w_id) ) )) ))  ))))))\n\t}\n\n\n\n/************\nmem(cache) IO\n************/\n\tio.mem_p.req.valid :\u003d req_valid_init || req_valid_load || req_valid_store\n\tio.mem_p.req.bits.addr :\u003d Mux(!initial_done_r,dma_addr + dma_cnt * 8.U, Mux(stalled_vec(0),base_addr_s+offset_addr_s,base_addr_l+offset_addr_l) ) /////////potential bug(0)\n\tio.mem_p.req.bits.data :\u003d Mux(stalled_vec(0), reg(store_id),0.U)\n\tio.mem_p.req.bits.tag :\u003d Bits(0)\n\tio.mem_p.req.bits.cmd :\u003dMux(!initial_done_r || stalled_vec(1),M_XRD,M_XWR) // perform a load (M_XWR for stores)\n\tio.mem_p.req.bits.phys :\u003d Bool(false)\n\tio.mem_p.req.bits.typ :\u003d MT_D\n\n}\n\n\n\n\n\n\n\n\n\n\n\n//wxr------------\n\n\n\n\n\n\n//wxrqw++++++++++++++++\nclass  Co_processor(opcodes: OpcodeSet, val n: Int \u003d 4)(implicit p: Parameters) extends LazyRoCC(opcodes) {\n  override lazy val module \u003d new Co_processor_ModuleImp(this)\n}\n\nclass Co_processor_ModuleImp(outer: Co_processor)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n    with HasCoreParameters {\n  val cmd \u003d Queue(io.cmd)\n  val funct \u003d cmd.bits.inst.funct\n\n\n/*\nTHe co-core\n*/\n\nval co_core \u003d Module(new micro_core(10))\nco_core.io.info.cfi \u003c\u003e io.cfi\nio.mem \u003c\u003e co_core.io.mem_p\n\n\n/*Function 1(funct 0 is i_mem 10 is d_mem), load the memory from the rs1, size is rs2 */ \n  val doLoad \u003d funct \u003d\u003d\u003d UInt(0)\n  val load_valid \u003d Reg(init \u003d Bool(false)) \n  val Load_addr \u003d Reg(init \u003d Bits(0,width\u003d64))\n  val Load_size \u003d Reg(init \u003d Bits(0,width\u003d64))\n  co_core.io.mem_initial.addr :\u003d Load_addr\n  co_core.io.mem_initial.len :\u003d Load_size\n  co_core.io.mem_initial.valid :\u003d load_valid\n\n  when(cmd.fire() \u0026\u0026 doLoad){\n\tLoad_addr :\u003d cmd.bits.rs1\n\tLoad_size :\u003d cmd.bits.rs2\n\tload_valid :\u003d Bool(true)\n  }.otherwise{\n\t  load_valid :\u003d Bool(false)\n  }\n\n\n\n\n/*Function6(funct6) change the register by rocc*/\n  val doChange \u003d (funct \u003d\u003d\u003d UInt(6)) \n  val change_busy \u003d Reg(init \u003d Bool(false))  //rs1 is the size\n  val reg_id_reg \u003d Reg(init \u003d Bits(0,width\u003d5))  //rs1 is the size\n  val reg_value_reg \u003d Reg(init \u003d Bits(0,width\u003d64))  //rs1 is the size\n  io.reg_id :\u003d reg_id_reg\n  io.reg_value :\u003d reg_value_reg\n  io.reg_valid :\u003d change_busy\n\n  when(cmd.fire() \u0026\u0026 doChange){\n\tchange_busy :\u003d Bool(true)\n\treg_id_reg :\u003d cmd.bits.rs1\n\treg_value_reg :\u003d cmd.bits.rs2\n  }.elsewhen(io.reg_ready ){\n\t  change_busy :\u003d Bool(false)\n  }\n\n\n\n\n\n  io.corestall_wxr :\u003d  co_core.io.main_core_stall\n\n  cmd.ready :\u003d  !change_busy\n  io.busy :\u003d cmd.valid \n  io.interrupt :\u003d Bool(false)\n\n  }\n\n//wxrqw----------------\n\n// class  AccumulatorExample(opcodes: OpcodeSet, val n: Int \u003d 4)(implicit p: Parameters) extends LazyRoCC(opcodes) {\n//   override lazy val module \u003d new AccumulatorExampleModuleImp(this)\n// }\n\n// class AccumulatorExampleModuleImp(outer: AccumulatorExample)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n//     with HasCoreParameters {\n//   val regfile \u003d Mem(outer.n, UInt(width \u003d xLen))\n//   val busy \u003d Reg(init \u003d Vec.fill(outer.n){Bool(false)})\n\n//   val cmd \u003d Queue(io.cmd)\n//   val funct \u003d cmd.bits.inst.funct\n//   val addr \u003d cmd.bits.rs2(log2Up(outer.n)-1,0)\n//   val doWrite \u003d funct \u003d\u003d\u003d UInt(0)\n//   val doRead \u003d funct \u003d\u003d\u003d UInt(1)\n//   val doLoad \u003d funct \u003d\u003d\u003d UInt(2)\n//   val doAccum \u003d funct \u003d\u003d\u003d UInt(3)\n//   val memRespTag \u003d io.mem.resp.bits.tag(log2Up(outer.n)-1,0)\n\n//   // datapath\n//   val addend \u003d cmd.bits.rs1\n//   val accum \u003d regfile(addr)\n//   val wdata \u003d Mux(doWrite, addend, accum + addend)\n\n//   when (cmd.fire() \u0026\u0026 (doWrite || doAccum)) {\n//     regfile(addr) :\u003d wdata\n//   }\n\n//   when (io.mem.resp.valid) {\n//     regfile(memRespTag) :\u003d io.mem.resp.bits.data\n//     busy(memRespTag) :\u003d Bool(false)\n//   }\n\n//   // control\n//   when (io.mem.req.fire()) {\n//     busy(addr) :\u003d Bool(true)\n//   }\n\n//   val doResp \u003d cmd.bits.inst.xd\n//   val stallReg \u003d busy(addr)\n//   val stallLoad \u003d doLoad \u0026\u0026 !io.mem.req.ready\n//   val stallResp \u003d doResp \u0026\u0026 !io.resp.ready\n\n//   cmd.ready :\u003d !stallReg \u0026\u0026 !stallLoad \u0026\u0026 !stallResp\n//     // command resolved if no stalls AND not issuing a load that will need a request\n\n//   // PROC RESPONSE INTERFACE\n//   io.resp.valid :\u003d cmd.valid \u0026\u0026 doResp \u0026\u0026 !stallReg \u0026\u0026 !stallLoad\n//     // valid response if valid command, need a response, and no stalls\n//   io.resp.bits.rd :\u003d cmd.bits.inst.rd\n//     // Must respond with the appropriate tag or undefined behavior\n//   io.resp.bits.data :\u003d accum\n//     // Semantics is to always send out prior accumulator register value\n\n//   io.busy :\u003d cmd.valid || busy.reduce(_||_)\n//     // Be busy when have pending memory requests or committed possibility of pending requests\n//   io.interrupt :\u003d Bool(false)\n//     // Set this true to trigger an interrupt on the processor (please refer to supervisor documentation)\n\n//   // MEMORY REQUEST INTERFACE\n//   io.mem.req.valid :\u003d cmd.valid \u0026\u0026 doLoad \u0026\u0026 !stallReg \u0026\u0026 !stallResp\n//   io.mem.req.bits.addr :\u003d addend\n//   io.mem.req.bits.tag :\u003d addr\n//   io.mem.req.bits.cmd :\u003d M_XRD // perform a load (M_XWR for stores)\n//   io.mem.req.bits.typ :\u003d MT_D // D \u003d 8 bytes, W \u003d 4, H \u003d 2, B \u003d 1\n//   io.mem.req.bits.data :\u003d Bits(0) // we\u0027re not performing any stores...\n//   io.mem.req.bits.phys :\u003d Bool(false)\n// }\n\nclass  TranslatorExample(opcodes: OpcodeSet)(implicit p: Parameters) extends LazyRoCC(opcodes, nPTWPorts \u003d 1) {\n  override lazy val module \u003d new TranslatorExampleModuleImp(this)\n}\n\nclass TranslatorExampleModuleImp(outer: TranslatorExample)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n    with HasCoreParameters {\n  val req_addr \u003d Reg(UInt(width \u003d coreMaxAddrBits))\n  val req_rd \u003d Reg(io.resp.bits.rd)\n  val req_offset \u003d req_addr(pgIdxBits - 1, 0)\n  val req_vpn \u003d req_addr(coreMaxAddrBits - 1, pgIdxBits)\n  val pte \u003d Reg(new PTE)\n\n  val s_idle :: s_ptw_req :: s_ptw_resp :: s_resp :: Nil \u003d Enum(Bits(), 4)\n  val state \u003d Reg(init \u003d s_idle)\n\n  io.cmd.ready :\u003d (state \u003d\u003d\u003d s_idle)\n\n  when (io.cmd.fire()) {\n    req_rd :\u003d io.cmd.bits.inst.rd\n    req_addr :\u003d io.cmd.bits.rs1\n    state :\u003d s_ptw_req\n  }\n\n  private val ptw \u003d io.ptw(0)\n\n  when (ptw.req.fire()) { state :\u003d s_ptw_resp }\n\n  when (state \u003d\u003d\u003d s_ptw_resp \u0026\u0026 ptw.resp.valid) {\n    pte :\u003d ptw.resp.bits.pte\n    state :\u003d s_resp\n  }\n\n  when (io.resp.fire()) { state :\u003d s_idle }\n\n  ptw.req.valid :\u003d (state \u003d\u003d\u003d s_ptw_req)\n  ptw.req.bits.valid :\u003d true.B\n  ptw.req.bits.bits.addr :\u003d req_vpn\n\n  io.resp.valid :\u003d (state \u003d\u003d\u003d s_resp)\n  io.resp.bits.rd :\u003d req_rd\n  io.resp.bits.data :\u003d Mux(pte.leaf(), Cat(pte.ppn, req_offset), SInt(-1, xLen).asUInt)\n\n  io.busy :\u003d (state \u003d/\u003d s_idle)\n  io.interrupt :\u003d Bool(false)\n  io.mem.req.valid :\u003d Bool(false)\n}\n\nclass  CharacterCountExample(opcodes: OpcodeSet)(implicit p: Parameters) extends LazyRoCC(opcodes) {\n  override lazy val module \u003d new CharacterCountExampleModuleImp(this)\n  override val atlNode \u003d TLClientNode(Seq(TLClientPortParameters(Seq(TLClientParameters(\"CharacterCountRoCC\")))))\n}\n\nclass CharacterCountExampleModuleImp(outer: CharacterCountExample)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n  with HasCoreParameters\n  with HasL1CacheParameters {\n  val cacheParams \u003d tileParams.icache.get\n\n  private val blockOffset \u003d blockOffBits\n  private val beatOffset \u003d log2Up(cacheDataBits/8)\n\n  val needle \u003d Reg(UInt(width \u003d 8))\n  val addr \u003d Reg(UInt(width \u003d coreMaxAddrBits))\n  val count \u003d Reg(UInt(width \u003d xLen))\n  val resp_rd \u003d Reg(io.resp.bits.rd)\n\n  val addr_block \u003d addr(coreMaxAddrBits - 1, blockOffset)\n  val offset \u003d addr(blockOffset - 1, 0)\n  val next_addr \u003d (addr_block + UInt(1)) \u003c\u003c UInt(blockOffset)\n\n  val s_idle :: s_acq :: s_gnt :: s_check :: s_resp :: Nil \u003d Enum(Bits(), 5)\n  val state \u003d Reg(init \u003d s_idle)\n\n  val (tl_out, edgesOut) \u003d outer.atlNode.out(0)\n  val gnt \u003d tl_out.d.bits\n  val recv_data \u003d Reg(UInt(width \u003d cacheDataBits))\n  val recv_beat \u003d Reg(UInt(width \u003d log2Up(cacheDataBeats+1)), init \u003d UInt(0))\n\n  val data_bytes \u003d Vec.tabulate(cacheDataBits/8) { i \u003d\u003e recv_data(8 * (i + 1) - 1, 8 * i) }\n  val zero_match \u003d data_bytes.map(_ \u003d\u003d\u003d UInt(0))\n  val needle_match \u003d data_bytes.map(_ \u003d\u003d\u003d needle)\n  val first_zero \u003d PriorityEncoder(zero_match)\n\n  val chars_found \u003d PopCount(needle_match.zipWithIndex.map {\n    case (matches, i) \u003d\u003e\n      val idx \u003d Cat(recv_beat - UInt(1), UInt(i, beatOffset))\n      matches \u0026\u0026 idx \u003e\u003d offset \u0026\u0026 UInt(i) \u003c\u003d first_zero\n  })\n  val zero_found \u003d zero_match.reduce(_ || _)\n  val finished \u003d Reg(Bool())\n\n  io.cmd.ready :\u003d (state \u003d\u003d\u003d s_idle)\n  io.resp.valid :\u003d (state \u003d\u003d\u003d s_resp)\n  io.resp.bits.rd :\u003d resp_rd\n  io.resp.bits.data :\u003d count\n  tl_out.a.valid :\u003d (state \u003d\u003d\u003d s_acq)\n  tl_out.a.bits :\u003d edgesOut.Get(\n                       fromSource \u003d UInt(0),\n                       toAddress \u003d addr_block \u003c\u003c blockOffset,\n                       lgSize \u003d UInt(lgCacheBlockBytes))._2\n  tl_out.d.ready :\u003d (state \u003d\u003d\u003d s_gnt)\n\n  when (io.cmd.fire()) {\n    addr :\u003d io.cmd.bits.rs1\n    needle :\u003d io.cmd.bits.rs2\n    resp_rd :\u003d io.cmd.bits.inst.rd\n    count :\u003d UInt(0)\n    finished :\u003d Bool(false)\n    state :\u003d s_acq\n  }\n\n  when (tl_out.a.fire()) { state :\u003d s_gnt }\n\n  when (tl_out.d.fire()) {\n    recv_beat :\u003d recv_beat + UInt(1)\n    recv_data :\u003d gnt.data\n    state :\u003d s_check\n  }\n\n  when (state \u003d\u003d\u003d s_check) {\n    when (!finished) {\n      count :\u003d count + chars_found\n    }\n    when (zero_found) { finished :\u003d Bool(true) }\n    when (recv_beat \u003d\u003d\u003d UInt(cacheDataBeats)) {\n      addr :\u003d next_addr\n      state :\u003d Mux(zero_found || finished, s_resp, s_acq)\n    } .otherwise {\n      state :\u003d s_gnt\n    }\n  }\n\n  when (io.resp.fire()) { state :\u003d s_idle }\n\n  io.busy :\u003d (state \u003d/\u003d s_idle)\n  io.interrupt :\u003d Bool(false)\n  io.mem.req.valid :\u003d Bool(false)\n  // Tie off unused channels\n  tl_out.b.ready :\u003d Bool(true)\n  tl_out.c.valid :\u003d Bool(false)\n  tl_out.e.valid :\u003d Bool(false)\n}\n\nclass OpcodeSet(val opcodes: Seq[UInt]) {\n  def |(set: OpcodeSet) \u003d\n    new OpcodeSet(this.opcodes ++ set.opcodes)\n\n  def matches(oc: UInt) \u003d opcodes.map(_ \u003d\u003d\u003d oc).reduce(_ || _)\n}\n\nobject OpcodeSet {\n  def custom0 \u003d new OpcodeSet(Seq(Bits(\"b0001011\")))\n  def custom1 \u003d new OpcodeSet(Seq(Bits(\"b0101011\")))\n  def custom2 \u003d new OpcodeSet(Seq(Bits(\"b1011011\")))\n  def custom3 \u003d new OpcodeSet(Seq(Bits(\"b1111011\")))\n  def all \u003d custom0 | custom1 | custom2 | custom3\n}\n\nclass RoccCommandRouter(opcodes: Seq[OpcodeSet])(implicit p: Parameters)\n    extends CoreModule()(p) {\n  val io \u003d new Bundle {\n    val in \u003d Decoupled(new RoCCCommand).flip\n    val out \u003d Vec(opcodes.size, Decoupled(new RoCCCommand))\n    val busy \u003d Bool(OUTPUT)\n  }\n\n  val cmd \u003d Queue(io.in)\n  val cmdReadys \u003d io.out.zip(opcodes).map { case (out, opcode) \u003d\u003e\n    val me \u003d opcode.matches(cmd.bits.inst.opcode)\n    out.valid :\u003d cmd.valid \u0026\u0026 me\n    out.bits :\u003d cmd.bits\n    out.ready \u0026\u0026 me\n  }\n  cmd.ready :\u003d cmdReadys.reduce(_ || _)\n  io.busy :\u003d cmd.valid\n\n  assert(PopCount(cmdReadys) \u003c\u003d UInt(1),\n    \"Custom opcode matched for more than one accelerator\")\n}\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.OutOfMemoryError: GC overhead limit exceeded
	at java.util.Arrays.copyOfRange(Arrays.java:3664)
	at java.lang.String.<init>(String.java:207)
	at scala.meta.inputs.Position$Range.text(Position.scala:41)
	at scala.meta.internal.parsing.TokenOps$ScalaTokenEqualizer$.equals(TokenOps.scala:59)
	at scala.meta.internal.parsing.TokenOps$ScalaTokenEqualizer$.equals(TokenOps.scala:56)
	at difflib.myers.MyersDiff.equals(MyersDiff.java:212)
	at difflib.myers.MyersDiff.buildPath(MyersDiff.java:191)
	at difflib.myers.MyersDiff.diff(MyersDiff.java:131)
	at difflib.DiffUtils.diff(DiffUtils.java:103)
	at difflib.DiffUtils.diff(DiffUtils.java:73)
	at scala.meta.internal.parsing.TokenEditDistance$.fromTokens(TokenEditDistance.scala:337)
	at scala.meta.internal.parsing.TokenEditDistance$.$anonfun$apply$5(TokenEditDistance.scala:386)
	at scala.meta.internal.parsing.TokenEditDistance$$$Lambda$3603/284153759.apply(Unknown Source)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.parsing.TokenEditDistance$.$anonfun$apply$4(TokenEditDistance.scala:384)
	at scala.meta.internal.parsing.TokenEditDistance$$$Lambda$3602/1065067277.apply(Unknown Source)
	at scala.Option.flatMap(Option.scala:271)
	at scala.meta.internal.parsing.TokenEditDistance$.apply(TokenEditDistance.scala:383)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:195)
	at scala.meta.internal.metals.Diagnostics.publishDiagnostics(Diagnostics.scala:164)
	at scala.meta.internal.metals.Diagnostics.didChange(Diagnostics.scala:112)
	at scala.meta.internal.metals.MetalsLanguageServer.didChange(MetalsLanguageServer.scala:1193)
	at sun.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint$$Lambda$115/1716093734.apply(Unknown Source)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)

Apr 10, 2022 5:34:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2723
Apr 10, 2022 5:34:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2724
Apr 10, 2022 5:34:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2725
Apr 10, 2022 5:34:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2726
Apr 10, 2022 5:34:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2727
Apr 10, 2022 5:34:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2729
Exception in thread "pool-1-thread-218" java.lang.OutOfMemoryError: GC overhead limit exceeded
Apr 10, 2022 5:34:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2730
Apr 10, 2022 5:34:14 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2731
Apr 10, 2022 5:34:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2735
Apr 10, 2022 5:34:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2737
Apr 10, 2022 5:34:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2738
Apr 10, 2022 5:34:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2733
Apr 10, 2022 5:34:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2736
Apr 10, 2022 5:34:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2740
Apr 10, 2022 5:34:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2741
Apr 10, 2022 5:34:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2745
Exception in thread "pool-1-thread-219" java.lang.OutOfMemoryError: GC overhead limit exceeded
Apr 10, 2022 5:34:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2750
Apr 10, 2022 5:34:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2751
Apr 10, 2022 5:34:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2756
Apr 10, 2022 5:34:49 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2759
Apr 10, 2022 5:34:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2760
Apr 10, 2022 5:34:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2732
Apr 10, 2022 5:34:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2763
Apr 10, 2022 5:34:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2768
2022.04.10 05:34:57 INFO  time: code lens generation in 8.27s
Apr 10, 2022 5:34:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2769
Apr 10, 2022 5:35:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2771
Apr 10, 2022 5:35:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2773
Apr 10, 2022 5:35:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2777
Apr 10, 2022 5:35:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2778
Apr 10, 2022 5:35:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2779
Apr 10, 2022 5:35:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2780
Apr 10, 2022 5:35:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2767
Apr 10, 2022 5:35:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2787
Exception in thread "pool-1-thread-222" java.lang.OutOfMemoryError: GC overhead limit exceeded
Apr 10, 2022 5:35:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "textDocument/didChange",
  "params": {
    "textDocument": {
      "version": 682,
      "uri": "file:///home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala"
    },
    "contentChanges": [
      {
        "text": "// See LICENSE.Berkeley for license details.\n// See LICENSE.SiFive for license details.\n\npackage freechips.rocketchip.tile\n\nimport Chisel._\n\nimport freechips.rocketchip.config._\nimport freechips.rocketchip.subsystem._\nimport freechips.rocketchip.diplomacy._\nimport freechips.rocketchip.rocket._\nimport freechips.rocketchip.tilelink._\nimport freechips.rocketchip.util.InOrderArbiter\n\nimport chisel3.core.{Input, Output}\n\ncase object BuildRoCC extends Field[Seq[Parameters \u003d\u003e LazyRoCC]](Nil)\n\n//flang\nclass DFIPort(implicit p: Parameters) extends CoreBundle {\n\tval test \u003d Bits(width \u003d xLen)\n\tval taraddr \u003d Bits(width \u003d xLen)\n\tval ltaraddr \u003d Bits(width \u003d xLen)\n\tval staraddr \u003d Bits(width \u003d xLen)\n\tval cmd \u003d Bits(width \u003d xLen)\n\tval valid \u003d Bool(INPUT)\n\tval svalid \u003d Bool(INPUT)\n\tval lvalid \u003d Bool(INPUT)\n\tval priv \u003d Bits(width \u003d xLen)\n\tval cycle \u003d Bits(width \u003d xLen)\n\tval cycle_now \u003d Bits(width \u003d xLen)\n\tval threadptr \u003d Input(UInt(xLen.W))\n\tval funcretaddr \u003d Input(UInt(xLen.W))\n\tval funcstackaddr \u003d Input(UInt(xLen.W))\n\tval funcarg0 \u003d Input(UInt(xLen.W))\n\tval funcarg1 \u003d Input(UInt(xLen.W))\n\tval funcarg2 \u003d Input(UInt(xLen.W))\n\tval funcarg3 \u003d Input(UInt(xLen.W))\n\tval funcarg4 \u003d Input(UInt(xLen.W))\n\tval funcarg5 \u003d Input(UInt(xLen.W))\n\tval callvalid \u003d Bool(INPUT)\n\tval retvalid \u003d Bool(INPUT)\n\tval brtarget \u003d Input(SInt(xLen.W))\n}\n\n//wxrqw\nclass CFIPort(implicit p: Parameters) extends CoreBundle {\n\tval taken \u003d Bool(INPUT)\n\tval valid \u003d Bool(INPUT)\n\tval mispredict \u003d Bool(INPUT)\n\tval pc \u003d Input(UInt(40.W))\n\tval cfiType \u003d Input(UInt(2.W))\n\tval isCFI \u003d Bool(INPUT)\n}\n\n\n\nclass RoCCInstruction extends Bundle {\n  val funct \u003d Bits(width \u003d 7)\n  val rs2 \u003d Bits(width \u003d 5)\n  val rs1 \u003d Bits(width \u003d 5)\n  val xd \u003d Bool()\n  val xs1 \u003d Bool()\n  val xs2 \u003d Bool()\n  val rd \u003d Bits(width \u003d 5)\n  val opcode \u003d Bits(width \u003d 7)\n}\n\nclass RoCCCommand(implicit p: Parameters) extends CoreBundle()(p) {\n  val inst \u003d new RoCCInstruction\n  val rs1 \u003d Bits(width \u003d xLen)\n  val rs2 \u003d Bits(width \u003d xLen)\n  val status \u003d new MStatus\n}\n\nclass RoCCResponse(implicit p: Parameters) extends CoreBundle()(p) {\n  val rd \u003d Bits(width \u003d 5)\n  val data \u003d Bits(width \u003d xLen)\n}\n\nclass RoCCCoreIO(implicit p: Parameters) extends CoreBundle()(p) {\n  val cmd \u003d Decoupled(new RoCCCommand).flip\n  val resp \u003d Decoupled(new RoCCResponse)\n  val mem \u003d new HellaCacheIO\n  val busy \u003d Bool(OUTPUT)\n  val interrupt \u003d Bool(OUTPUT)\n  val exception \u003d Bool(INPUT)\n  //flang\n  val corestalled \u003d Bool(INPUT)\n  val corestall \u003d Bool(OUTPUT)\n  val coreexception \u003d Bool(OUTPUT)\n  val canexception \u003d Bool(INPUT)\n  val cmdvalid \u003d Bool(INPUT)\n  val test \u003d Bits(width \u003d xLen).flip\n  val dfi \u003d Decoupled(new DFIPort).flip\n  //wxrqw\n  val corestall_wxr \u003d Bool(OUTPUT)\n  val reg_id \u003d Bits(width\u003d5)\n  val reg_value \u003d Bits(width\u003d64)\n  val reg_valid \u003d Bool(OUTPUT)\n  val reg_ready \u003d Bool(INPUT)\n  val cfi \u003d Decoupled(new CFIPort).flip\n}\n\nclass RoCCIO(val nPTWPorts: Int)(implicit p: Parameters) extends RoCCCoreIO()(p) {\n  val ptw \u003d Vec(nPTWPorts, new TLBPTWIO)\n  val fpu_req \u003d Decoupled(new FPInput)\n  val fpu_resp \u003d Decoupled(new FPResult).flip\n}\n\n/** Base classes for Diplomatic TL2 RoCC units **/\nabstract class LazyRoCC(\n      val opcodes: OpcodeSet,\n      val nPTWPorts: Int \u003d 0,\n      val usesFPU: Boolean \u003d false\n    )(implicit p: Parameters) extends LazyModule {\n  val module: LazyRoCCModuleImp\n  val atlNode: TLNode \u003d TLIdentityNode()\n  val tlNode: TLNode \u003d TLIdentityNode()\n}\n\nclass LazyRoCCModuleImp(outer: LazyRoCC) extends LazyModuleImp(outer) {\n  val io \u003d IO(new RoCCIO(outer.nPTWPorts))\n}\n\n/** Mixins for including RoCC **/\n\ntrait HasLazyRoCC extends CanHavePTW { this: BaseTile \u003d\u003e\n  val roccs \u003d p(BuildRoCC).map(_(p))\n\n  roccs.map(_.atlNode).foreach { atl \u003d\u003e tlMasterXbar.node :\u003d* atl }\n  roccs.map(_.tlNode).foreach { tl \u003d\u003e tlOtherMastersNode :\u003d* tl }\n\n  nPTWPorts +\u003d roccs.map(_.nPTWPorts).foldLeft(0)(_ + _)\n  nDCachePorts +\u003d roccs.size\n}\n\ntrait HasLazyRoCCModule extends CanHavePTWModule\n    with HasCoreParameters { this: RocketTileModuleImp with HasFpuOpt \u003d\u003e\n\n  val (respArb, cmdRouter) \u003d if(outer.roccs.size \u003e 0) {\n    val respArb \u003d Module(new RRArbiter(new RoCCResponse()(outer.p), outer.roccs.size))\n    val cmdRouter \u003d Module(new RoccCommandRouter(outer.roccs.map(_.opcodes))(outer.p))\n    outer.roccs.zipWithIndex.foreach { case (rocc, i) \u003d\u003e\n      ptwPorts ++\u003d rocc.module.io.ptw\n      rocc.module.io.cmd \u003c\u003e cmdRouter.io.out(i)\n      val dcIF \u003d Module(new SimpleHellaCacheIF()(outer.p))\n      dcIF.io.requestor \u003c\u003e rocc.module.io.mem\n      dcachePorts +\u003d dcIF.io.cache\n      respArb.io.in(i) \u003c\u003e Queue(rocc.module.io.resp)\n    }\n\n    fpuOpt foreach { fpu \u003d\u003e\n      val nFPUPorts \u003d outer.roccs.filter(_.usesFPU).size\n      if (usingFPU \u0026\u0026 nFPUPorts \u003e 0) {\n        val fpArb \u003d Module(new InOrderArbiter(new FPInput()(outer.p), new FPResult()(outer.p), nFPUPorts))\n        val fp_rocc_ios \u003d outer.roccs.filter(_.usesFPU).map(_.module.io)\n        fpArb.io.in_req \u003c\u003e fp_rocc_ios.map(_.fpu_req)\n        fp_rocc_ios.zip(fpArb.io.in_resp).foreach {\n          case (rocc, arb) \u003d\u003e rocc.fpu_resp \u003c\u003e arb\n        }\n        fpu.io.cp_req \u003c\u003e fpArb.io.out_req\n        fpArb.io.out_resp \u003c\u003e fpu.io.cp_resp\n      } else {\n        fpu.io.cp_req.valid :\u003d Bool(false)\n        fpu.io.cp_resp.ready :\u003d Bool(false)\n      }\n    }\n    (Some(respArb), Some(cmdRouter))\n  } else {\n    (None, None)\n  }\n}\n\n//flang++++++++++++++++\n\nclass DFIFIFO(depth: Int, datawidth: Int)(implicit p: Parameters) extends Module {\n\tval io \u003d new Bundle{\n\t\tval rst \u003d Bool(INPUT)\n\t\tval write \u003d Bool(INPUT)\n\t\tval datain \u003d Bits(width \u003d datawidth).flip\n\t\tval read \u003d Bool(INPUT)\n\t\tval dataout \u003d Bits(width \u003d datawidth)\n\t\tval full \u003d Bool(OUTPUT)\n\t\tval empty \u003d Bool(OUTPUT)\n\t}\n\tval head \u003d Reg(init \u003d Bits(0,width \u003d 12))\n\tval tail \u003d Reg(init \u003d Bits(0,width \u003d 12))\n\tval addrwidth \u003d log2Up(depth)\n\t//val buffer\u003dReg(init \u003d Vec.fill(depth){Bits(0,width \u003d datawidth)})\n\tval buffer\u003dMem(depth,Bits(width \u003d datawidth))\n\t\n\tval nowfull \u003d ((head(addrwidth-1,0) \u003d\u003d\u003d tail(addrwidth-1,0)) \u0026\u0026 (head(addrwidth) \u003d/\u003d tail(addrwidth)))\n\tval willfull \u003d io.write \u0026\u0026 (head(addrwidth-1,0) \u003d\u003d\u003d (tail+Bits(1))(addrwidth-1,0)) \u0026\u0026 (head(addrwidth) \u003d/\u003d (tail+Bits(1))(addrwidth))\n\tval nowempty \u003d ((head(addrwidth-1,0) \u003d\u003d\u003d tail(addrwidth-1,0)) \u0026\u0026 (head(addrwidth) \u003d\u003d\u003d tail(addrwidth)))\n\tval willempty \u003d (io.read \u0026\u0026 ((head+Bits(1))(addrwidth-1,0) \u003d\u003d\u003d tail(addrwidth-1,0)) \u0026\u0026 ((head+Bits(1))(addrwidth) \u003d\u003d\u003d tail(addrwidth)))\n\tio.full :\u003d nowfull || willfull\n\tio.empty :\u003d nowempty || willempty\n\t\n\t//val outbuf\u003dReg(init \u003d Bits(0,width \u003d datawidth))\n\t\n\twhen(io.rst){\n\t\thead :\u003d Bits(0)\n\t\ttail :\u003d Bits(0)\n\t}\n\twhen(!io.rst \u0026\u0026 io.write){\n\t\twhen(!nowfull){\n\t\t\tbuffer(tail(addrwidth-1,0)) :\u003d io.datain\n\t\t\ttail :\u003d tail + Bits(1)\n\t\t}.otherwise{}\n\t}\n\twhen(!io.rst \u0026\u0026 io.read){\n\t\twhen(!nowempty){\n\t\t\thead :\u003d head + Bits(1)\n\t\t}.otherwise{}\n\t}.otherwise{}\n\tio.dataout :\u003d buffer(head(addrwidth-1,0))\n}\n\nclass DFI_stoptbuf(size: Int, addrwidth: Int)(implicit p: Parameters) extends Module {\n\tval io \u003d new Bundle {\n\t\tval rst \u003d Bool(INPUT)\n\t\tval rw \u003d Bits(width \u003d 1)\n\t\tval id \u003d Bits(width \u003d 16)\n\t\tval taraddr \u003d Bits(width \u003d addrwidth)\n\t\tval red \u003d Bool(OUTPUT)\n\t}\n}\n\nclass DFILdOptBuf(size: Int, addrwidth: Int)(implicit p: Parameters) extends Module {\n\tval io \u003d new Bundle{\n\t\tval rst \u003d Bool(INPUT)\n\t\tval rw \u003d Bits(width \u003d 1).flip\n\t\tval id \u003d Bits(width \u003d 16).flip\n\t\tval taraddr \u003d Bits(width \u003d addrwidth).flip\n\t\tval red \u003d Bool(OUTPUT)\n\t}\n\tval buf_id\u003dReg(init \u003d Vec.fill(size){Bits(0,width \u003d 16)})\n\tval buf_taraddr\u003dReg(init \u003d Vec.fill(size){Bits(0,width \u003d addrwidth)})\n\t\n\tval sameid\u003dVec.fill(size){Bool(false)}\n\tval sametaraddr\u003dVec.fill(size){Bool(false)}\n\t\n\tfor (i\u003c- 0 to size-1){\n\t\tsameid(i) :\u003d (io.id \u003d\u003d\u003d buf_id(i))\n\t\tsametaraddr(i) :\u003d (io.taraddr \u003d\u003d\u003d buf_taraddr(i))\n\t}\n\t\n\tbuf_id(0) :\u003d Mux(io.rst,Bits(0),Mux(io.rw \u003d\u003d\u003d Bits(1), io.id, buf_id(0)))\n\tbuf_taraddr(0) :\u003d Mux(io.rst,Bits(0),Mux(io.rw \u003d\u003d\u003d Bits(1), io.taraddr, buf_taraddr(0)))\n\tfor (i\u003c- 1 to size-1){\n\t\tbuf_id(i) :\u003d Mux(io.rst,Bits(0),Mux(io.rw \u003d\u003d\u003d Bits(1), buf_id(i-1), Mux(sametaraddr(i), Bits(0), buf_id(i))))\n\t\tbuf_taraddr(i) :\u003d Mux(io.rst,Bits(0),Mux(io.rw \u003d\u003d\u003d Bits(1), buf_taraddr(i-1), Mux(sametaraddr(i), Bits(0), buf_taraddr(i))))\n\t}\n\t\n\tval sameboth\u003dVec.fill(size){Bool(false)}\n\tfor (i\u003c- 0 to size-1){\n\t\tsameboth(i) :\u003d (sameid(i)\u0026\u0026sametaraddr(i))\n\t}\n\t\n\tval midre\u003dVec.fill(size){Vec.fill(size){Bool(false)}}\n\tfor (i\u003c- 0 to log2Up(size)-1){\n\t\tfor (j\u003c- 0 to (1\u003c\u003ci)-1){\n\t\t\tif(i\u003clog2Up(size)-1){\n\t\t\t\tmidre(i)(j) :\u003d midre(i+1)(j\u003c\u003c1) | midre(i+1)((j\u003c\u003c1)+1)\n\t\t\t}else{\n\t\t\t\tmidre(i)(j) :\u003d sameboth(j\u003c\u003c1) | sameboth((j\u003c\u003c1)+1)\n\t\t\t}\n\t\t}\n\t}\n\tio.red :\u003d midre(0)(0)\n}\n\nclass  DFIcheck(opcodes: OpcodeSet)(implicit p: Parameters) extends LazyRoCC(opcodes) {\n  override lazy val module \u003d new DFIcheckImp(this)\n}\n\nclass DFIcheckImp2(outer: DFIcheck)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n    with HasCoreParameters {\n}\n\nclass DFIcheckImp(outer: DFIcheck)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n    with HasCoreParameters {\n\t//IMPORTANT!!!!!: this module works under the assumption that the lowest 3 bits of rdsaddr, rdtaddr and debugaddr are all 0\n\t//info format:\n\t//21-20 \u003d 0 : 19 \u003d 0 : 16:st/ld, 15-0: id\n\t//21-20 \u003d 0 : 19 \u003d 1 : 18:ld?, 17:st?, 16:call/ret? 15-0: id\n\t//21-20 \u003d 1 : rdt addr\n\t//21-20 \u003d 2 : rds addr\n\t//21-20 \u003d 3 : debug addr, 19 \u003d 1 : run with debug\n\t//21-20 \u003d 3 : debug addr, 18 \u003d 1 : write debug\n\t//21-20 \u003d 3 : debug addr, 17 \u003d 1 : func signal\n\t\n\tdef SIMULATION: Bool \u003d Bool(false)\n\t\n\tdef fifostldsize: Int \u003d 64\n\tdef fifofuncsize: Int \u003d 8\n\t\n\tdef ldopbufsize: Int \u003d 64\n\t\n\tdef shdstacksize: Int \u003d 1024\n\t\n\tdef bufsize: Int \u003d 8\n\t\n\tdef addrshift: Int \u003d 2\n\t\n\tdef rdscacheaddrwidth: Int \u003d 10\n\tdef rdsaddrwidth: Int \u003d 16 //log(how many entry), not how many bytes\n\tdef rdscacheaddrmask: UInt \u003d UInt((1\u003c\u003crdscacheaddrwidth)-1)\n\t\n\tdef rdsmapcacheaddrwidth: Int \u003d 10\n\tdef rdsmapaddrwidth: Int \u003d 16 //log(how many entry), not how many bytes\n\tdef rdsmapcacheaddrmask: UInt \u003d UInt((1\u003c\u003crdsmapcacheaddrwidth)-1)\n\t\n\t//def rdtcacheaddrwidth: Int \u003d 5\n\t//def rdtaddrwidth: Int \u003d 8 //log(how many entry), not how many bytes\n\tdef rdtcacheaddrwidth: Int \u003d 10\n\tdef rdtaddrwidth: Int \u003d 25 //log(how many entry), not how many bytes\n\tdef addrmask: Int \u003d (1\u003c\u003crdtaddrwidth)-1\n\tdef rdtcacheaddrmask: UInt \u003d UInt((1\u003c\u003crdtcacheaddrwidth)-1)\n\t\n\tval addrrdt \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval addrrds \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval addrdebug \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//target address acuqire\n\tval saddrbuf \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval scyclebuf \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval saddrbuf_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval laddrbuf \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval lcyclebuf \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval laddrbuf_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval staraddrs \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval staraddrs_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval ltaraddrs \u003d Reg(init \u003d Vec.fill(bufsize){Bits(0,width \u003d xLen)})\n\tval ltaraddrs_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval staraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval ltaraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//DFI shared\n\tval count \u003d Reg(init \u003d Bits(0,width \u003d 8))\n\tval countreq \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval countresp \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval countstinflight \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval matched \u003d Reg(init \u003d Bool(true))\n\tval info_debug \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval infor \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval haserror \u003d Reg(init \u003d Bool(false))\n\tval waitresp \u003d Reg(init \u003d Bool(false))\n\t\n\t//st/ld DFI\n\tval slneedprocess \u003d Reg(init \u003d Bits(0,width \u003d 2))\n\tval taraddr \u003d Reg(init \u003d Vec.fill(2){Bits(0,width \u003d xLen)})\n\tval rw \u003d Reg(init \u003d Bits(0,width \u003d 1))\n\tval id \u003d Reg(init \u003d Vec.fill(3){Bits(0,width \u003d xLen)})\n\tval prevwid \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdsid \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdsp \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdse \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//func DFI\n\tval brneedprocess \u003d Reg(init \u003d Vec.fill(2){Bool(false)})\n\tval waitingcall \u003d Reg(init \u003d Bool(false))\n\tval repcall \u003d Reg(init \u003d Bool(false))\n\tval callremain \u003d Reg(init \u003d Vec.fill(3){Bool(false)})\n\tval brremain \u003d Reg(init \u003d Vec.fill(2){Bool(false)})\n\tval brtarget \u003d Reg(init \u003d Vec.fill(2){SInt(0,width \u003d xLen)})\n\tval funcretaddr \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg0 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg1 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg2 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg3 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg4 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcarg5 \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcretpointer \u003d Reg(init \u003d Vec.fill(2){UInt(0,width \u003d xLen)})\n\tval funcmode \u003d Reg(init \u003d Vec.fill(3){Bits(0,width \u003d 2)})//000: normal call; 001: lib call, w; 010: lib call, r; 011: lib call, w+r; 100: ret \n\tval funciscall \u003d Reg(init \u003d Vec.fill(2){Bool(false)})\n\tval funccount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalfunccount \u003d Reg(init \u003d Vec.fill(2){Bits(0,width \u003d xLen)})\n\t\n\t//for stop\n\tval stop_call_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval stop_call_count_all \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval stop_call_count_max \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval stop_call_count_keep \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval stop_repcall \u003d Reg(init \u003d Bool(false))\n\tval stop_brtarget \u003d Reg(init \u003d SInt(0,width \u003d xLen))\n\tval stop_coreexception \u003d Reg(init \u003d Bool(false))\n\tio.coreexception :\u003d stop_coreexception\n\t\n\t//for debug\n\tval opst_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval opld_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval uprdt_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdrdt_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdrdsmap_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval rdrds_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval chk_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg0 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg1 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg2 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg3 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg4 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibarg5 \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibretaddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxlibretptr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval maxliblen \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalldopt \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalldnoopt \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdtcachehit \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdsmapcachehit \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdscachehit \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdtcachemiss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdsmapcachemiss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalrdscachemiss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval idle_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval total_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocuspush_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncpush_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocuspop_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncpop_cycle \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusbranchpush \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusbranchpop \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncbranchpush \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncbranchpop \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncloss \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestinfo \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlossinfo \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlossrecord \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlosscuscount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlossfunccount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusmax \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofuncmax \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatestlosstaraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifofunclatesttaraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval shdstackmax \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalstcount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalldcount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalcallcount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval totalcallexceptioncount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\tval rdtreaddebug_p \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//latency check\n\t/*\n\tval lat_st_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ld_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ret_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_call_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libst_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libld_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libstld_state \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_st_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ld_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_call_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libst_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libld_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libstld_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ret_fifo_red \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_st_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_st_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ld_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ld_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ret_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_ret_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_call_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_call_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libst_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libst_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libld_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libld_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libstld_cycles \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_libstld_count \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval lat_cate \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t*/\n\t//latency check FSM parameters\n\tdef LAT_IDLE: Int \u003d 0\n\tdef LAT_WAIT_ENQ: Int \u003d 1\n\tdef LAT_WAIT_POP: Int \u003d 2\n\tdef LAT_WAIT_END: Int \u003d 3\n\t\n\t//timeout\n\tval timeout \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tdef maxtimeout: Int \u003d 300\n\t\n\t//record\n\tval violations\u003dReg(init \u003d Bits(0,width \u003d 16))\n\tval errorcount\u003dReg(init \u003d Bits(0,width \u003d 32))\n\tval totalcount\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//opt buf\n\tval ldoptbuf \u003d Module(new DFILdOptBuf(ldopbufsize, xLen)(outer.p))\n\tval ldopt_rst \u003d Reg(init \u003d Bool(false))\n\tval ldopt_rw \u003d Reg(init \u003d Bits(0,width \u003d 1))\n\tval ldopt_id \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval ldopt_taraddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tldoptbuf.io.rst :\u003d ldopt_rst\n\tldoptbuf.io.rw :\u003d ldopt_rw\n\tldoptbuf.io.id :\u003d ldopt_id\n\tldoptbuf.io.taraddr :\u003d ldopt_taraddr\n\tval ldopt_red \u003d Reg(init \u003d Bool(false))\n\n\t//shadow stack\n\t//not use yet\n\t//val shdstack \u003d Mem(shdstacksize, Bits(width \u003d xLen))\n\tval shdstkaddr \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval shdstkcount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval shdstkdatain \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t//val shdstkdataout \u003d shdstack(shdstkaddr - Bits(1))\n\t//shdstack(shdstkaddr) :\u003d shdstkdatain\n\t\n\t//FIFO\n\tval fifocustom \u003d Module(new Queue(Bits(width \u003d 64+22), fifostldsize))\n\tval fifocusenqvalid \u003d Reg(init \u003d Bool(false))\n\tval fifocusdeqready \u003d Reg(init \u003d Bool(false))\n\tval fifocusdatain \u003d Reg(init \u003d Bits(0,width \u003d 64+22))\n\tfifocustom.io.enq.valid :\u003d fifocusenqvalid\n\tfifocustom.io.enq.bits :\u003d fifocusdatain\n\tfifocustom.io.deq.ready :\u003d fifocusdeqready\n\tval fifocuscount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval waitinginfifocus \u003d Reg(init \u003d Bool(false))\n\t\n\tval fifofunc \u003d Module(new Queue(Bits(width \u003d 2+1+1+16+64+64*3), fifofuncsize))\n\tval fifofuncenqvalid \u003d Reg(init \u003d Bool(false))\n\tval fifofuncdeqready \u003d Reg(init \u003d Bool(false))\n\tval fifofuncdatain \u003d Reg(init \u003d Bits(0,width \u003d 2+1+1+16+64+64*3))\n\tfifofunc.io.enq.valid :\u003d fifofuncenqvalid\n\tfifofunc.io.enq.bits :\u003d fifofuncdatain\n\tfifofunc.io.deq.ready :\u003d fifofuncdeqready\n\tval fifofunccount \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval waitinginfifofunc \u003d Reg(init \u003d Bool(false))\n\tval waitingcallfifo \u003d Reg(init \u003d Bool(false))\n\t\n\t/*\n\tval testfifo \u003d Module(new Queue(Bits(width \u003d 8), 4))\n\tval fifotestvalid \u003d Reg(init \u003d Bool(false))\n\tval fifotestready \u003d Reg(init \u003d Bool(false))\n\tval fifotestdatain \u003d Reg(init \u003d Bits(0,width \u003d 8))\n\ttestfifo.io.enq.valid :\u003d fifotestvalid\n\ttestfifo.io.enq.bits :\u003d fifotestdatain\n\ttestfifo.io.deq.ready :\u003d fifotestready\n\tval fifostate \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\twhen(fifostate\u003cBits(4)){\n\t\twhen(testfifo.io.enq.fire()){\n\t\t\tprintf(\"enq data %x\\n\",fifotestdatain)\n\t\t\tfifostate :\u003d fifostate + Bits(1)\n\t\t\tfifotestvalid :\u003d Bool(false)\n\t\t}.otherwise{\n\t\t\tfifotestvalid :\u003d Bool(true)\n\t\t\tfifotestdatain :\u003d fifostate + Bits(1)\n\t\t}\n\t}.otherwise{\n\t\twhen(testfifo.io.deq.fire()){\n\t\t\tprintf(\"deq data %x\\n\",testfifo.io.deq.bits)\n\t\t}.otherwise{\n\t\t\tfifotestready :\u003d Bool(true)\n\t\t}\n\t}\n\t*/\n\t/*\n\tval fifocustom\u003dMem(4,Bits(width \u003d 32))\n\tval fifocusaddrwidth\u003dlog2Up(4)\n\tval fifocushead \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocustail \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusdatain \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tfifocustom(fifocustail(fifocusaddrwidth-1,0)) :\u003d fifocusdatain\n\tval fifocusdataout\u003dfifocustom(fifocushead(fifocusaddrwidth-1,0))\n\t*/\n\t/*\n\tval fifocustom \u003d Module(new DFIFIFO(4, 32)(outer.p))\n\tval fifocusrst \u003d Reg(init \u003d Bool(false))\n\tval fifocuswrite \u003d Reg(init \u003d Bool(false))\n\tval fifocusdatain \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\tval fifocusread \u003d Reg(init \u003d Bool(false))\n\tfifocustom.io.rst :\u003d fifocusrst\n\tfifocustom.io.write :\u003d fifocuswrite\n\tfifocustom.io.datain :\u003d fifocusdatain\n\tfifocustom.io.read :\u003d fifocusread\n\t\n\tval fifostate \u003d Reg(init \u003d Bits(0,width \u003d xLen))\n\t\n\tfifostate :\u003d fifostate + Bits(1)\n\t\n\twhen(fifostate \u003c\u003d Bits(20)){\n\twhen(!fifocustom.io.full){\n\t\tfifocuswrite :\u003d Bool(true)\n\t\tfifocusdatain :\u003d io.dfi.bits.cycle_now+Bits(1)\n\t\tprintf(\"FIFO write %x\\n\",io.dfi.bits.cycle_now+Bits(1))\n\t}.otherwise{\n\t\tfifocuswrite :\u003d Bool(false)\n\t}\n\t\n\twhen(!fifocustom.io.empty){\n\t\tfifocusread :\u003d Bool(true)\n\t\tfifocusdatain :\u003d io.dfi.bits.cycle_now\n\t\tprintf(\"not empty FIFO read %x\\n\",fifocustom.io.dataout)\n\t}.otherwise{\n\t\tprintf(\"FIFO read %x\\n\",fifocustom.io.dataout)\n\t\tfifocusread :\u003d Bool(false)\n\t}\n\t}\n\t*/\n\t/*\n\twhen(fifostate\u003d\u003d\u003dBits(0)){\n\t\twhen(!fifocustom.io.full){\n\t\t\tfifocuswrite :\u003d Bool(true)\n\t\t\tfifocusdatain :\u003d io.dfi.bits.cycle_now+Bits(1)\n\t\t\tprintf(\"FIFO write %x\\n\",io.dfi.bits.cycle_now+Bits(1))\n\t\t}.otherwise{\n\t\t\tfifocuswrite :\u003d Bool(false)\n\t\t\tfifostate :\u003d Bits(1)\n\t\t}\n\t}.elsewhen(fifostate\u003c\u003dBits(15)){\n\t\twhen(!fifocustom.io.empty){\n\t\t\tfifocusread :\u003d Bool(true)\n\t\t\tfifocusdatain :\u003d io.dfi.bits.cycle_now\n\t\t\tprintf(\"not empty FIFO read %x\\n\",fifocustom.io.dataout)\n\t\t}.otherwise{\n\t\t\tprintf(\"FIFO read %x\\n\",fifocustom.io.dataout)\n\t\t\tfifocusread :\u003d Bool(false)\n\t\t\tfifostate :\u003d fifostate + Bits(1)\n\t\t}\n\t}\n\t*/\n\t/*\n\t//funcmode 2, iscall 1, retpointer 64, arg0-2 64*3,\n\tval fifofunc \u003d Module(new DFIFIFO(4, 2+1+64+64*3)(outer.p))\n\tval fifofuncrst \u003d Reg(init \u003d Bool(false))\n\tval fifofuncwrite \u003d Reg(init \u003d Bool(false))\n\tval fifofuncdatain \u003d Reg(init \u003d Bits(0,width \u003d 2+1+64+64*3))\n\tval fifofuncread \u003d Reg(init \u003d Bool(false))\n\tfifofunc.io.rst :\u003d fifofuncrst\n\tfifofunc.io.write :\u003d fifofuncwrite\n\tfifofunc.io.datain :\u003d fifofuncdatain\n\tfifofunc.io.read :\u003d fifofuncread\n\t*/\n\t\n\t//FSM parameters\n\tdef IDLE: Int \u003d 0\n\tdef WAIT: Int \u003d 1\n\tdef WRITERDT: Int \u003d 2\n\tdef READRDT: Int \u003d 3\n\tdef READRDSMAP: Int \u003d 4\n\tdef READRDS: Int \u003d 5\n\tdef CHECK: Int \u003d 6\n\tdef FUNCSTATE: Int \u003d 7\n\tdef WRITELDTRACE: Int \u003d 8\n\tdef WRITEDEBUG: Int \u003d 9\n\tdef ERROR: Int \u003d 10\n\tdef REPORT: Int \u003d 11\n\tdef READRDTRDSMAP: Int \u003d 12\n\tdef READRDTCACHE: Int \u003d 13\n\tdef READRDSMAPCACHE: Int \u003d 14\n\tdef CACHERESET: Int \u003d 15\n\tdef READSTOPCOND: Int \u003d 16\n\t\n\tval state \u003d Reg(init \u003d Bits(IDLE,width \u003d 8))\n\tval nstate \u003d Reg(init \u003d Bits(IDLE,width \u003d 8))\n\tval pstate \u003d Reg(init \u003d Bits(IDLE,width \u003d 8))\n\t\n\tval ldstate \u003d Reg(init \u003d Bits(IDLE,width \u003d 8))\n\t\n\t//control\n\tval busystld \u003d Reg(init \u003d Bool(false))\n\tval busyfunc \u003d Reg(init \u003d Bool(false))\n\tval stallfunc \u003d Reg(init \u003d Bool(false))\n\tval stallstld \u003d Reg(init \u003d Bool(false))\n\t\n    io.corestall :\u003d stallfunc || stallstld\n\t//val cmd \u003d Queue(io.cmd)\n\tval cmd \u003d io.cmd\n\tcmd.ready :\u003d !(busystld || busyfunc) //\u0026\u0026 (violations \u003d\u003d\u003d Bits(0))\n\t\n\t//wb, not use\n\tio.resp.valid :\u003d Bool(false)//cmd.valid \u0026\u0026 cmd.bits.inst.xd \u0026\u0026 io.mem.req.ready\n\tio.resp.bits.rd :\u003d cmd.bits.inst.rd\n\tio.resp.bits.data :\u003d Bits(0)//wdata\n\tio.busy :\u003d Bool(false) //cmd.valid || busy\n\tio.interrupt :\u003d Bool(false)\n\t\n\t//get the DFI info\n\tval info\u003d(cmd.bits.inst.funct\u003c\u003c15)|(cmd.bits.inst.rs2\u003c\u003c10)|(cmd.bits.inst.rs1\u003c\u003c5)|(cmd.bits.inst.rd)\n\t\n\t//memory control\n\tval memvalid \u003d Reg(init \u003d Bool(false))\n\tval memaddr\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval memaddrmod\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval memtag \u003d Reg(init \u003d Bits(0,width \u003d xLen))//used for record the memtype of the request\n\tval memdatain\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval memdataout\u003dMux(memtag(1) \u003d\u003d\u003d Bits(1),Mux(memtag(0) \u003d\u003d\u003d Bits(1), io.mem.resp.bits.data, io.mem.resp.bits.data(31,0)), Mux(memtag(0) \u003d\u003d\u003d Bits(1), io.mem.resp.bits.data(15,0), io.mem.resp.bits.data(7,0)))\n\tval memw\u003dReg(init \u003d Bool(false))\n\tval memtype\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\t\n\tval pmemaddr\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval pmemdatain\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\tval pmemw\u003dReg(init \u003d Bool(false))\n\tval pmemtype\u003dReg(init \u003d Bits(0,width \u003d xLen))\n\t\n\t//val memaddrfix \u003d Mux((memaddr\u003e\u003dBits(0xf4084000L) \u0026\u0026 memaddr\u003cBits(0xf4084000L+0x6000000L)), memaddr, Bits(0xf4084000L+0x4400000L))\n\tval memaddrfix \u003d memaddr\n\t\n\tval memoffdata \u003d memdatain\u003c\u003c(((memaddrfix(2,0))\u003c\u003c3))\n\t\n\tio.mem.req.valid :\u003d memvalid//cmd.valid \u0026\u0026 ((funct \u003d\u003d\u003d UInt(1)) || (funct \u003d\u003d\u003d UInt(2))) // \u0026\u0026 !busy\n\tio.mem.req.bits.addr :\u003d memaddrfix\n\tio.mem.req.bits.tag :\u003d memtag\n\tio.mem.req.bits.cmd :\u003d Mux(memw,M_XWR,M_XRD)//M_XRD // perform a load (M_XWR for stores)\n\tio.mem.req.bits.typ :\u003d Mux(memtype(1) \u003d\u003d\u003d Bits(1),Mux(memtype(0) \u003d\u003d\u003d Bits(1), MT_D, MT_W), Mux(memtype(0) \u003d\u003d\u003d Bits(1), MT_H, MT_B))//memtype // D \u003d 8 bytes, W \u003d 4, H \u003d 2, B \u003d 1\n\tio.mem.req.bits.data :\u003d memoffdata\n\tio.mem.req.bits.phys :\u003d Mux(SIMULATION,Bool(false),Bool(true))//Bool(true)\n\t\n\t//caches\n\tval rdtcache \u003d Mem((1\u003c\u003crdtcacheaddrwidth), Bits(width \u003d rdtaddrwidth-rdtcacheaddrwidth+64))\n\tval rdtcwaddr \u003d Reg(init \u003d Bits(0,width \u003d rdtcacheaddrwidth))\n\tval rdtcraddr \u003d Reg(init \u003d Bits(0,width \u003d rdtcacheaddrwidth))\n\tval rdtcdatain \u003d Reg(init \u003d Bits(0,width \u003d rdtaddrwidth-rdtcacheaddrwidth-2+64))\n\tval rdtcdataout \u003d rdtcache(rdtcraddr)\n\trdtcache(rdtcwaddr) :\u003d rdtcdatain\n\tval rdtcprobing \u003d Reg(init \u003d Bool(false))\n\t\n\tval rdsmapcache \u003d Mem((1\u003c\u003crdsmapcacheaddrwidth), Bits(width \u003d rdsmapaddrwidth-rdsmapcacheaddrwidth+64))\n\tval rdsmapcwaddr \u003d Reg(init \u003d Bits(0,width \u003d rdsmapcacheaddrwidth))\n\tval rdsmapcraddr \u003d Reg(init \u003d Bits(0,width \u003d rdsmapcacheaddrwidth))\n\tval rdsmapcdatain \u003d Reg(init \u003d Bits(0,width \u003d rdsmapaddrwidth-rdsmapcacheaddrwidth+64))\n\tval rdsmapcdataout \u003d rdsmapcache(rdsmapcraddr)\n\trdsmapcache(rdsmapcwaddr) :\u003d rdsmapcdatain\n\tval rdsmapcprobing \u003d Reg(init \u003d Bool(false))\n\t\n\tval rdscache \u003d Mem((1\u003c\u003crdscacheaddrwidth), Bits(width \u003d rdsaddrwidth-rdscacheaddrwidth+64))\n\tval rdscwaddr \u003d Reg(init \u003d Bits(0,width \u003d rdscacheaddrwidth))\n\tval rdscraddr \u003d Reg(init \u003d Bits(0,width \u003d rdscacheaddrwidth))\n\tval rdscdatain \u003d Reg(init \u003d Bits(0,width \u003d rdsaddrwidth-rdscacheaddrwidth+64))\n\tval rdscdataout \u003d rdscache(rdscraddr)\n\trdscache(rdscwaddr) :\u003d rdscdatain\n\tval rdscprobing \u003d Reg(init \u003d Bool(false))\n\t\n\t//dfi check\n\tval checkmatch0\u003d(rdsp)\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp)\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 io.mem.resp.bits.data(15,0) \u003d\u003d\u003d prevwid\n\tval checkmatch1\u003d(rdsp+Bits(1))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(1))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 io.mem.resp.bits.data(31,16) \u003d\u003d\u003d prevwid\n\tval checkmatch2\u003d(rdsp+Bits(2))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(2))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 io.mem.resp.bits.data(47,32) \u003d\u003d\u003d prevwid\n\tval checkmatch3\u003d(rdsp+Bits(3))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(3))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 io.mem.resp.bits.data(63,48) \u003d\u003d\u003d prevwid\n\tval onematched\u003d(checkmatch0 || checkmatch1) || (checkmatch2 || checkmatch3)\n\t\n\tval ccheckmatch0\u003d(rdsp)\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp)\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 rdscdataout(15,0) \u003d\u003d\u003d prevwid\n\tval ccheckmatch1\u003d(rdsp+Bits(1))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(1))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 rdscdataout(31,16) \u003d\u003d\u003d prevwid\n\tval ccheckmatch2\u003d(rdsp+Bits(2))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(2))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 rdscdataout(47,32) \u003d\u003d\u003d prevwid\n\tval ccheckmatch3\u003d(rdsp+Bits(3))\u003crdse+memaddrmod(2,1) \u0026\u0026 (rdsp+Bits(3))\u003e\u003drdss+memaddrmod(2,1) \u0026\u0026 rdscdataout(63,48) \u003d\u003d\u003d prevwid\n\tval conematched\u003d(ccheckmatch0 || ccheckmatch1) || (ccheckmatch2 || ccheckmatch3)\n\t\n\twhen(io.dfi.bits.valid){\n\t\twhen(io.dfi.bits.cmd\u003d\u003d\u003dM_XWR){\n\t\t\tsaddrbuf(saddrbuf_p(log2Up(bufsize)-1,0)) :\u003d io.dfi.bits.taraddr\n\t\t\tscyclebuf(saddrbuf_p(log2Up(bufsize)-1,0)) :\u003d io.dfi.bits.cycle\n\t\t\tsaddrbuf_p :\u003d saddrbuf_p + Bits(1)\n\t\t}\n\t\t.elsewhen(io.dfi.bits.cmd\u003d\u003d\u003dM_XRD){\n\t\t\tladdrbuf(laddrbuf_p(log2Up(bufsize)-1,0)) :\u003d io.dfi.bits.taraddr\n\t\t\tlcyclebuf(laddrbuf_p(log2Up(bufsize)-1,0)) :\u003d io.dfi.bits.cycle\n\t\t\tladdrbuf_p :\u003d laddrbuf_p + Bits(1)\n\t\t}.otherwise{}\n\t}.otherwise{}\n\n\t//this is for debug\n\twhen(cmd.fire()){\n\t\tstaraddrs(staraddrs_p(log2Up(bufsize)-1,0)) :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\tstaraddrs_p :\u003d staraddrs_p + Bits(1)\n\t\t\n\t\tltaraddrs(ltaraddrs_p(log2Up(bufsize)-1,0)) :\u003d laddrbuf(laddrbuf_p-Bits(1))\n\t\tltaraddrs_p :\u003d ltaraddrs_p + Bits(1)\n\t}.otherwise{}\n\t\n\tval taraddr_recorded\u003dReg(init \u003d Bool(false))\n\twhen(cmd.valid \u0026\u0026 cmd.ready){\n\t\twhen(!taraddr_recorded){\n\t\t\tstaraddr :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\tltaraddr :\u003d laddrbuf(laddrbuf_p-Bits(1))\n\t\t}\n\t\ttaraddr_recorded :\u003d Bool(false)\n\t}.elsewhen(cmd.valid \u0026\u0026 !cmd.ready){\n\t\twhen(!taraddr_recorded){\n\t\t\ttaraddr_recorded :\u003d Bool(true)\n\t\t\tstaraddr :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\tltaraddr :\u003d laddrbuf(laddrbuf_p-Bits(1))\n\t\t}\n\t}.otherwise{}\n\t\n\t//recieve func request\n\t//note that func req and st/ld req may come at the same cycle, accually it is func req is earlier than st/ld req, because the delay\n\t//funcmode 2, iscall 1, callremain 1, id 16, retpointer 64, arg0-2 64*3,\n\twhen(fifofuncmax \u003c fifofunccount){\n\t\tfifofuncmax :\u003d fifofunccount\n\t}.otherwise{}\n\t\n\twhen(fifofunc.io.enq.fire() \u0026\u0026 fifofunc.io.deq.fire()){\n\t}.elsewhen(fifofunc.io.enq.fire()){\n\t\tfifofunccount :\u003d fifofunccount + Bits(1)\n\t}.elsewhen(fifofunc.io.deq.fire()){\n\t\twhen(fifofunccount \u003e Bits(0)){\n\t\t\tfifofunccount :\u003d fifofunccount - Bits(1)\n\t\t}\n\t}.otherwise{}\n\n\twhen(fifofunc.io.enq.fire()){\n\t\tfifofuncpush_cycle :\u003d fifofuncpush_cycle + Bits(1)\n\t\tfifofuncenqvalid :\u003d Bool(false)\n\t\twaitinginfifofunc :\u003d Bool(false)\n\t\tbusyfunc :\u003d Bool(false)\n\t}.elsewhen(waitinginfifofunc){\n\t\tfifofuncpush_cycle :\u003d fifofuncpush_cycle + Bits(1)\n\t\tbusyfunc :\u003d Bool(true)\n\t}.otherwise{\n\t\tbusyfunc :\u003d Bool(false)\n\t}\n\t//receive func FIFO\n\twhen(fifofunc.io.deq.fire()){\n\t\tfifofuncbranchpop :\u003d fifofuncbranchpop + Bits(1)\n\t\tfifofuncdeqready :\u003d Bool(false)\n\t\twaitingcallfifo :\u003d Bool(false)\n\t\twhen(fifofunc.io.deq.bits(64*4+17) \u003d\u003d\u003d Bits(1)){//call\n\t\t\twhen((fifofunc.io.deq.bits(64*3-1,64*2) \u0026 UInt((1\u003c\u003caddrshift)-1)) \u003e UInt(0)){\n\t\t\t\ttotalfunccount(0) :\u003d (fifofunc.io.deq.bits(64*3-1,64*2)\u003e\u003eaddrshift)+UInt(1)\n\t\t\t}.otherwise{\n\t\t\t\ttotalfunccount(0) :\u003d (fifofunc.io.deq.bits(64*3-1,64*2)\u003e\u003eaddrshift)\n\t\t\t}\n\t\t\t\n\t\t\tid(1):\u003dfifofunc.io.deq.bits(64*4+16-1,64*4)\n\t\t\tfuncmode(1) :\u003d fifofunc.io.deq.bits(64*4+19,64*4+18)\n\t\t\tcallremain(1) :\u003d fifofunc.io.deq.bits(64*4+16)\n\t\t\tfunciscall(0) :\u003d Bool(true)\n\t\t\tfuncarg0(0) :\u003d fifofunc.io.deq.bits(64*1-1,0)\n\t\t\tfuncarg1(0) :\u003d fifofunc.io.deq.bits(64*2-1,64*1)\n\t\t\tfuncarg2(0) :\u003d fifofunc.io.deq.bits(64*3-1,64*2)\n\t\t\t//funcretaddr(0) :\u003d io.dfi.bits.funcretaddr\n\t\t\tfuncretpointer(0) :\u003d fifofunc.io.deq.bits(64*4-1,64*3) //return address\u0027s pointer\n\t\t\tbrremain(0) :\u003d Bool(true)\n\t\t\t\n\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 2.5 func FIFO OUT, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"function call, from FIFO, %x\\n\",fifofunc.io.deq.bits)\n\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 2.5\\n\")\n\t\t\tbrneedprocess(0) :\u003d Bool(true)\n\t\t}.otherwise{//ret\n\t\t\t\n\t\t\tfuncmode(1) :\u003d fifofunc.io.deq.bits(64*4+19,64*4+18)\n\t\t\tcallremain(1) :\u003d fifofunc.io.deq.bits(64*4+16)\n\t\t\tfunciscall(0) :\u003d Bool(false)\n\t\t\tfuncarg0(0) :\u003d UInt(0)\n\t\t\tfuncarg1(0) :\u003d UInt(0)\n\t\t\tfuncarg2(0) :\u003d UInt(0)\n\t\t\tfuncretpointer(0) :\u003d fifofunc.io.deq.bits(64*4-1,64*3) //return address\u0027s pointer\n\t\t\tbrremain(0) :\u003d Bool(true)\n\t\t\t\n\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 2.5 func FIFO OUT, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"function ret, from FIFO, %x\\n\",fifofunc.io.deq.bits)\n\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 2.5\\n\")\n\t\t\tbrneedprocess(0) :\u003d Bool(true)\n\t\t}\n\t}\n\t.otherwise{\n\t\twhen(state \u003d\u003d\u003d Bits(IDLE) \u0026\u0026 slneedprocess \u003d\u003d\u003d Bits(0) \u0026\u0026 !brneedprocess(0) \u0026\u0026 waitingcallfifo){\n\t\t\tfifofuncdeqready :\u003d Bool(true)\n\t\t}.otherwise{\n\t\t\tfifofuncdeqready :\u003d Bool(false)\n\t\t}\n\t\t/*\n\t\twhen(fifofuncdeqready \u0026\u0026 timeout\u003cUInt(maxtimeout)){\n\t\t\ttimeout :\u003d timeout + Bits(1)\n\t\t}.elsewhen(fifofuncdeqready \u0026\u0026 timeout\u003e\u003dUInt(maxtimeout)){\n\t\t\tfifofuncdeqready :\u003d Bool(false)\n\t\t\twaitingcallfifo :\u003d Bool(false)\n\t\t\tfifofuncloss :\u003d fifofuncloss + Bits(1)\n\t\t\tfifofunclatestlossinfo :\u003d fifofunclatestinfo\n\t\t\tfifofunclatestlosstaraddr :\u003d fifofunclatesttaraddr\n\t\t\tfifofunclatestlosscuscount :\u003d fifocuscount\n\t\t\tfifofunclatestlossfunccount :\u003d fifofunccount\n\t\t\tfifofunclatestlossrecord :\u003d (fifofuncdeqready\u003c\u003c28)|(fifofuncenqvalid\u003c\u003c27)|(fifocusdeqready\u003c\u003c26)|(fifocusenqvalid\u003c\u003c25)|(waitinginfifofunc\u003c\u003c24)|(waitinginfifocus\u003c\u003c23)|(stallfunc\u003c\u003c22)|(busystld\u003c\u003c21)|(brneedprocess(0)\u003c\u003c20)|(slneedprocess\u003c\u003c18)|(waitingcallfifo\u003c\u003c17)|(waitingcall\u003c\u003c16)|state\n\t\t\ttimeout :\u003d Bits(0)\n\t\t}.otherwise{\n\t\t\ttimeout :\u003d Bits(0)\n\t\t}*/\n\t}\n\t\n\t//receive st/ld request\n\twhen(fifocusmax \u003c fifocuscount){\n\t\tfifocusmax :\u003d fifocuscount\n\t}.otherwise{}\n\t\n\twhen(fifocustom.io.enq.fire() \u0026\u0026 fifocustom.io.deq.fire()){\n\t}.elsewhen(fifocustom.io.enq.fire()){\n\t\tfifocuscount :\u003d fifocuscount + Bits(1)\n\t}.elsewhen(fifocustom.io.deq.fire()){\n\t\twhen(fifocuscount \u003e Bits(0)){\n\t\t\tfifocuscount :\u003d fifocuscount - Bits(1)\n\t\t}\n\t}.otherwise{}\n\t\n\twhen(fifocustom.io.enq.fire()){\n\t\tfifocuspush_cycle :\u003d fifocuspush_cycle + Bits(1)\n\t\tfifocusenqvalid :\u003d Bool(false)\n\t\twaitinginfifocus :\u003d Bool(false)\n\t\tbusystld :\u003d Bool(false)\n\t}.elsewhen(waitinginfifocus){\n\t\tfifocuspush_cycle :\u003d fifocuspush_cycle + Bits(1)\n\t\tbusystld :\u003d Bool(true)\n\t}.otherwise{\n\t\tbusystld :\u003d Bool(false)\n\t}\n\twhen(cmd.fire()){\n\t\tfifocuspush_cycle :\u003d fifocuspush_cycle + Bits(1)\n\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\twhen(!SIMULATION){\n\t\t\t\t//addrrdt :\u003d Bits(0xe0400000L)\n\t\t\t\taddrrdt :\u003d Bits(0xf4084000L+0x400000L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\taddrrdt :\u003d staraddr//saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\tprintf(\"rdt: %x, (now cycle: %x)\\n\", staraddr,io.dfi.bits.cycle_now)//saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t}.otherwise{\n\t\t\t\t\taddrrdt :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\tprintf(\"rdt: %x, (now cycle: %x)\\n\", saddrbuf(saddrbuf_p-Bits(1)),io.dfi.bits.cycle_now)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\twhen(!SIMULATION){\n\t\t\t\t//addrrds :\u003d Bits(0xe4400000L)\n\t\t\t\taddrrds :\u003d Bits(0xf4084000L+0x4400000L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\taddrrds :\u003d staraddr//saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\tprintf(\"rds: %x\\n\", staraddr)//saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t}.otherwise{\n\t\t\t\t\taddrrds :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\tprintf(\"rds: %x\\n\", saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t}\n\t\t\t}\n\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\twhen(info(17) \u003d\u003d\u003d Bits(1)){\n\t\t\t\t\n\t\t\t}.elsewhen(info(18) \u003d\u003d\u003d Bits(1)){\n\t\t\t\tfifocusdatain :\u003d info\n\t\t\t\twaitinginfifocus :\u003d Bool(true)\n\t\t\t\tfifocusenqvalid :\u003d Bool(true)\n\t\t\t\tbusystld :\u003d Bool(true)\n\t\t\t}.otherwise{\n\t\t\t\twhen(!SIMULATION){\n\t\t\t\t\t//addrdebug :\u003d Bits(0xe0000000L)\n\t\t\t\t\taddrdebug :\u003d Bits(0xf4084000L)\n\t\t\t\t}.otherwise{\n\t\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\t\taddrdebug :\u003d staraddr//saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\t\tprintf(\"debug buffer: %x\\n\", staraddr)//saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\taddrdebug :\u003d saddrbuf(saddrbuf_p-Bits(1))\n\t\t\t\t\t\tprintf(\"debug buffer: %x\\n\", saddrbuf(saddrbuf_p-Bits(1)))\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfifocusdatain :\u003d info\n\t\t\t\twaitinginfifocus :\u003d Bool(true)\n\t\t\t\tfifocusenqvalid :\u003d Bool(true)\n\t\t\t\tbusystld :\u003d Bool(true)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 1 ld/st FIFO IN, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\t\tprintf(\"DFI request recieved\\n\")\n\t\t\t\tprintf(\"info: %x\\n\",info)\n\t\t\t\tprintf(\"thread pointer %x\\n\",io.dfi.bits.threadptr)\n\t\t\t\tprintf(\"%x/%x DFI process errors\\n\",errorcount,totalcount)\n\t\t\t\tprintf(\"return address: %x, stack address: %x, func arg0: %x, func arg1: %x, func arg2: %x\\n\",io.dfi.bits.funcretaddr,io.dfi.bits.funcstackaddr,io.dfi.bits.funcarg0,io.dfi.bits.funcarg1,io.dfi.bits.funcarg2)\n\t\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 1 \\n\")\n\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\tfifocusbranchpush :\u003d fifocusbranchpush + Bits(1)\n\t\t\t\t\tfifocusdatain :\u003d (((fifofuncdeqready\u003c\u003c28)|(fifofuncenqvalid\u003c\u003c27)|(fifocusdeqready\u003c\u003c26)|(fifocusenqvalid\u003c\u003c25)|(waitinginfifofunc\u003c\u003c24)|(waitinginfifocus\u003c\u003c23)|(stallfunc\u003c\u003c22)|(busystld\u003c\u003c21)|(brneedprocess(0)\u003c\u003c20)|(slneedprocess\u003c\u003c18)|(waitingcallfifo\u003c\u003c17)|(waitingcall\u003c\u003c16)|state)\u003c\u003c(22+8))|(fifocuscount\u003c\u003c22)|info\n\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){\n\t\t\t\t\t\tfifofuncbranchpush :\u003d fifofuncbranchpush + Bits(1)\n\t\t\t\t\t\tfifofuncdatain :\u003d (info(18,17)\u003c\u003c(64*4+18))|(Bits(1)\u003c\u003c(64*4+17))|(Mux(info(18,17) \u003e Bits(0),Bits(1),Bits(0))\u003c\u003c(64*4+16))|(info(15,0)\u003c\u003c(64*4))|((io.dfi.bits.funcstackaddr - UInt(8))\u003c\u003c(64*3))|(io.dfi.bits.funcarg2\u003c\u003c(64*2))|(io.dfi.bits.funcarg1\u003c\u003cUInt(64))|(io.dfi.bits.funcarg0)\n\t\t\t\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 1.5 func FIFO IN, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\t\t\t\tprintf(\"function call, to %x\\n\",io.dfi.bits.brtarget)\n\t\t\t\t\t\tprintf(\"return address: %x, stack address: %x, func arg0: %x, func arg1: %x, func arg2: %x\\n\",io.dfi.bits.funcretaddr,io.dfi.bits.funcstackaddr,io.dfi.bits.funcarg0,io.dfi.bits.funcarg1,io.dfi.bits.funcarg2)\n\t\t\t\t\t\tprintf(\"push to FIFO: %x\\n\",(info(18,17)\u003c\u003c(64*4+18))|(Bits(1)\u003c\u003c(64*4+17))|(Mux(info(18,17) \u003e Bits(0),Bits(1),Bits(0))\u003c\u003c(64*4+16))|(info(15,0)\u003c\u003c(64*4))|((io.dfi.bits.funcstackaddr - UInt(8))\u003c\u003c(64*3))|(io.dfi.bits.funcarg2\u003c\u003c(64*2))|(io.dfi.bits.funcarg1\u003c\u003cUInt(64))|(io.dfi.bits.funcarg0))\n\t\t\t\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 1.5\\n\")\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tfifofuncbranchpush :\u003d fifofuncbranchpush + Bits(1)\n\t\t\t\t\t\tfifofuncdatain :\u003d (info(18,17)\u003c\u003c(64*4+18))|(Bits(0)\u003c\u003c(64*4+17))|(Mux(info(18,17) \u003e Bits(0),Bits(1),Bits(0))\u003c\u003c(64*4+16))|(info(15,0)\u003c\u003c(64*4))|((io.dfi.bits.funcstackaddr - UInt(8))\u003c\u003c(64*3))\n\t\t\t\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 1.5 func FIFO IN, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\t\t\t\tprintf(\"function return, to %x\\n\",io.dfi.bits.brtarget)\n\t\t\t\t\t\tprintf(\"return address: %x, stack address: %x, func arg0: %x, func arg1: %x, func arg2: %x\\n\",io.dfi.bits.funcretaddr,io.dfi.bits.funcstackaddr,io.dfi.bits.funcarg0,io.dfi.bits.funcarg1,io.dfi.bits.funcarg2)\n\t\t\t\t\t\tprintf(\"push to FIFO: %x\\n\",(info(18,17)\u003c\u003c(64*4+18))|(Bits(0)\u003c\u003c(64*4+17))|(Mux(info(18,17) \u003e Bits(0),Bits(1),Bits(0))\u003c\u003c(64*4+16))|(info(15,0)\u003c\u003c(64*4))|((io.dfi.bits.funcstackaddr - UInt(8))\u003c\u003c(64*3)))\n\t\t\t\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 1.5\\n\")\n\t\t\t\t\t}\n\t\t\t\t\twaitinginfifofunc :\u003d Bool(true)\n\t\t\t\t\tfifofuncenqvalid :\u003d Bool(true)\n\t\t\t\t\tbusyfunc :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0) \u0026\u0026 info(18,17) \u003e Bits(0) \u0026\u0026 maxliblen\u003c(io.dfi.bits.funcarg2\u003e\u003eaddrshift)){\n\t\t\t\t\t\tmaxlibarg0 :\u003d io.dfi.bits.funcarg0\n\t\t\t\t\t\tmaxlibarg1 :\u003d io.dfi.bits.funcarg1\n\t\t\t\t\t\tmaxlibarg2 :\u003d io.dfi.bits.funcarg2\n\t\t\t\t\t\tmaxlibarg3 :\u003d io.dfi.bits.funcarg3\n\t\t\t\t\t\tmaxlibarg4 :\u003d io.dfi.bits.funcarg4\n\t\t\t\t\t\tmaxlibarg5 :\u003d info\n\t\t\t\t\t\tmaxlibretaddr :\u003d io.dfi.bits.funcretaddr\n\t\t\t\t\t\tmaxlibretptr :\u003d io.dfi.bits.funcstackaddr\n\t\t\t\t\t\tmaxliblen :\u003d io.dfi.bits.funcarg2\u003e\u003eaddrshift\n\t\t\t\t\t}.otherwise{}\n\t\t\t\t\t\n\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\t\tfifocusdatain :\u003d (staraddr\u003c\u003c22)|info\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tfifocusdatain :\u003d (saddrbuf(saddrbuf_p-Bits(1))\u003c\u003c22)|info\n\t\t\t\t\t}\n\t\t\t\t}.otherwise{//ld\n\t\t\t\t\twhen(taraddr_recorded){\n\t\t\t\t\t\tfifocusdatain :\u003d (ltaraddr\u003c\u003c22)|info\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tfifocusdatain :\u003d (laddrbuf(laddrbuf_p-Bits(1))\u003c\u003c22)|info\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twaitinginfifocus :\u003d Bool(true)\n\t\t\t\tfifocusenqvalid :\u003d Bool(true)\n\t\t\t\tbusystld :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\t//receive st/ld FIFO\n\twhen(fifocustom.io.deq.fire()){\n\t\tfifocusdeqready :\u003d Bool(false)\n\t\twhen(fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t}.elsewhen(fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t}.elsewhen(fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 2 FUNC FIFO OUT, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"info: %x\\n\",fifocustom.io.deq.bits)\n\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 2\\n\")\n\t\t\twhen(fifocustom.io.deq.bits(18)){\n\t\t\t\tinfor :\u003d fifocustom.io.deq.bits\n\t\t\t\tslneedprocess :\u003d Bits(2)\n\t\t\t}.otherwise{\n\t\t\t\tinfor :\u003d fifocustom.io.deq.bits\n\t\t\t\trdsmapcwaddr :\u003d Bits(0)//ready to reset rdsmapcache\n\t\t\t\trdsmapcdatain :\u003d Bits(0)\n\t\t\t\trdtcwaddr :\u003d Bits(0)\n\t\t\t\trdtcdatain :\u003d Bits(0)\n\t\t\t\trdscwaddr :\u003d Bits(0)\n\t\t\t\trdscdatain :\u003d Bits(0)\n\t\t\t\tfifocusbranchpush :\u003d Bits(0)\n\t\t\t\tfifocusbranchpop :\u003d Bits(0)\n\t\t\t\tfifofuncbranchpush :\u003d Bits(0)\n\t\t\t\tfifofuncbranchpop :\u003d Bits(0)\n\t\t\t\tfifofuncloss :\u003d Bits(0)\n\t\t\t\tfifocusmax :\u003d Bits(0)\n\t\t\t\tfifofuncmax :\u003d Bits(0)\n\t\t\t\tstop_call_count :\u003d Bits(0)\n\t\t\t\t\n\t\t\t\tslneedprocess :\u003d Bits(2)\n\t\t\t\t\n\t\t\t\twhen(fifocustom.io.deq.bits(19) \u003d\u003d\u003d UInt(1)){//debug\n\t\t\t\t\tprintf(\"WRTIE LOAD TRACE\\n\")\n\t\t\t\t\tldstate :\u003d Bits(WRITELDTRACE)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tldstate :\u003d Bits(READRDSMAP)\n\t\t\t\t}\n\t\t\t\trdtreaddebug_p :\u003d Bits(0)\n\t\t\t}\n\t\t}.elsewhen(fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\tprintf(\"\u003e\u003e\u003e\u003e\u003e 2 FUNC FIFO OUT, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"info: %x\\n\",fifocustom.io.deq.bits)\n\t\t\tprintf(\"\u003c\u003c\u003c\u003c\u003c 2\\n\")\n\t\t\tinfor :\u003d fifocustom.io.deq.bits\n\t\t\twhen(fifocustom.io.deq.bits(19,17) \u003e UInt(0)){\n\t\t\t\tfifocusbranchpop :\u003d fifocusbranchpop + Bits(1)\n\t\t\t\twaitingcallfifo :\u003d Bool(true)\n\t\t\t\tfifofunclatestinfo :\u003d fifocustom.io.deq.bits(21,0)\n\t\t\t\tfifofunclatesttaraddr :\u003d fifocustom.io.deq.bits(22+64-1,22)\n\t\t\t}.elsewhen(fifocustom.io.deq.bits(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\ttaraddr(0) :\u003d fifocustom.io.deq.bits(64+22-1,22)\n\t\t\t\tslneedprocess :\u003d Bits(2)\n\t\t\t}.otherwise{//ld\n\t\t\t\ttaraddr(0) :\u003d fifocustom.io.deq.bits(64+22-1,22)\n\t\t\t\tslneedprocess :\u003d Bits(2)\n\t\t\t}\n\t\t}\n\t\t.otherwise{}\n\t}\n\t.otherwise{\n\t\twhen(state \u003d\u003d\u003d Bits(IDLE) \u0026\u0026 slneedprocess \u003d\u003d\u003d Bits(0) \u0026\u0026 !brneedprocess(0) \u0026\u0026 !waitingcallfifo){\n\t\t\tfifocusdeqready :\u003d Bool(true)\n\t\t}.otherwise{\n\t\t\tfifocusdeqready :\u003d Bool(false)\n\t\t}\n\t}\n\t/*\n\t//lat check\n\t//1st lat check----------call\n\twhen(lat_call_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t\twhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//normal call\n\t\t\t\t\t\t\t\tlat_cate :\u003d Bits(0)\n\t\t\t\t\t\t\t\tlat_call_count :\u003d lat_call_count + Bits(1)\n\t\t\t\t\t\t\t\tlat_call_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_call_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_call_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_call_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_call_cycles :\u003d lat_call_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_call_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_call_fifo_red :\u003d lat_call_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_call_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_call_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_call_cycles :\u003d lat_call_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_call_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_call_fifo_red :\u003d lat_call_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_call_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_call_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_call_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_call_cycles :\u003d lat_call_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_call_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_call_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//2nd lat check----------libst\n\twhen(lat_libst_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t\twhen(info(17)\u003d\u003d\u003dUInt(1) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//write\n\t\t\t\t\t\t\t\tlat_cate :\u003d Bits(1)\n\t\t\t\t\t\t\t\tlat_libst_count :\u003d lat_libst_count + Bits(1)\n\t\t\t\t\t\t\t\tlat_libst_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_libst_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_libst_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libst_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libst_cycles :\u003d lat_libst_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libst_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libst_fifo_red :\u003d lat_libst_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_libst_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_libst_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libst_cycles :\u003d lat_libst_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libst_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libst_fifo_red :\u003d lat_libst_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_libst_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_libst_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libst_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libst_cycles :\u003d lat_libst_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_libst_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_libst_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//3rd lat check----------libld\n\twhen(lat_libld_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t\twhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//normal call\n\t\t\t\t\t\t\t}.elsewhen(info(17)\u003d\u003d\u003dUInt(1) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//write\n\t\t\t\t\t\t\t}.elsewhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(1)){//read\n\t\t\t\t\t\t\t\tlat_cate :\u003d Bits(2)\n\t\t\t\t\t\t\t\tlat_libld_count :\u003d lat_libld_count + Bits(1)\n\t\t\t\t\t\t\t\tlat_libld_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_libld_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_libld_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libld_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libld_cycles :\u003d lat_libld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libld_fifo_red :\u003d lat_libld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_libld_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_libld_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libld_cycles :\u003d lat_libld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libld_fifo_red :\u003d lat_libld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_libld_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_libld_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libld_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libld_cycles :\u003d lat_libld_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_libld_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_libld_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//4th lat check----------libstld\n\twhen(lat_libstld_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t\twhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//normal call\n\t\t\t\t\t\t\t}.elsewhen(info(17)\u003d\u003d\u003dUInt(1) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(0)){//write\n\t\t\t\t\t\t\t}.elsewhen(info(17)\u003d\u003d\u003dUInt(0) \u0026\u0026 info(18)\u003d\u003d\u003dUInt(1)){//read\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_cate :\u003d Bits(3)\n\t\t\t\t\t\t\t\tlat_libstld_count :\u003d lat_libstld_count + Bits(1)\n\t\t\t\t\t\t\t\tlat_libstld_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_libstld_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_libstld_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libstld_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libstld_cycles :\u003d lat_libstld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libstld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libstld_fifo_red :\u003d lat_libstld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_libstld_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_libstld_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libstld_cycles :\u003d lat_libstld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_libstld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_libstld_fifo_red :\u003d lat_libstld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_libstld_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_libstld_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_libstld_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_libstld_cycles :\u003d lat_libstld_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_libstld_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_libstld_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//5th lat check----------ret\n\twhen(lat_ret_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t\twhen(info(16) \u003d\u003d\u003d Bits(0)){//call\n\t\t\t\t\t\t}.otherwise{//ret\n\t\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\t\tlat_ret_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\t\tlat_ret_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlat_cate :\u003d Bits(4)\n\t\t\t\t\t\t\tlat_ret_count :\u003d lat_ret_count + Bits(1)\n\t\t\t\t\t\t\tlat_ret_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t\t}\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_ret_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ret_cycles :\u003d lat_ret_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_ret_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_ret_fifo_red :\u003d lat_ret_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_ret_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_ret_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ret_cycles :\u003d lat_ret_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_ret_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_ret_fifo_red :\u003d lat_ret_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_ret_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_ret_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_ret_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ret_cycles :\u003d lat_ret_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_ret_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_ret_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//6th lat check----------st\n\twhen(lat_st_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\tlat_st_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\tlat_st_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlat_cate :\u003d Bits(5)\n\t\t\t\t\t\tlat_st_count :\u003d lat_st_count + Bits(1)\n\t\t\t\t\t\tlat_st_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_st_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_st_cycles :\u003d lat_st_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_st_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_st_fifo_red :\u003d lat_st_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_st_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_st_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_st_cycles :\u003d lat_st_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_st_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_st_fifo_red :\u003d lat_st_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_st_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_st_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_st_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_st_cycles :\u003d lat_st_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_st_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_st_state :\u003d Bits(LAT_IDLE)\n\t}\n\t//7th lat check----------ld\n\twhen(lat_ld_state\u003d\u003d\u003dBits(LAT_IDLE)){\n\t\twhen(cmd.fire()){\n\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(1)){\n\t\t\t\t//addrrdt :\u003d Bits(0x200074e010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(2)){\n\t\t\t\t//addrrds :\u003d Bits(0x200474f010L)\n\t\t\t}.elsewhen(info(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\t//addrdebug :\u003d Bits(0x200034d010L)\n\t\t\t}.otherwise{\n\t\t\t\twhen(info(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\t\t\t\twhen(info(19,17) \u003e UInt(0)){\n\t\t\t\t\t}.elsewhen(info(16) \u003d\u003d\u003d UInt(0)){\n\t\t\t\t\t\t//store\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t//ld\n\t\t\t\t\t\twhen(!fifocustom.io.deq.fire()){\n\t\t\t\t\t\t\tlat_ld_fifo_red :\u003d fifocuscount + Bits(1)\n\t\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\tlat_ld_fifo_red :\u003d fifocuscount\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlat_cate :\u003d Bits(6)\n\t\t\t\t\t\tlat_ld_count :\u003d lat_ld_count + Bits(1)\n\t\t\t\t\t\tlat_ld_state :\u003d Bits(LAT_WAIT_ENQ)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_ld_state\u003d\u003d\u003dBits(LAT_WAIT_ENQ)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ld_cycles :\u003d lat_ld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_ld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_ld_fifo_red :\u003d lat_ld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(fifocustom.io.enq.fire()){\n\t\t\tlat_ld_state :\u003d Bits(LAT_WAIT_POP)\n\t\t}\n\t}.elsewhen(lat_ld_state\u003d\u003d\u003dBits(LAT_WAIT_POP)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ld_cycles :\u003d lat_ld_cycles + Bits(1)\n\t\t}\n\t\twhen(lat_ld_fifo_red\u003eBits(0) \u0026\u0026 fifocustom.io.deq.fire()){\n\t\t\tlat_ld_fifo_red :\u003d lat_ld_fifo_red - Bits(1)\n\t\t}\n\t\twhen(lat_ld_fifo_red\u003d\u003d\u003dBits(0)){\n\t\t\twhen(state\u003d\u003d\u003dBits(IDLE) \u0026\u0026 (slneedprocess \u003d\u003d\u003d Bits(2) || brneedprocess(0))){\n\t\t\t\tlat_ld_state :\u003d Bits(LAT_WAIT_END)\n\t\t\t}\n\t\t}.otherwise{}\n\t}.elsewhen(lat_ld_state\u003d\u003d\u003dBits(LAT_WAIT_END)){\n\t\twhen(!io.corestalled){\n\t\t\tlat_ld_cycles :\u003d lat_ld_cycles + Bits(1)\n\t\t}\n\t\twhen(state\u003d\u003d\u003dBits(IDLE)){\n\t\t\tlat_ld_state :\u003d Bits(LAT_IDLE)\n\t\t}\n\t}.otherwise{\n\t\tlat_ld_state :\u003d Bits(LAT_IDLE)\n\t}\n\t*/\n\t//ldopt\n\twhen(fifofunc.io.deq.fire()){\n\t\tldopt_rst :\u003d Bool(true)\n\t\tldopt_red :\u003d Bool(false)\n\t}.elsewhen(fifocustom.io.deq.fire() \u0026\u0026 fifocustom.io.deq.bits(21,20) \u003d/\u003d UInt(0)){\n\t\tldopt_rst :\u003d Bool(true)\n\t\tldopt_red :\u003d Bool(false)\n\t}.elsewhen(fifocustom.io.deq.fire() \u0026\u0026 fifocustom.io.deq.bits(21,20) \u003d\u003d\u003d UInt(0) \u0026\u0026 addrrdt \u003d/\u003d Bits(0) \u0026\u0026 addrrds \u003d/\u003d Bits(0) \u0026\u0026 addrdebug \u003d/\u003d Bits(0)){\n\t\tldopt_rst :\u003d Bool(false)\n\t\tldopt_rw :\u003d fifocustom.io.deq.bits(16)\n\t\tldopt_id :\u003d fifocustom.io.deq.bits(15,0)\n\t\twhen(fifocustom.io.deq.bits(16)\u003d\u003d\u003dBits(0)){\n\t\t\tldopt_taraddr :\u003d fifocustom.io.deq.bits(64+22-1,22)\n\t\t}.otherwise{\n\t\t\tldopt_taraddr :\u003d fifocustom.io.deq.bits(64+22-1,22)\n\t\t}\n\t\tldopt_red :\u003d Bool(false)\n\t}.otherwise{\n\t\twhen(ldoptbuf.io.red \u0026\u0026 ldopt_id \u003d/\u003d Bits(0)){\n\t\t\tldopt_red :\u003d Bool(true)\n\t\t\tprintf(\"!!!!!!!! redundant ld\\n\")\n\t\t}\n\t\tldopt_rst :\u003d Bool(false)\n\t\tldopt_rw :\u003d Bits(0)\n\t\tldopt_id :\u003d Bits(0)\n\t\tldopt_taraddr :\u003d Bits(0)\n\t}\n\t\n\twhen(cmd.fire() \u0026\u0026 info(21,20) \u003d\u003d\u003d UInt(3) \u0026\u0026 info(18) \u003d/\u003d Bits(1)){\n\t\ttotal_cycle :\u003d Bits(0)\n\t}.otherwise{\n\t\ttotal_cycle :\u003d total_cycle + Bits(1)\n\t}\n\t\n\twhen(cmd.fire() \u0026\u0026 info(21,20) \u003d\u003d\u003d UInt(3) \u0026\u0026 info(18) \u003d/\u003d Bits(1)){\n\t\tidle_cycle :\u003d Bits(0)\n\t}.elsewhen(state \u003d\u003d\u003d Bits(IDLE)){\n\t\tidle_cycle :\u003d idle_cycle + Bits(1)\n\t}.otherwise{}\n\t\n\twhen(shdstkaddr\u003eshdstackmax){\n\t\tshdstackmax :\u003d shdstkaddr\n\t}.otherwise{}\n\t\n\t//stop the program\n\twhen(cmd.fire() \u0026\u0026 info(21,20) \u003d\u003d\u003d UInt(3) \u0026\u0026 info(17) \u003d\u003d\u003d UInt(1)){\n\t\tprintf(\"CALL COUNT SIGNAL\\n\")\n\t\twhen(stop_call_count_max \u003e Bits(0)){\n\t\t\tprintf(\"current stop count: %x\\n\",stop_call_count)\n\t\t\tstop_call_count :\u003d stop_call_count + Bits(1)\n\t\t\tstop_call_count_all :\u003d stop_call_count_all + Bits(1)\n\t\t}\n\t}\n\t/*\n\twhen(io.dfi.bits.callvalid \u0026\u0026 (!stop_repcall || stop_brtarget \u003d/\u003d io.dfi.bits.brtarget)){\n\t\tstop_repcall :\u003d Bool(true)\n\t\tstop_brtarget :\u003d io.dfi.bits.brtarget\n\t\twhen(stop_call_count_max \u003e Bits(0)){\n\t\t\tstop_call_count :\u003d stop_call_count + Bits(1)\n\t\t\tstop_call_count_all :\u003d stop_call_count_all + Bits(1)\n\t\t}\n\t}.elsewhen(io.dfi.bits.retvalid \u0026\u0026 (!stop_repcall || stop_brtarget \u003d/\u003d io.dfi.bits.brtarget)){\n\t\tstop_repcall :\u003d Bool(false)\n\t\tstop_brtarget :\u003d io.dfi.bits.brtarget\n\t}.elsewhen(!io.dfi.bits.callvalid \u0026\u0026 !io.dfi.bits.retvalid){\n\t\tstop_repcall :\u003d Bool(true)\n\t}.otherwise{}\n\t*/\n\twhen(stop_call_count_max \u003e Bits(0) \u0026\u0026 stop_call_count \u003e\u003d stop_call_count_max){\n\t\tstop_call_count_max :\u003d Bits(0)\n\t\tstop_call_count :\u003d Bits(0)\n\t\tprintf(\"EXCEPTION!!!\\n\")\n\t\tstop_coreexception :\u003d Bool(true)\n\t}\n\t.elsewhen(stop_coreexception){\n\t\tprintf(\"WAIT FOR NEXT CUSTOM TO STOP\\n\")\n\t\twhen(io.canexception){\n\t\t\tstop_coreexception :\u003d Bool(false)\n\t\t}.otherwise{}\n\t}\n\t/*.elsewhen(stop_coreexception \u0026\u0026 stop_call_count_keep \u003c Bits(5)){\n\t\tstop_call_count_keep :\u003d stop_call_count_keep + Bits(1)\n\t}*/\n\t.otherwise{\n\t\tstop_call_count_keep :\u003d Bits(0)\n\t\tstop_coreexception :\u003d Bool(false)\n\t}\n\t\n\t//++++++++++++++++++++++FSM++++++++++++++++++\n\twhen(state \u003d\u003d\u003d Bits(IDLE)){\n\t\tstallfunc :\u003d Bool(false)\n\t\tmemtag :\u003d Bits(0)\n\t\tmemtype :\u003d Bits(3)\n\t\tcount :\u003d Bits(0)\n\t\tmemvalid :\u003d Bool(false)\n\t\tmemw :\u003d Bool(false)\n\t\tnstate :\u003d Bits(IDLE)\n\t\tpstate :\u003d Bits(IDLE)\n\t\tmatched :\u003d Bool(true)\n\t\twaitresp :\u003d Bool(false)\n\t\twhen(~matched){\n\t\t\tviolations :\u003d violations + Bits(1)\n\t\t\tprintf(\"IDLESTATE: violation\\n\");\n\t\t}.otherwise{}\n\t\twhen(haserror){\n\t\t\terrorcount :\u003d errorcount + Bits(1)\n\t\t\thaserror :\u003d Bool(false)\n\t\t}\n\t\t\n\t\twhen(brneedprocess(0)){//need to process a function call\n\t\t\tbrneedprocess(0) :\u003d Bool(false)\n\t\t\tbrneedprocess(1) :\u003d brneedprocess(0)\n\t\t\t\n\t\t\ttotalcount :\u003d totalcount + Bits(1)\n\t\t\ttotalcallcount :\u003d totalcallcount + Bits(1)\n\t\t\tprintf(\"---------------DFI process begin --------FUNC, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"normal function call/ret? %x, is call? %x, is lib? %x, mode: %x\\n\",brremain(0),funciscall(0),callremain(1),funcmode(1))\n\t\t\tprintf(\"return address pointer: %x arg0: %x, arg1: %x, arg2: %x\\n\",funcretpointer(0),funcarg0(0),funcarg1(0),funcarg2(0))\n\t\t\tprintf(\"custom inst fire? %x\\n\",cmd.fire())\n\t\t\tprintf(\"%x/%x DFI process errors\\n\",errorcount,totalcount)\n\t\t\t\n\t\t\tid(2):\u003did(1)\n\t\t\tfunccount :\u003d totalfunccount(0)\n\t\t\ttotalfunccount(1) :\u003d totalfunccount(0)\n\t\t\tfuncmode(2) :\u003d funcmode(1)\n\t\t\tcallremain(2) :\u003d callremain(1)\n\t\t\tfunciscall(1) :\u003d funciscall(0)\n\t\t\tbrtarget(1) :\u003d brtarget(0)\n\t\t\tfuncarg0(1) :\u003d funcarg0(0)\n\t\t\tfuncarg1(1) :\u003d funcarg1(0)\n\t\t\tfuncarg2(1) :\u003d funcarg2(0)\n\t\t\tfuncretaddr(1) :\u003d funcretaddr(0)\n\t\t\tfuncretpointer(1) :\u003d funcretpointer(0)\n\t\t\tbrremain(1) :\u003d brremain(0)\n\t\t\t\n\t\t\twhen(brremain(0)){\n\t\t\t\twhen(funciscall(0)){\n\t\t\t\t\twhen(funcmode(1) \u003e\u003d Bits(2)){\n\t\t\t\t\t\t//stallfunc :\u003d Bool(true)\n\t\t\t\t\t}\n\t\t\t\t\t/*\n\t\t\t\t\tshdstkaddr :\u003d shdstkaddr + Bits(1)\n\t\t\t\t\twhen(shdstkcount \u003c shdstacksize){\n\t\t\t\t\t\tshdstkaddr :\u003d shdstkcount\n\t\t\t\t\t\tshdstkcount :\u003d shdstkcount + Bits(1)\n\t\t\t\t\t\tsdhstkdatain :\u003d \n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\t\n\t\t\t\t\t}*/\n\t\t\t\t\tval rdtentry \u003d (((funcretpointer(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\n\t\t\t\t\tmemaddr :\u003d addrrdt+(((funcretpointer(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\tmemdatain :\u003d Bits(0xffff)\n\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdtentry \u003d (((funcretpointer(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\trdtcprobing :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\tval realaddr \u003d addrrdt+(((funcretpointer(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(READRDT)//skip READRDSMAP because no need\n\t\t\t\t}\n\t\t\t}.otherwise{}\n\t\t}.otherwise{}\n\t\t\n\t\twhen(!brneedprocess(0) \u0026\u0026 slneedprocess \u003d\u003d\u003d Bits(2)){\n\t\t\tprintf(\"---------------DFI process begin, @%x\\n\",io.dfi.bits.cycle_now)\n\t\t\tprintf(\"info: %x\\n\",infor)\n\t\t\tbrneedprocess(1) :\u003d Bool(false)\n\t\t\ttotalcount :\u003d totalcount + Bits(1)\n\t\t\t/*\n\t\t\tprintf(\"sbuf_p %d +++\\n\", saddrbuf_p(log2Up(bufsize)-1,0))\n\t\t\tfor (i\u003c- 0 to bufsize-1)\n\t\t\tprintf(\"sbuf %d value: %x, cycle %x\\n\", UInt(i), saddrbuf(UInt(i)), scyclebuf(UInt(i)))\n\t\t\t\n\t\t\tprintf(\"lbuf_p %d +++\\n\", laddrbuf_p(log2Up(bufsize)-1,0))\n\t\t\tfor (i\u003c- 0 to bufsize-1)\n\t\t\tprintf(\"lbuf %d value: %x, cycle %x\\n\", UInt(i), laddrbuf(UInt(i)), lcyclebuf(UInt(i)))\n\t\t\t*/\n\t\t\tslneedprocess :\u003d Bits(0)\n\t\t\tcount :\u003d Bits(0)\n\t\t\trw :\u003d infor(16)\n\t\t\tid(2) :\u003d infor(15,0)\n\t\t\tinfo_debug :\u003d infor\n\t\t\twhen(infor(21,20) \u003d\u003d\u003d UInt(3)){\n\t\t\t\twhen(infor(18)){\n\t\t\t\t\tprintf(\"write report ---\\n\")\n\t\t\t\t\tcount :\u003d Bits(0)\n\t\t\t\t\tstate :\u003d Bits(REPORT)\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tprintf(\"reset rdsmap cache ---\\n\")\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t\tstate :\u003d Bits(CACHERESET)\n\t\t\t\t}\n\t\t\t}.elsewhen(infor(19,17) \u003e UInt(0)){\n\t\t\t\t\n\t\t\t}.elsewhen(infor(16) \u003d\u003d\u003d UInt(0)){//store\n\t\t\t\ttotalstcount :\u003d totalstcount + Bits(1)\n\t\t\t\tval rdtentry \u003d (((taraddr(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\n\t\t\t\tmemaddr :\u003d addrrdt+(((taraddr(0)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\tmemdatain :\u003d infor(15,0)\n\t\t\t\t\n\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\ttaraddr(1) :\u003d taraddr(0)\n\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t}.otherwise{//load\n\t\t\t\ttotalldcount :\u003d totalldcount + Bits(1)\n\t\t\t\twhen((ldopt_red || (ldoptbuf.io.red \u0026\u0026 ldopt_id \u003d/\u003d Bits(0)))){\n\t\t\t\t\ttotalldopt :\u003d totalldopt + Bits(1)\n\t\t\t\t\tprintf(\"LD redundant\\n\")\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t}.otherwise{\n\t\t\t\t\ttotalldnoopt :\u003d totalldnoopt + Bits(1)\n\t\t\t\t\twhen(ldstate \u003d\u003d\u003d Bits(READRDSMAP)){\n\t\t\t\t\t\tval rdsmapentry \u003d infor(15,0)\n\t\t\t\t\t\trdsmapcraddr :\u003d rdsmapentry\u0026rdsmapcacheaddrmask\n\t\t\t\t\t\trdsmapcprobing :\u003d Bool(true)\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrds+(infor(15,0)\u003c\u003c3)\n\t\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t//memvalid :\u003d Bool(true)\n\t\t\t\t\t\t\n\t\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t\t\ttaraddr(1) :\u003d taraddr(0)\n\t\t\t\t\t\tstate :\u003d Bits(READRDSMAP)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\t\tcallremain(2) :\u003d Bool(false)\n\t\t\t\t\t\ttaraddr(1) :\u003d taraddr(0)\n\t\t\t\t\t\tstate :\u003d Bits(WRITELDTRACE)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.otherwise{}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(CACHERESET)){\n\t\twhen(rdsmapcwaddr\u003cBits((1\u003c\u003crdsmapcacheaddrwidth)-1)){\n\t\t\trdsmapcwaddr :\u003d rdsmapcwaddr + Bits(1)\n\t\t\trdsmapcdatain :\u003d Bits(0)\n\t\t}.otherwise{}\n\t\twhen(rdtcwaddr\u003cBits((1\u003c\u003crdtcacheaddrwidth)-1)){\n\t\t\trdtcwaddr :\u003d rdtcwaddr + Bits(1)\n\t\t\trdtcdatain :\u003d Bits(0)\n\t\t}.otherwise{}\n\t\twhen(rdscwaddr\u003cBits((1\u003c\u003crdscacheaddrwidth)-1)){\n\t\t\trdscwaddr :\u003d rdscwaddr + Bits(1)\n\t\t\trdscdatain :\u003d Bits(0)\n\t\t}.otherwise{}\n\t\twhen(rdsmapcwaddr \u003d\u003d\u003d Bits((1\u003c\u003crdsmapcacheaddrwidth)-1) \u0026\u0026 rdtcwaddr \u003d\u003d\u003d Bits((1\u003c\u003crdtcacheaddrwidth)-1) \u0026\u0026 rdscwaddr \u003d\u003d\u003d Bits((1\u003c\u003crdscacheaddrwidth)-1)){\n\t\t\tprintf(\"cache reset done\\n\")\n\t\t\t//state :\u003d Bits(IDLE)\n\t\t\tmemaddr :\u003d addrdebug\n\t\t\tmemw :\u003d Bool(false)\n\t\t\tmemtype :\u003d Bits(3)\n\t\t\tmemtag :\u003d Bits(2)\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\tstate :\u003d Bits(READSTOPCOND)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}.otherwise{}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(READSTOPCOND)){\n\t\twhen(io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)){\n\t\t\tstop_call_count_max :\u003d io.mem.resp.bits.data\n\t\t\tprintf(\"stop condition (call) is: %x\\n\",io.mem.resp.bits.data)\n\t\t\tstate :\u003d Bits(IDLE)\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(WAIT)){\n\t\twhen(io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)){\n\t\t\tstate :\u003d nstate\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(WRITERDT)){\n\t\tuprdt_cycle :\u003d uprdt_cycle + Bits(1)\n\t\twhen(!waitresp){\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\tval cachehit \u003d rdtcdataout \u003d/\u003d Bits(0) \u0026\u0026 (rdtcdataout\u003e\u003e64) \u003d\u003d\u003d ((memaddr-addrrdt)\u003e\u003e3)\u003e\u003erdtcacheaddrwidth\n\t\t\t\twhen(cachehit){\n\t\t\t\t\trdtcwaddr :\u003d rdtcraddr\n\t\t\t\t\trdtcdatain :\u003d (rdtcdataout\u0026(~(Bits(0xffff)\u003c\u003c(memaddr(2,1)\u003c\u003c4))))|((memdatain\u0026Bits(0xffff))\u003c\u003c(memaddr(2,1)\u003c\u003c4))\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twaitresp :\u003d Bool(true)\n\t\t\t\tprintf(\"w addr: %x, data: %x, id: %x, RDT entry: %x\\n\",memaddr,memdatain,id(2),(memaddr-addrrdt)\u003e\u003e1)\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)){\n\t\t\t\topst_count :\u003d opst_count + Bits(1)\n\t\t\t\twaitresp :\u003d Bool(false)\n\t\t\t\twhen(brremain(1) \u0026\u0026 funciscall(1)){\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\twhen(callremain(2)){\n\t\t\t\t\t\twhen(funccount \u003d\u003d\u003d Bits(0) || funccount \u003e\u003d Bits(0xf0000000L)){\n\t\t\t\t\t\t\ttotalcallexceptioncount :\u003d totalcallexceptioncount + Bits(1)\n\t\t\t\t\t\t\tprintf(\"WARNING, lib func length incorrect\\n\")\n\t\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t}.elsewhen(funcmode(2) \u003d\u003d\u003d Bits(2) || funcmode(2) \u003d\u003d\u003d Bits(3)){\n\t\t\t\t\t\t\tval rdsmapentry \u003d id(2)\n\t\t\t\t\t\t\trdsmapcraddr :\u003d rdsmapentry\u0026rdsmapcacheaddrmask\n\t\t\t\t\t\t\trdsmapcprobing :\u003d Bool(true)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmemaddr :\u003d addrrds+(id(2)\u003c\u003c3)\n\t\t\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t\t//memvalid :\u003d Bool(true)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstate :\u003d Bits(READRDSMAP)\n\t\t\t\t\t\t}.elsewhen(funcmode(2) \u003d\u003d\u003d Bits(1)){\n\t\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\t}.otherwise{}\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.elsewhen(!callremain(2)){\n\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t}.elsewhen(callremain(2) \u0026\u0026 funccount \u003c\u003d Bits(1)){\n\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+funccount-Bits(2))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\n\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+funccount-Bits(2))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\tfunccount :\u003d funccount - Bits(1)\n\t\t\t\t}\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(READRDSMAP)){\n\t\trdrdsmap_cycle :\u003d rdrdsmap_cycle + Bits(1)\n\t\trdsid :\u003d Bits(0)\n\t\tmatched :\u003d Bool(false)\n\t\twhen(waitresp || rdsmapcprobing){\n\t\t\tval cachehit \u003d rdsmapcdataout \u003d/\u003d Bits(0) \u0026\u0026 (rdsmapcdataout\u003e\u003e64) \u003d\u003d\u003d ((memaddr-addrrds)\u003e\u003e3)\u003e\u003erdsmapcacheaddrwidth\n\t\t\tval memresp \u003d io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)\n\t\t\twhen(cachehit || memresp){\n\t\t\t\twhen(waitresp){\n\t\t\t\t\tval rdsmapentry \u003d ((memaddr-addrrds)\u003e\u003e3)\n\t\t\t\t\trdsmapcwaddr :\u003d rdsmapentry\u0026rdsmapcacheaddrmask\n\t\t\t\t\trdsmapcdatain :\u003d ((rdsmapentry\u003e\u003erdsmapcacheaddrwidth)\u003c\u003c64)|io.mem.resp.bits.data(63,0)\n\t\t\t\t}.otherwise{}\n\t\t\t\t\n\t\t\t\twaitresp :\u003d Bool(false)\n\t\t\t\trdsmapcprobing :\u003d Bool(false)\n\t\t\t\t\n\t\t\t\twhen(waitresp){\n\t\t\t\t\ttotalrdsmapcachemiss :\u003d totalrdsmapcachemiss + Bits(1)\n\t\t\t\t\tprintf(\"rds range: %x, %x\\n\",io.mem.resp.bits.data(31,0),io.mem.resp.bits.data(63,32))\n\t\t\t\t\trdss :\u003d io.mem.resp.bits.data(31,0)\n\t\t\t\t\trdsp :\u003d io.mem.resp.bits.data(31,0)\n\t\t\t\t\trdse :\u003d io.mem.resp.bits.data(63,32)\n\t\t\t\t}.otherwise{\n\t\t\t\t\ttotalrdsmapcachehit :\u003d totalrdsmapcachehit + Bits(1)\n\t\t\t\t\tprintf(\"RDSMAPCACHEHIT, rdsmapcache data: %x (%x, %x)\\n\",rdsmapcdataout,(rdsmapcdataout\u003e\u003e64),((memaddr-addrrds)\u003e\u003e3)\u003e\u003erdsmapcacheaddrwidth)\n\t\t\t\t\tprintf(\"rds range: %x, %x\\n\",rdsmapcdataout(31,0),rdsmapcdataout(63,32))\n\t\t\t\t\trdss :\u003d rdsmapcdataout(31,0)\n\t\t\t\t\trdsp :\u003d rdsmapcdataout(31,0)\n\t\t\t\t\trdse :\u003d rdsmapcdataout(63,32)\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhen(waitresp \u0026\u0026 (io.mem.resp.bits.data(31,0) \u003d\u003d\u003d io.mem.resp.bits.data(63,32)) || rdsmapcprobing \u0026\u0026 (rdsmapcdataout(31,0) \u003d\u003d\u003d rdsmapcdataout(63,32))){//not need to check if rds is empty\n\t\t\t\t\tmatched :\u003d Bool(true)\n\t\t\t\t\twhen(!callremain(2)){\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen(callremain(2) \u0026\u0026 (funcmode(2) \u003d\u003d\u003d Bits(1) || funcmode(2) \u003d\u003d\u003d Bits(3))){\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\tfunccount :\u003d totalfunccount(1)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdtentry0 \u003d (((funcretpointer(1)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\tval rdtentry1 \u003d ((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\tval rdtentry2 \u003d (((taraddr(1)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\n\t\t\t\t\twhen(brremain(1)){\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry0\u0026rdtcacheaddrmask\n\t\t\t\t\t}.elsewhen(callremain(2)){\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry1\u0026rdtcacheaddrmask\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry2\u0026rdtcacheaddrmask\n\t\t\t\t\t}\n\t\t\t\t\trdtcprobing :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\twhen(brremain(1)){\n\t\t\t\t\t\tval realaddr \u003d addrrdt+(((funcretpointer(1)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t}.elsewhen(callremain(2)){\n\t\t\t\t\t\tval realaddr \u003d addrrdt+((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tval realaddr \u003d addrrdt+(((taraddr(1)\u003e\u003eaddrshift)\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t}\n\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(READRDT)\n\t\t\t\t}\n\t\t\t}.elsewhen(rdsmapcprobing \u0026\u0026 !cachehit){\n\t\t\t\tprintf(\"rdsmap not hit, access rdt in memory\\n\")\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\trdsmapcprobing :\u003d Bool(false)\n\t\t\t}\n\t\t\t.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\twaitresp :\u003d Bool(true)\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(READRDT)){\n\t\trdsp :\u003d rdss\n\t\trdrdt_cycle :\u003d rdrdt_cycle + Bits(1)\n\t\twhen(waitresp || rdtcprobing){\n\t\t\tval cachehit \u003d rdtcdataout \u003d/\u003d Bits(0) \u0026\u0026 (rdtcdataout\u003e\u003e64) \u003d\u003d\u003d ((memaddr-addrrdt)\u003e\u003e3)\u003e\u003erdtcacheaddrwidth\n\t\t\tval memresp \u003d io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)\n\t\t\twhen(cachehit || memresp){\n\t\t\t\topld_count :\u003d opld_count + Bits(1)\n\t\t\t\twhen(memresp){\n\t\t\t\t\tval rdtentry \u003d ((memaddr-addrrdt)\u003e\u003e3)\n\t\t\t\t\trdtcwaddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\trdtcdatain :\u003d ((rdtentry\u003e\u003erdtcacheaddrwidth)\u003c\u003c64)|io.mem.resp.bits.data\n\t\t\t\t}.otherwise{}\n\t\t\t\t\n\t\t\t\twaitresp :\u003d Bool(false)\n\t\t\t\trdtcprobing :\u003d Bool(false)\n\t\t\t\t\n\t\t\t\tval previdfmem \u003d (io.mem.resp.bits.data\u003e\u003e(memaddrmod(2,1)\u003c\u003c4))\u0026Bits(0xffff)\n\t\t\t\tval previdfcache \u003d (rdtcdataout\u003e\u003e(memaddrmod(2,1)\u003c\u003c4))\u0026Bits(0xffff)\n\t\t\t\t\n\t\t\t\twhen(waitresp){\n\t\t\t\t\ttotalrdtcachemiss :\u003d totalrdtcachemiss + Bits(1)\n\t\t\t\t\tprintf(\"latest write id: %d\\n\",previdfmem(15,0))\n\t\t\t\t\tprevwid :\u003d previdfmem(15,0)\n\t\t\t\t}.otherwise{\n\t\t\t\t\ttotalrdtcachehit :\u003d totalrdtcachehit + Bits(1)\n\t\t\t\t\tprintf(\"RDTCACHEHIT, rdtcache data: %x, tag: %x, latest write id: %d\\n\",rdtcdataout(63,0),(rdtcdataout\u003e\u003e64),previdfcache(15,0))\n\t\t\t\t\tprevwid :\u003d previdfcache\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhen(memresp \u0026\u0026 previdfmem \u003d\u003d\u003d Bits(0) || cachehit \u0026\u0026 previdfcache \u003d\u003d\u003d Bits(0)){//not need to check if rdt\u003d0\n\t\t\t\t\tmatched :\u003d Bool(true)\n\t\t\t\t\twhen(!callremain(2)){//no other check\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen((callremain(2) \u0026\u0026 funccount \u003c\u003d Bits(1) \u0026\u0026 (funcmode(2) \u003d\u003d\u003d Bits(1) || funcmode(2) \u003d\u003d\u003d Bits(3)) )){//lib read finished, go to lib write\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\tfunccount :\u003d totalfunccount(1)\n\t\t\t\t\t}.elsewhen(callremain(2)){//lib read unfinished, continue\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\trdtcprobing :\u003d Bool(true)\n\t\t\t\t\t\t\n\t\t\t\t\t\tval realaddr \u003d addrrdt+((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(READRDT)\n\t\t\t\t\t\tfunccount :\u003d funccount - Bits(1)\n\t\t\t\t\t}.otherwise{//OTW, finish DFI process\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.elsewhen(brremain(1)){//if stack pointer needs to be check\n\t\t\t\t\tmatched :\u003d (memresp \u0026\u0026 previdfmem \u003d\u003d\u003d Bits(0xffff)) || (cachehit \u0026\u0026 previdfcache \u003d\u003d\u003d Bits(0xffff))\n\t\t\t\t\tbrremain(1) :\u003d Bool(false)\n\t\t\t\t\tstate :\u003d Bits(IDLE)//this is a function return, callremain must \u003d 0\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdsentry \u003d (rdss\u003c\u003c1)(61,3)\n\t\t\t\t\trdscraddr :\u003d rdsentry\u0026rdscacheaddrmask\n\t\t\t\t\trdscprobing :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\tmemaddr :\u003d ((addrrds+(rdss\u003c\u003c1))(61,3))\u003c\u003c3\n\t\t\t\t\tmemaddrmod :\u003d (addrrds+(rdss\u003c\u003c1))(2,0)\n\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(READRDS)\n\t\t\t\t}\n\t\t\t}.elsewhen(rdtcprobing \u0026\u0026 !cachehit){\n\t\t\t\tprintf(\"not hit, access rdt in memory\\n\")\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\trdtcprobing :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\twaitresp :\u003d Bool(true)\n\t\t\t\tprintf(\"r addr: %x, id: %x, RDT entry: %x\\n\",memaddr,id(2),(memaddr-addrrdt)\u003e\u003e1)\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(READRDS)){\n\t\trdrds_cycle :\u003d rdrds_cycle + Bits(1)\n\t\twhen(waitresp || rdscprobing){\n\t\t\tval cachehit \u003d rdscdataout \u003d/\u003d Bits(0) \u0026\u0026 (rdscdataout\u003e\u003e64) \u003d\u003d\u003d ((memaddr-addrrds)\u003e\u003e3)\u003e\u003erdscacheaddrwidth\n\t\t\tval memresp \u003d io.mem.resp.valid \u0026\u0026 io.mem.resp.bits.tag(1,0) \u003d\u003d\u003d Bits(2)\n\t\t\twhen(cachehit || memresp){\n\t\t\t\twhen(memresp){\n\t\t\t\t\tval rdsentry \u003d ((memaddr-addrrds)\u003e\u003e3)\n\t\t\t\t\trdscwaddr :\u003d rdsentry\u0026rdscacheaddrmask\n\t\t\t\t\trdscdatain :\u003d ((rdsentry\u003e\u003erdscacheaddrwidth)\u003c\u003c64)|io.mem.resp.bits.data\n\t\t\t\t}.otherwise{}\n\t\t\t\t\n\t\t\t\twaitresp :\u003d Bool(false)\n\t\t\t\trdscprobing :\u003d Bool(false)\n\t\t\t\t\n\t\t\t\twhen(waitresp){\n\t\t\t\t\tprintf(\"rds id: %d, %d, %d, %d\\n\",io.mem.resp.bits.data(15,0),io.mem.resp.bits.data(31,16),io.mem.resp.bits.data(47,32),io.mem.resp.bits.data(63,48))\n\t\t\t\t\ttotalrdscachemiss :\u003d totalrdscachemiss + Bits(1)\n\t\t\t\t}.otherwise{\n\t\t\t\t\tprintf(\"RDSCACHEHIT, rds id: %d, %d, %d, %d\\n\",rdscdataout(15,0),rdscdataout(31,16),rdscdataout(47,32),rdscdataout(63,48))\n\t\t\t\t\ttotalrdscachehit :\u003d totalrdscachehit + Bits(1)\n\t\t\t\t}\n\t\t\t\tprintf(\"mem side pass? %x, cache side pass? %x\\n\",onematched,conematched)\n\t\t\t\trdsp:\u003drdsp+Bits(4)\n\t\t\t\twhen((onematched \u0026\u0026 memresp) || (conematched \u0026\u0026 cachehit)){//check pass\n\t\t\t\t\tmatched :\u003d Bool(true)\n\t\t\t\t\twhen(!callremain(2)){//this is not a lib call check, then finish DFI\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen((callremain(2) \u0026\u0026 funccount \u003c\u003d Bits(1) \u0026\u0026 (funcmode(2) \u003d\u003d\u003d Bits(1) || funcmode(2) \u003d\u003d\u003d Bits(3)) )){//this is a call, finished, check if needs write\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\tfunccount :\u003d totalfunccount(1)\n\t\t\t\t\t}.elsewhen(callremain(2) \u0026\u0026 funccount \u003c\u003d Bits(1) \u0026\u0026 funcmode(2) \u003d\u003d\u003d Bits(2)){\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen(callremain(2)){\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\trdtcprobing :\u003d Bool(true)\n\t\t\t\t\t\t\n\t\t\t\t\t\tval realaddr \u003d addrrdt+((((funcarg1(1)\u003e\u003eaddrshift)+funccount-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemaddr :\u003d realaddr(61,3)\u003c\u003c3\n\t\t\t\t\t\tmemaddrmod :\u003d realaddr(2,0)\n\t\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(READRDT)\n\t\t\t\t\t\tfunccount :\u003d funccount - Bits(1)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.elsewhen(rdsp+Bits(4)\u003e\u003drdse){//check not pass\n\t\t\t\t\tmatched :\u003d Bool(false)\n\t\t\t\t\twhen(!callremain(2)){\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}.elsewhen(callremain(2) \u0026\u0026 (funcmode(2) \u003d\u003d\u003d Bits(1) || funcmode(2) \u003d\u003d\u003d Bits(3))){//one of the data readed by lib is violated, no need to check the following data\n\t\t\t\t\t\tval rdtentry \u003d ((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)(61,3)\n\t\t\t\t\t\trdtcraddr :\u003d rdtentry\u0026rdtcacheaddrmask\n\t\t\t\t\t\t\n\t\t\t\t\t\tmemaddr :\u003d addrrdt+((((funcarg0(1)\u003e\u003eaddrshift)+totalfunccount(1)-Bits(1))\u0026Bits(addrmask))\u003c\u003c1)\n\t\t\t\t\t\tmemtype :\u003d Bits(1)\n\t\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\t\tmemw :\u003d Bool(true)\n\t\t\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\t\t\tmemdatain :\u003d id(2)\n\t\t\t\t\t\t\n\t\t\t\t\t\tstate :\u003d Bits(WRITERDT)\n\t\t\t\t\t\tfunccount :\u003d totalfunccount(1)\n\t\t\t\t\t}.otherwise{\n\t\t\t\t\t\tstate :\u003d Bits(IDLE)\n\t\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t}\n\t\t\t\t}.otherwise{\n\t\t\t\t\tval rdsentry \u003d (rdsp+Bits(4)\u003c\u003c1)(61,3)\n\t\t\t\t\trdscraddr :\u003d rdsentry\u0026rdscacheaddrmask\n\t\t\t\t\trdscprobing :\u003d Bool(true)\n\t\t\t\t\t\n\t\t\t\t\tmemaddr :\u003d ((addrrds+(rdsp+Bits(4)\u003c\u003c1))(61,3))\u003c\u003c3\n\t\t\t\t\tmemaddrmod :\u003d (addrrds+(rdsp+Bits(4)\u003c\u003c1))(2,0)\n\t\t\t\t\tmemw :\u003d Bool(false)\n\t\t\t\t\tmemtag :\u003d Bits(2)\n\t\t\t\t\tmemtype :\u003d Bits(3)\n\t\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\t\t\n\t\t\t\t\tstate :\u003d Bits(READRDS)\n\t\t\t\t}\n\t\t\t}.elsewhen(rdscprobing \u0026\u0026 !cachehit){\n\t\t\t\tprintf(\"not hit, access rds in memory\\n\")\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t\trdscprobing :\u003d Bool(false)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t}\n\t\t}.otherwise{\n\t\t\twhen(io.mem.req.fire()){\n\t\t\t\tprintf(\"r rds: %x\\n\",((addrrds+(rdsp\u003c\u003c1))(61,3))\u003c\u003c3);\n\t\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\twaitresp :\u003d Bool(true)\n\t\t\t}.otherwise{\n\t\t\t\tmemvalid :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(WRITELDTRACE)){\n\t\tmemtag :\u003d Bits(2)\n\t\tmemaddr :\u003d addrdebug+Bits(800)+(rdtreaddebug_p\u003c\u003c3)\n\t\tmemw :\u003d Bool(true)\n\t\tmemdatain :\u003d taraddr(1)\n\t\tmemtype :\u003d Bits(3)\n\t\t\n\t\twhen(io.mem.req.fire()){\n\t\t\tprintf(\"rdttrace write to addr: %x, trace %x\\n\",addrdebug+Bits(800)+(rdtreaddebug_p\u003c\u003c3),taraddr(1));\n\t\t\twhen(rdtreaddebug_p\u003e\u003dBits(0x7ff00)){\n\t\t\t\trdtreaddebug_p :\u003d Bits(0)\n\t\t\t}.otherwise{\n\t\t\t\trdtreaddebug_p :\u003d rdtreaddebug_p + Bits(1)\n\t\t\t}\n\n\t\t\tstate :\u003d Bits(WAIT)\n\t\t\t\n\t\t\tval rdsmapentry \u003d id(2)\n\t\t\trdsmapcraddr :\u003d rdsmapentry\u0026rdsmapcacheaddrmask\n\t\t\trdsmapcprobing :\u003d Bool(true)\n\t\t\t\n\t\t\tmemaddr :\u003d addrrds+(id(2)\u003c\u003c3)\n\t\t\tmemw :\u003d Bool(false)\n\t\t\tmemtype :\u003d Bits(3)\n\t\t\tmemtag :\u003d Bits(2)\n\t\t\tmemvalid :\u003d Bool(false)\n\t\t\t\n\t\t\tnstate :\u003d Bits(READRDSMAP)\n\t\t\tpstate :\u003d Bits(WRITELDTRACE)\n\t\t}.otherwise{\n\t\t\tmemvalid :\u003d Bool(true)\n\t\t}\n\t}\n\t.elsewhen(state \u003d\u003d\u003d Bits(REPORT)){\n\t\tmemtag :\u003d Bits(2)\n\t\tmemaddr :\u003d addrdebug+(count\u003c\u003c3)\n\t\tmemw :\u003d Bool(true)\n\t\twhen(count \u003d\u003d\u003d Bits(0)){\n\t\t\tmemdatain :\u003d violations\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(1)){\n\t\t\tmemdatain :\u003d errorcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(2)){\n\t\t\tmemdatain :\u003d totalcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(3)){\n\t\t\tmemdatain :\u003d funcarg0(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(4)){\n\t\t\tmemdatain :\u003d funcarg1(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(5)){\n\t\t\tmemdatain :\u003d funcarg2(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(6)){\n\t\t\tmemdatain :\u003d funcretpointer(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(7)){\n\t\t\tmemdatain :\u003d totalfunccount(1)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(8)){\n\t\t\tmemdatain :\u003d opst_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(9)){\n\t\t\tmemdatain :\u003d opld_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(10)){\n\t\t\tmemdatain :\u003d uprdt_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(11)){\n\t\t\tmemdatain :\u003d rdrdt_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(12)){\n\t\t\tmemdatain :\u003d rdrdsmap_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(13)){\n\t\t\tmemdatain :\u003d rdrds_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(14)){\n\t\t\tmemdatain :\u003d chk_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(15)){\n\t\t\tmemdatain :\u003d maxlibarg0\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(16)){\n\t\t\tmemdatain :\u003d maxlibarg1\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(17)){\n\t\t\tmemdatain :\u003d maxlibarg2\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(18)){\n\t\t\tmemdatain :\u003d maxlibarg3\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(19)){\n\t\t\tmemdatain :\u003d maxlibretaddr\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(20)){\n\t\t\tmemdatain :\u003d maxlibretptr\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(21)){\n\t\t\tmemdatain :\u003d maxliblen\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(22)){\n\t\t\tmemdatain :\u003d totalldopt\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(23)){\n\t\t\tmemdatain :\u003d totalldnoopt\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(24)){\n\t\t\tmemdatain :\u003d totalrdtcachehit\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(25)){\n\t\t\tmemdatain :\u003d totalrdsmapcachehit\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(26)){\n\t\t\tmemdatain :\u003d rdtcdataout\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(27)){\n\t\t\tmemdatain :\u003d rdsmapcdataout\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(28)){\n\t\t\tmemdatain :\u003d totalrdscachehit\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(29)){\n\t\t\tmemdatain :\u003d totalrdtcachemiss\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(30)){\n\t\t\tmemdatain :\u003d totalrdsmapcachemiss\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(31)){\n\t\t\tmemdatain :\u003d totalrdscachemiss\n\t\t/*\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(32)){\n\t\t\tmemdatain :\u003d lat_call_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(33)){\n\t\t\tmemdatain :\u003d lat_call_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(34)){\n\t\t\tmemdatain :\u003d lat_libst_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(35)){\n\t\t\tmemdatain :\u003d lat_libst_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(36)){\n\t\t\tmemdatain :\u003d lat_libld_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(37)){\n\t\t\tmemdatain :\u003d lat_libld_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(38)){\n\t\t\tmemdatain :\u003d lat_libstld_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(39)){\n\t\t\tmemdatain :\u003d lat_libstld_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(40)){\n\t\t\tmemdatain :\u003d lat_ret_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(41)){\n\t\t\tmemdatain :\u003d lat_ret_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(42)){\n\t\t\tmemdatain :\u003d lat_st_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(43)){\n\t\t\tmemdatain :\u003d lat_st_cycles\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(44)){\n\t\t\tmemdatain :\u003d lat_ld_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(45)){\n\t\t\tmemdatain :\u003d lat_ld_cycles\n\t\t*/\n\t\t\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(32)){\n\t\t\tmemdatain :\u003d idle_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(33)){\n\t\t\tmemdatain :\u003d total_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(34)){\n\t\t\tmemdatain :\u003d fifocuspush_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(35)){\n\t\t\tmemdatain :\u003d fifofuncpush_cycle\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(36)){\n\t\t\tmemdatain :\u003d fifocusbranchpush\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(37)){\n\t\t\tmemdatain :\u003d fifocusbranchpop\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(38)){\n\t\t\tmemdatain :\u003d fifofuncbranchpush\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(39)){\n\t\t\tmemdatain :\u003d fifofuncbranchpop\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(40)){\n\t\t\tmemdatain :\u003d fifofuncloss\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(41)){\n\t\t\tmemdatain :\u003d fifofunclatestlossinfo\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(42)){\n\t\t\tmemdatain :\u003d fifofunclatestlosscuscount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(43)){\n\t\t\tmemdatain :\u003d fifofunclatestlossfunccount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(44)){\n\t\t\tmemdatain :\u003d fifofunclatestlossrecord\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(45)){\n\t\t\tmemdatain :\u003d fifofunclatestlosstaraddr\n\t\t\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(46)){\n\t\t\tmemdatain :\u003d fifocusmax\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(47)){\n\t\t\tmemdatain :\u003d fifofuncmax\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(48)){\n\t\t\tmemdatain :\u003d shdstackmax\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(49)){\n\t\t\tmemdatain :\u003d stop_call_count\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(50)){\n\t\t\tmemdatain :\u003d stop_call_count_all\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(51)){\n\t\t\tmemdatain :\u003d stop_call_count_max\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(52)){\n\t\t\tmemdatain :\u003d stop_coreexception\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(53)){\n\t\t\tmemdatain :\u003d totalstcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(54)){\n\t\t\tmemdatain :\u003d totalldcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(55)){\n\t\t\tmemdatain :\u003d totalcallcount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(56)){\n\t\t\tmemdatain :\u003d totalcallexceptioncount\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(57)){\n\t\t\tmemdatain :\u003d Bits(0)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(58)){\n\t\t\tmemdatain :\u003d Bits(0)\n\t\t}.elsewhen(count \u003d\u003d\u003d Bits(59)){\n\t\t\tmemdatain :\u003d Bits(0x11122233)\n\t\t}\n\t\t.otherwise{}\n\t\t\n\t\tmemtype :\u003d Bits(3)\n\t\twhen(io.mem.req.fire()){\n\t\t\t//printf(\"report write to addr: %x\\n\",addrdebug+((count+Bits(6))\u003c\u003c2));\n\t\t\tmemvalid :\u003d Bool(false)\n\t\t\tstate :\u003d Bits(WAIT)\n\t\t\twhen(count \u003c Bits(59)){\n\t\t\t\tnstate :\u003d Bits(REPORT)\n\t\t\t}.otherwise{\n\t\t\t\tnstate :\u003d Bits(IDLE)\n\t\t\t}\n\t\t\tpstate :\u003d Bits(REPORT)\n\t\t\tcount :\u003d count + Bits(1)\n\t\t}.otherwise{\n\t\t\tmemvalid :\u003d Bool(true)\n\t\t}\n\t}\n\t.otherwise{}\n\t\n}\n//flang----------------\n\n\n//wxr++++++++++++\n\n\n\n/*\nHere are some reasons:\n\t1.Locality 2.History\n\tWe use the shiftreg to hold the history message\n*/\nclass Redundant_Buffer(Depth:Int)(implicit p: Parameters) extends Module {\n\tval io \u003d IO(new Bundle{\n\t\t//fifo signals\n\t\tval fifo_read \u003d Bool(OUTPUT)\n\t\tval fifo_empty \u003d Bool(INPUT)\n\t\tval fifo_data \u003d Input(UInt(64.W))\n\t\t//redundant signals out\n\t\tval info_req \u003d Bool(INPUT)\n\t\tval info_resp \u003d Bool(OUTPUT)\n\t\tval info_data \u003d Output(UInt(64.W))\n\t\t//configure siganls\n\t\tval conf_valid \u003d Bool(INPUT)\n\t\tval group_num \u003d Input(UInt(3.W)) //how many 64, load from the fifo\n\t\tval group_realtion \u003d Input(UInt(1.W)) // 0 || ; 1 \u0026\u0026\n\t\tval conditions \u003d Input(UInt(2.W)) //8 shiftregs, need 2 conditions bit \u003c \u003e \u003d\n\t})\n\n\n}\n\n\n//This module is memory in the micro-core\n\n\nclass mem_rw(implicit p:Parameters) extends CoreBundle{\n\tval addr \u003d Input(UInt(width  \u003d 32))\n\tval write \u003d Bool(INPUT)\n\tval data_w \u003d Input(UInt(64.W))\n\tval busy \u003d Bool(OUTPUT)\n\tval burst \u003d Input(UInt(4.W)) //0000:no burst\n\tval out \u003d Output(UInt(64.W))\n}\n\n/*\nclass micro_core_mem(Depth:Int)(implicit p: Parameters) extends Module {\n\tval io \u003d IO(new Bundle {\n\t\tval initial \u003d new HellaCacheIO \n\t\tval initial_done \u003d Bool(OUTPUT)\n\t\tval initial_valid \u003d Bool(INPUT)\n\t\tval initial_addr \u003d Input(UInt(64.W))\n\t\tval initial_len \u003d Input(UInt(16.W))\n\n\t\tval rw \u003d new mem_rw\n\t})\n\n\tval mem \u003d Mem(64, Bits(width \u003d 1\u003c\u003cDepth)) \n\tval initial_done \u003d Reg(Bool(false))\n\tio.initial_done :\u003d initial_done \n\n\t//rw signal\n\tval out_r \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval busy_r \u003d Reg(Bool(false))\n\tio.rw.out :\u003d out_r\n\tio.rw.busy :\u003d busy_r\n\t\n\t//cache io\n\tval mem_state \u003d Reg(init \u003d Bits(0,width \u003d 4))\n\tval req_valid \u003d Reg(Bool(false))\n\tval initial_done_r \u003d Reg(Bool(false))\n\tio.initial.req.valid :\u003d req_valid\n\tio.initial.req.addr :\u003d dma_addr + dma_cnt * 8.U\n\tio.initial_done :\u003d initial_done_r\n\t\n\n\tswitch(mem_state){\n\t\tis(UInt(0)){\n\t\t\twhen(io.initial_valid \u0026\u0026 !initial_done){\n\t\t\t\tdma_len  :\u003d io.initial_len\n\t\t\t\tdma_addr :\u003d io.initial_addr\n\t\t\t\tmem_state :\u003d 1.U\n\t\t\t}\n\t\t}\n\t\tis(UInt(1)){\n\t\t\treq_valid :\u003d Bool(true)\n\t\t\twhen(io.initial.req.fire()){\n\t\t\t\tmem_state :\u003d 2.U\n\t\t\t\treq_valid :\u003d Bool(false)\n\t\t\t}\n\t\t}\n\t\tis(UInt(2)){\n\t\t\twhen(io.initial.resp.valid){\n\t\t\t\tdma_cnt :\u003d Mux(dma_cnt \u003d\u003d dma_len-1.U ,0.U ,dma_cnt+1.U )\n\t\t\t\tmem_state :\u003d Mux(dma_cnt \u003d\u003d dma_len -1.U,3.U ,1.U)\n\t\t\t\tmem(dma_cnt) :\u003d io.initial.resp.bits.data\n\t\t\t}\n\t\t}\n\t\tis(UInt(3)){\n\t\t\tinitial_done_r :\u003d Bool(true)\n\t\t\twhen(io.rw.write){\n\t\t\t\t\t\tmem(io.rw.addr) :\u003d io.rw.data_w\n\t\t\t\t}\n\n\t\t\t}.otherwise{\n\t\t\t\t\t\tout_r :\u003d mem(io.rw.addr)\n\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n*/\n\nclass mem_initial(implicit p:Parameters) extends CoreBundle{\n\tval valid \u003d Input(Bool())\n\tval addr \u003d Input(UInt(width  \u003d 32))\n\tval len \u003d Input(UInt(64.W))\n\tval load_done \u003d Output(Bool())\n}\n\n\n\n//This class bundle the message come from hardware\nclass info(implicit p:Parameters) extends CoreBundle{\n\tval cfi \u003d Decoupled(new CFIPort).flip\n}\n\n\n\n//shadow stack\n/*\nThis stack has 16 entries, each entry has 64bits. At the same time\n, when the stack is full, the lastest push entry will be replaced \nby the newest entry\n*/\nclass stack(implicit p: Parameters) extends Module {\n\tval io \u003d IO(new Bundle{\n\t\tval push \u003d Bool(INPUT)\n\t\tval pop \u003d Bool(INPUT)\n\t\tval data_in \u003d Input(UInt(64.W))\n\t\tval data_out \u003d Output(UInt(64.W))\n\t\tval empty \u003d Bool(OUTPUT)\n\t})\n\n\tval mem \u003d Mem(16,Bits(width\u003d64))\n\tval top \u003d Reg(init \u003d Bits(0,width\u003d5))\n\tval bottom \u003d Reg(init \u003d Bits(0,width\u003d5))\n\tio.empty :\u003d top \u003d\u003d\u003d bottom\n\tval full \u003d ( Mux(top\u003ebottom,top-bottom,bottom-top )\u003d\u003d\u003d 15.U )\n\tval data_out_reg \u003d Reg(init \u003d Bits(0,width\u003d64))\n\tio.data_out :\u003d data_out_reg\n\twhen(io.push \u0026\u0026 io.pop){\n\t\tdata_out_reg :\u003d mem(top)\n\t\tmem(top) :\u003d io.data_in\n\t}.elsewhen(io.push){\n\t\ttop :\u003d top+1.U\n\t\tbottom :\u003d Mux(full,bottom + 1.U,bottom)\n\t\tmem(top+1.U) :\u003d io.data_in\n\t}.elsewhen(io.pop){\n\t\ttop :\u003d Mux(io.empty,top,top-1.U) //maybe there is bug\n\t\tdata_out_reg :\u003d mem(top)\n\t}\n\n}\n\n\n//This trait describe some const\ntrait co_core_const{\n\tdef CO_JUMP       \u003d UInt(\"b000001\")\n\tdef CO_FIFO_INPUT \u003d UInt(\"b000010\")\n\tdef CO_LOAD       \u003d UInt(\"b000011\")\n\tdef CO_STORE      \u003d UInt(\"b000100\")\n\tdef CO_CMP        \u003d UInt(\"b000101\")\n\tdef CO_ADD        \u003d UInt(\"b000110\")\n\tdef CO_MUL        \u003d UInt(\"b000111\")\n\tdef CO_MINUS      \u003d UInt(\"b001000\")\n\tdef CO_WReg       \u003d UInt(\"b001001\")\n\tdef CO_DO_UNTIL   \u003d UInt(\"b001010\")\n\tdef CO_R_BUF      \u003d UInt(\"b001011\")  //read the message from buffer\n\tdef CO_R_FIFO     \u003d UInt(\"b001100\")\n\tdef CO_SL         \u003d UInt(\"b001101\")\n\tdef CO_RL         \u003d UInt(\"b001110\")\n\tdef CO_BIT_AND    \u003d UInt(\"b001111\")\n\tdef CO_IF         \u003d UInt(\"b010000\")\n\tdef CO_POP        \u003d UInt(\"b010001\")\n\tdef CO_PUSH       \u003d UInt(\"b010010\")\n\tdef CO_S_LOAD     \u003d UInt(\"b010011\")\n\n}\n\n\n\n//This module describe the pipeline of the micro-core\n/*\n@first stage : fetch the inst from IMem, IMem is limited in 50 instructions(6 bits address)\n@second stage: decode and if needed fetch the memeroy data to normal-reg and do some computation\n*/\nclass micro_core(mem_Depth:Int)(implicit p: Parameters) extends Module with co_core_const {\n\tval io \u003d IO(new Bundle{\n\t\tval stall \u003d Bool(INPUT)\n\t\tval stalled \u003d Bool(OUTPUT)\n\t\tval main_core_stall \u003d Bool(OUTPUT)\n\t\tval mem_initial \u003d new mem_initial\n\t\tval mem_p \u003d new HellaCacheIO\n\t\tval info \u003d new info\n\t})\n\n\t//input and output\n\tval fifo_r \u003d Reg(init \u003d Bool(false)) \n\tval stalled_vec \u003d Reg(init \u003d Vec.fill(2){Bool(false)}) \n\tval stalled_fifo_empty \u003d Reg(init \u003d Bool(false))\n\tval stalled_s_pop \u003d Reg(init \u003d Bool(false))\n\tval stalled_r \u003d stalled_vec(0) || stalled_vec(1) || stalled_fifo_empty || fifo_r || stalled_s_pop\n\t//some situation, we need to stall the fifo\n\tio.stalled :\u003d stalled_r\n\t\n\n\t//some utils like reg, CSRs and fifo\n\t//the 16-31 is the CSR register\n\tval reg \u003d Reg(init \u003d Vec.fill(32){Bits(0,width \u003d 64)})\n\n\tval fifo \u003dModule(new DFIFIFO(1024,64))\n\tfifo.io.read :\u003d fifo_r\n\n\n\n\tval initial_done_w \u003d Wire(Bool())\n\tval cfi_en_w \u003d Wire(Bool())\n\tval mem_state_w \u003d Wire(UInt(4.W))\n\t//stall the main core with some situation\n\tio.main_core_stall :\u003d fifo.io.full || (io.mem_initial.valid || mem_state_w \u003d/\u003d 0.U) || (initial_done_w \u0026\u0026 !cfi_en_w  )\n\n\t//shadow stack\n\tval stack \u003d Module(new stack)\n\n/****************\n * initial instruction memory\n****************/\n\tval i_mem \u003d Mem(64, Bits(width \u003d 64)) \n\tval mem_state \u003d Reg(init \u003d Bits(0,width \u003d 4))\n\tmem_state_w :\u003d mem_state\n\tval dma_len \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval dma_addr \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval dma_cnt \u003d Reg(init \u003d Bits(0,width \u003d 16))\n\tval req_valid_init \u003d Reg(init \u003d Bool(false))\n\tval initial_done_r \u003d Reg(init \u003d Bool(false))\n\tio.mem_initial.load_done :\u003d initial_done_r\n\tinitial_done_w :\u003d initial_done_r\n\n\tswitch(mem_state){\n\t\tis(UInt(0)){\n\t\t\twhen(io.mem_initial.valid \u0026\u0026 !initial_done_r){\n\t\t\t\tdma_len  :\u003d io.mem_initial.len\n\t\t\t\tdma_addr :\u003d io.mem_initial.addr\n\t\t\t\tmem_state :\u003d 1.U\n\t\t\t}\n\t\t}\n\t\tis(UInt(1)){\n\t\t\treq_valid_init :\u003d Bool(true)\n\t\t\twhen(io.mem_p.req.fire()){\n\t\t\t\tmem_state :\u003d 2.U\n\t\t\t\treq_valid_init :\u003d Bool(false)\n\t\t\t}\n\t\t}\n\t\tis(UInt(2)){\n\t\t\twhen(io.mem_p.resp.valid){\n\t\t\t\tdma_cnt :\u003d Mux(dma_cnt \u003d\u003d\u003d dma_len-1.U ,0.U ,dma_cnt+1.U )\n\t\t\t\tmem_state :\u003d Mux(dma_cnt \u003d\u003d\u003d dma_len -1.U,0.U ,1.U)\n\t\t\t\tinitial_done_r :\u003d Mux(dma_cnt \u003d\u003d\u003d dma_len -1.U,Bool(true) ,Bool(false))\n\t\t\t\ti_mem(dma_cnt) :\u003d io.mem_p.resp.bits.data\n\t\t\t}\n\t\t}\n\t}\n\n\n\n/***********\n * stage 1\n***********/\n\t//@fetch stage: fetch the inst from the Mem the begin address is 0x0\n\tval inst \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval pc \u003d Reg(init \u003d Bits(0,width \u003d 8))\n\t//Do util signal\n\tval do_util \u003d Reg(init \u003d Bool(false))\n\tval do_util_invalid \u003d Reg(init \u003d Bool(false))\n\tval co_pc1 \u003d Reg(init \u003d Bits(0,width\u003d6))\n\tval co_pc2 \u003d Reg(init \u003d Bits(0,width\u003d6))\n\tval co_new_pc \u003d Reg(init \u003d Bits(0,width\u003d6))\n\tval co_do_util_happen \u003d Reg(init \u003d Bool(false))\n\t//if decode_invald signal\n\tval if_en_w \u003d Wire(Bool())\n\tval if_new_pc_w \u003d Wire(UInt(6.W))\n\t\n\tval pc_flush \u003d Reg(init \u003d Bool(false))\n\tval co_event_happen_w \u003d Wire(Bool())\n\tval decode_invalid \u003d  pc_flush || RegNext(pc_flush) || do_util_invalid || RegNext(do_util_invalid) || co_do_util_happen || co_event_happen_w || RegNext(if_en_w)\n\t\n\tval new_pc \u003d Reg(UInt(40.W))\n\t//PC GEN, generate the pc\n    val pc_en \u003d !io.stall \u0026\u0026 !stalled_r \u0026\u0026 initial_done_r \n\twhen(pc_en){\n\t\twhen(if_en_w){\n\t\t\tpc :\u003d if_new_pc_w\n\t\t}\n\t\t.elsewhen(!do_util){\n\t\t\tpc :\u003d Mux(pc_flush,new_pc, Mux (co_do_util_happen,co_new_pc ,pc+1.U))\n\t\t}.otherwise{\n\t\t\twhen(do_util_invalid){\n\t\t\t\tpc :\u003d co_pc1\n\t\t\t}.otherwise{\n\t\t\t\tpc :\u003d Mux(pc_flush , new_pc,Mux(pc \u003d\u003d\u003d co_pc2,co_pc1,pc+1.U ))\n\t\t\t}\n\n\t\t}\n\t\tinst :\u003d i_mem(pc)\n\t}\n\n/*********\n * stage 2\n@Decode and exe stage\n*********/\n\t////////////////////////////////////////////////////////////////////co-jump\n\tpc_flush :\u003d (inst(5,0) \u003d\u003d\u003d CO_JUMP) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tnew_pc :\u003d inst(11,6)\n\n\t////////////////////////////////////////////////////////////////////co-if\n\tval co_if \u003d (inst(5,0) \u003d\u003d\u003d CO_IF) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tval if_en \u003d reg(inst(11,6)) \u003d\u003d\u003d inst(17,12) \u0026\u0026 co_if\n\tval if_new_pc \u003d inst(23,18)\n\tif_en_w :\u003d if_en\n\tif_new_pc_w :\u003d if_new_pc\n\n\t////////////////////////////////////////////////////////////////////shadow pop/push/load\n\tval s_pop \u003d (inst(5,0) \u003d\u003d\u003d CO_POP) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tval s_push \u003d (inst(5,0) \u003d\u003d\u003d CO_PUSH) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tval s_load \u003d (inst(5,0) \u003d\u003d\u003d CO_S_LOAD) \u0026\u0026 (!decode_invalid) \u0026\u0026 !stalled_r\n\tval s_pop_id \u003d Reg(init \u003d Bits(0,width\u003d6))\n\tval stack_status \u003d Mux(stack.io.empty,1.U,0.U) \n\ts_pop_id :\u003d Mux(s_pop,inst(11,6),s_pop_id)\n\tstalled_s_pop :\u003d s_pop\n\tstack.io.push :\u003d s_push\n\tstack.io.pop :\u003d s_pop\n\tstack.io.data_in :\u003d reg(inst(11,6))\n\t\n\n\n\t////////////////////////////////////////////////////////////////////co-fifo\n\t/*\n\tval io \u003d new Bundle{\n\t\tval rst \u003d Bool(INPUT)\n\t\tval write \u003d Bool(INPUT)\n\t\tval datain \u003d Bits(width \u003d datawidth).flip\n\t\tval read \u003d Bool(INPUT)\n\t\tval dataout \u003d Bits(width \u003d datawidth)\n\t\tval full \u003d Bool(OUTPUT)\n\t\tval empty \u003d Bool(OUTPUT)\n\t}\n\tinst(11,6) -\u003e the info, 000000-\u003ecfi, 0000001-\u003edfi\n\t*/\n\t/*\n\t1.CFI situation\n\t\tThe isCFI \u0026\u0026 valid is the branch or other jump instruction\n\t\tand we need to hold the next correct instrution then\n\t\n\t*/\n\tval cfi_pc_r_1 \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\tval cfi_pc_r_2 \u003d Reg(init \u003d Bits(0,width \u003d 64))\n\twhen(io.info.cfi.bits.valid){\n\t\tcfi_pc_r_2 :\u003d cfi_pc_r_1\n\t\tcfi_pc_r_1 :\u003d io.info.cfi.bits.pc\n\t}\n\tval pc_NoChange \u003d cfi_pc_r_1 \u003d\u003d\u003d cfi_pc_r_2\n\n\tval cfi_en \u003d Reg(init \u003d Bool(false))\n\tcfi_en_w :\u003d cfi_en\n\tval cfi_target_valid \u003d io.info.cfi.bits.valid \u0026\u0026 !io.info.cfi.bits.mispredict\n\tval cfi_wait_target \u003d Reg(init \u003d Bool(false))\n\tval isCFI_valid \u003d (io.info.cfi.bits.valid \u0026\u0026 io.info.cfi.bits.isCFI \u0026\u0026 io.info) \n\twhen(isCFI_valid){\n\t\tcfi_wait_target :\u003d Bool(true)\n\t}.elsewhen(cfi_wait_target){\n\t\twhen(io.info.cfi.bits.valid \u0026\u0026 !io.info.cfi.bits.mispredict){\n\t\t\tcfi_wait_target :\u003d Bool(false)\n\t\t}\n\t}.otherwise{\n\t\tcfi_wait_target :\u003d Bool(false)\n\t}\n\tval cfi_valid \u003d (isCFI_valid || (cfi_wait_target \u0026\u0026 cfi_target_valid  ) ) \u0026\u0026 !pc_NoChange\n\n\tfifo.io.write :\u003d Mux(cfi_en,cfi_valid,Bool(false))\n\tfifo.io.datain :\u003dMux(cfi_en,Mux(isCFI_valid,(io.info.cfi.bits.pc | (io.info.cfi.bits.cfiType\u003c\u003c40) ),io.info.cfi.bits.pc),0.U) //add the cfiType to the fifo data\n\t\t\n\n\twhen(inst(5,0) \u003d\u003d\u003d CO_FIFO_INPUT \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r){\n\t\tswitch( inst(11,6) ){\n\t\t\tis(0.U){\n\t\t\t\tcfi_en :\u003d Bool(true)\n\t\t\t}\n\t\t}\n\t}\n\n\n\t///////////////////////////////////////////////////////////////co-load/store\n\t/*\n\tstore the reg to mem just need one cycle\n\tinst(11,6) is the reg id, the inst (17,12)is reg base add ,inst(23,18) \n\n\tload the mem to reg need 2 cycles. cycle read the mem to tmp\n\tinst(11,6) is the tmp reg id\n\t*/\n\tval store_en \u003d inst(5,0) \u003d\u003d\u003d CO_STORE \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval req_valid_store \u003d Reg(init \u003d Bool(false))\n\tval load_en \u003d inst(5,0) \u003d\u003d\u003d CO_LOAD \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval req_valid_load \u003d Reg(init \u003d Bool(false))\n\tval offset_addr_s \u003d Reg(init \u003d Bits(0,width \u003d64))\n\tval offset_addr_l \u003d Reg(init \u003d Bits(0,width \u003d64))\n\tval base_addr_s \u003d Reg(init \u003d Bits(0,width \u003d64))\n\tval base_addr_l \u003d Reg(init \u003d Bits(0,width \u003d64))\n\n\n\tval store_id \u003d Reg(init \u003d Bits(0,width \u003d6))\n\tval load_id \u003d Reg(init \u003d Bits(0,width \u003d6))\n\n\twhen(store_en){\n\t\tstalled_vec(0) :\u003d Bool(true)\n\t\treq_valid_store :\u003d Bool(true)\n\t\tbase_addr_s :\u003d reg(inst(17,12))\n\t\toffset_addr_s :\u003d reg(inst(23,18))\n\t\tstore_id :\u003d inst(11,6)\n\t}.elsewhen(stalled_vec(0) \u0026\u0026 io.mem_p.req.fire()){\n\t\treq_valid_store :\u003d Bool(false)\n\t}.elsewhen(io.mem_p.resp.fire()){\n\t\tstalled_vec(0) :\u003d Bool(false)\n\t}\n\t\t\n\twhen(load_en){\n\t\tstalled_vec(1) :\u003d Bool(true)\n\t\treq_valid_load :\u003d Bool(true)\n\t\tbase_addr_l :\u003d reg(inst(17,12))\n\t\toffset_addr_l :\u003d reg(inst(23,18))\n\t\tload_id :\u003d inst(11,6)\n\t}.elsewhen(stalled_vec(1) \u0026\u0026 io.mem_p.req.fire()){\n\t\treq_valid_load :\u003d Bool(false)\n\t}.elsewhen(io.mem_p.resp.fire()){\n\t\tstalled_vec(1) :\u003d Bool(false)\n\t}\n\n\n\t///////////////////////////////////////////////////////////////ALU\n\t//inst(11,6) rs1 inst(17,12) rs2, inst(23,18) rd\n\tval Add \u003d inst(5,0) \u003d\u003d\u003d CO_ADD \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval Minus \u003d inst(5,0) \u003d\u003d\u003d CO_MINUS \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval Cmp \u003d inst(5,0) \u003d\u003d\u003d CO_CMP \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval SL \u003d inst(5,0) \u003d\u003d\u003d CO_SL \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval RL \u003d inst(5,0) \u003d\u003d\u003d CO_RL \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval BIT_ADD \u003d inst(5,0) \u003d\u003d\u003d CO_BIT_AND \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\n\t\n\tval Add_res \u003d reg(inst(11,6))+reg(inst(17,12))\n\tval Minus_res \u003d reg(inst(11,6))-reg(inst(17,12))\n\tval Cmp_res \u003d Mux(reg(inst(11,6))\u003d\u003d\u003dreg(inst(17,12)),1.U,0.U)\n\tval SL_res \u003d reg(inst(11,6)) \u003c\u003c reg(inst(17,12))(6,0)\n\tval RL_res \u003d reg(inst(11,6)) \u003e\u003e reg(inst(17,12))(6,0)\n\tval BA_res \u003d reg(inst(11,6)) \u0026 reg(inst(17,12))\n\n\n\t///////////////////////////////////////////////////////////////Wreg\n\tval w_reg \u003d inst(5,0) \u003d\u003d\u003d CO_WReg \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval w_reg_data \u003d inst(63,12)\n\n\t///////////////////////////////////////////////////////////////read buffer\n\t//This instruction will stalled the co-core util read the proper message\n\tval r_buf \u003d inst(5,0) \u003d\u003d\u003d CO_R_BUF \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\n\n\n\t///////////////////////////////////////////////////////////////read fifo \n\tval r_fifo \u003d inst(5,0) \u003d\u003d\u003d CO_R_FIFO \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval r_fifo_rd \u003d Reg(init \u003d Bits(0,width \u003d6))\n//\tval fifo_r_data \u003d\n\twhen(r_fifo){\n\t\tstalled_fifo_empty :\u003d Bool(true)\n\t\tr_fifo_rd :\u003d inst(11,6)\n\t\tfifo_r :\u003d Bool(false)\n\t}.elsewhen(stalled_fifo_empty){\n\t\twhen(fifo.io.empty){\n\t\t\tstalled_fifo_empty :\u003d Bool(true)\n\t\t\tfifo_r :\u003d Bool(false)\n\t\t}.otherwise{\n\t\t\tfifo_r :\u003d Bool(true)\n\t\t\tstalled_fifo_empty :\u003d Bool(false)\n\t\t}\n\t}.otherwise{\n\t\tfifo_r :\u003d Bool(false)\n\t}\n\n\t////////////////////////////////////////////////////////////////DO-until\n\t/*\n\tthis instruction used to keep the hardware loop without the jump\n\t*/\n\tval Do_Util \u003d inst(5,0) \u003d\u003d\u003d CO_DO_UNTIL \u0026\u0026 !decode_invalid \u0026\u0026 !stalled_r \n\tval co_event \u003d Reg(init \u003d Bits(0,width\u003d4))\n\tval co_event_value \u003d Reg(init \u003d Bits(0,width\u003d4))\n\tco_event_happen_w :\u003d Mux(co_event\u003d\u003d\u003d0.U,reg(16)\u003d\u003d\u003dco_event_value ,Bool(false) ) \u0026\u0026 do_util //Because of the reg write need one more cycle\n\twhen(Do_Util){\n\t\tdo_util :\u003d Bool(true)\n\t\tco_pc1 :\u003d inst(11,6)\n\t\tco_pc2 :\u003d inst(17,12)\n\t\tco_new_pc :\u003d inst(23,18)\n\t\tco_event :\u003d inst(27,24)\n\t\tco_event_value :\u003d inst(32,28)\n\t\tdo_util_invalid :\u003d Bool(true)\n\t\tco_do_util_happen :\u003d Bool(false)\n\t}.elsewhen(do_util){\n\t\tdo_util_invalid :\u003d Bool(false)\n\t\tswitch(co_event){\n\t\t\tis(0.U){\n\t\t\t\t//event0 : register16\n\t\t\t\twhen(reg(16) \u003d\u003d\u003d co_event_value){\n\t\t\t\t\tdo_util :\u003d Bool(false)\n\t\t\t\t\tco_do_util_happen :\u003d Bool(true)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}.otherwise{\n\t\tdo_util_invalid :\u003d Bool(false)\n\t\tco_do_util_happen :\u003d Bool(false)\n\t}\n\n\n\n/***********\nreg IO\n***********/\n\tval reg_w_id \u003d Mux(stalled_vec(1),load_id, Mux( fifo_r, r_fifo_rd, Mux(w_reg||s_load,inst(11,6),Mux( stalled_s_pop ,s_pop_id,inst(23,18)) ) ))\n\tval reg_w_en \u003d io.mem_p.resp.fire() || Add || Minus || Cmp || SL || RL || BIT_ADD || w_reg || fifo_r || stalled_s_pop || s_load\n\twhen(reg_w_en){\n\t\treg(reg_w_id) :\u003d Mux(stalled_vec(1),io.mem_p.resp.bits.data,Mux(Add,Add_res, Mux(Minus,Minus_res, Mux(Cmp,Cmp_res,Mux(w_reg,w_reg_data,\n\t\t\t\t\t\t\t\tMux(fifo_r, fifo.io.dataout , Mux(SL,SL_res , Mux(RL,RL_res, Mux(BIT_ADD, BA_res, Mux(stalled_s_pop, stack.io.data_out, Mux(s_load ,stack_status ,reg(reg_w_id) ) )) ))  ))))))\n\t}\n\n\n\n/************\nmem(cache) IO\n************/\n\tio.mem_p.req.valid :\u003d req_valid_init || req_valid_load || req_valid_store\n\tio.mem_p.req.bits.addr :\u003d Mux(!initial_done_r,dma_addr + dma_cnt * 8.U, Mux(stalled_vec(0),base_addr_s+offset_addr_s,base_addr_l+offset_addr_l) ) /////////potential bug(0)\n\tio.mem_p.req.bits.data :\u003d Mux(stalled_vec(0), reg(store_id),0.U)\n\tio.mem_p.req.bits.tag :\u003d Bits(0)\n\tio.mem_p.req.bits.cmd :\u003dMux(!initial_done_r || stalled_vec(1),M_XRD,M_XWR) // perform a load (M_XWR for stores)\n\tio.mem_p.req.bits.phys :\u003d Bool(false)\n\tio.mem_p.req.bits.typ :\u003d MT_D\n\n}\n\n\n\n\n\n\n\n\n\n\n\n//wxr------------\n\n\n\n\n\n\n//wxrqw++++++++++++++++\nclass  Co_processor(opcodes: OpcodeSet, val n: Int \u003d 4)(implicit p: Parameters) extends LazyRoCC(opcodes) {\n  override lazy val module \u003d new Co_processor_ModuleImp(this)\n}\n\nclass Co_processor_ModuleImp(outer: Co_processor)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n    with HasCoreParameters {\n  val cmd \u003d Queue(io.cmd)\n  val funct \u003d cmd.bits.inst.funct\n\n\n/*\nTHe co-core\n*/\n\nval co_core \u003d Module(new micro_core(10))\nco_core.io.info.cfi \u003c\u003e io.cfi\nio.mem \u003c\u003e co_core.io.mem_p\n\n\n/*Function 1(funct 0 is i_mem 10 is d_mem), load the memory from the rs1, size is rs2 */ \n  val doLoad \u003d funct \u003d\u003d\u003d UInt(0)\n  val load_valid \u003d Reg(init \u003d Bool(false)) \n  val Load_addr \u003d Reg(init \u003d Bits(0,width\u003d64))\n  val Load_size \u003d Reg(init \u003d Bits(0,width\u003d64))\n  co_core.io.mem_initial.addr :\u003d Load_addr\n  co_core.io.mem_initial.len :\u003d Load_size\n  co_core.io.mem_initial.valid :\u003d load_valid\n\n  when(cmd.fire() \u0026\u0026 doLoad){\n\tLoad_addr :\u003d cmd.bits.rs1\n\tLoad_size :\u003d cmd.bits.rs2\n\tload_valid :\u003d Bool(true)\n  }.otherwise{\n\t  load_valid :\u003d Bool(false)\n  }\n\n\n\n\n/*Function6(funct6) change the register by rocc*/\n  val doChange \u003d (funct \u003d\u003d\u003d UInt(6)) \n  val change_busy \u003d Reg(init \u003d Bool(false))  //rs1 is the size\n  val reg_id_reg \u003d Reg(init \u003d Bits(0,width\u003d5))  //rs1 is the size\n  val reg_value_reg \u003d Reg(init \u003d Bits(0,width\u003d64))  //rs1 is the size\n  io.reg_id :\u003d reg_id_reg\n  io.reg_value :\u003d reg_value_reg\n  io.reg_valid :\u003d change_busy\n\n  when(cmd.fire() \u0026\u0026 doChange){\n\tchange_busy :\u003d Bool(true)\n\treg_id_reg :\u003d cmd.bits.rs1\n\treg_value_reg :\u003d cmd.bits.rs2\n  }.elsewhen(io.reg_ready ){\n\t  change_busy :\u003d Bool(false)\n  }\n\n\n\n\n\n  io.corestall_wxr :\u003d  co_core.io.main_core_stall\n\n  cmd.ready :\u003d  !change_busy\n  io.busy :\u003d cmd.valid \n  io.interrupt :\u003d Bool(false)\n\n  }\n\n//wxrqw----------------\n\n// class  AccumulatorExample(opcodes: OpcodeSet, val n: Int \u003d 4)(implicit p: Parameters) extends LazyRoCC(opcodes) {\n//   override lazy val module \u003d new AccumulatorExampleModuleImp(this)\n// }\n\n// class AccumulatorExampleModuleImp(outer: AccumulatorExample)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n//     with HasCoreParameters {\n//   val regfile \u003d Mem(outer.n, UInt(width \u003d xLen))\n//   val busy \u003d Reg(init \u003d Vec.fill(outer.n){Bool(false)})\n\n//   val cmd \u003d Queue(io.cmd)\n//   val funct \u003d cmd.bits.inst.funct\n//   val addr \u003d cmd.bits.rs2(log2Up(outer.n)-1,0)\n//   val doWrite \u003d funct \u003d\u003d\u003d UInt(0)\n//   val doRead \u003d funct \u003d\u003d\u003d UInt(1)\n//   val doLoad \u003d funct \u003d\u003d\u003d UInt(2)\n//   val doAccum \u003d funct \u003d\u003d\u003d UInt(3)\n//   val memRespTag \u003d io.mem.resp.bits.tag(log2Up(outer.n)-1,0)\n\n//   // datapath\n//   val addend \u003d cmd.bits.rs1\n//   val accum \u003d regfile(addr)\n//   val wdata \u003d Mux(doWrite, addend, accum + addend)\n\n//   when (cmd.fire() \u0026\u0026 (doWrite || doAccum)) {\n//     regfile(addr) :\u003d wdata\n//   }\n\n//   when (io.mem.resp.valid) {\n//     regfile(memRespTag) :\u003d io.mem.resp.bits.data\n//     busy(memRespTag) :\u003d Bool(false)\n//   }\n\n//   // control\n//   when (io.mem.req.fire()) {\n//     busy(addr) :\u003d Bool(true)\n//   }\n\n//   val doResp \u003d cmd.bits.inst.xd\n//   val stallReg \u003d busy(addr)\n//   val stallLoad \u003d doLoad \u0026\u0026 !io.mem.req.ready\n//   val stallResp \u003d doResp \u0026\u0026 !io.resp.ready\n\n//   cmd.ready :\u003d !stallReg \u0026\u0026 !stallLoad \u0026\u0026 !stallResp\n//     // command resolved if no stalls AND not issuing a load that will need a request\n\n//   // PROC RESPONSE INTERFACE\n//   io.resp.valid :\u003d cmd.valid \u0026\u0026 doResp \u0026\u0026 !stallReg \u0026\u0026 !stallLoad\n//     // valid response if valid command, need a response, and no stalls\n//   io.resp.bits.rd :\u003d cmd.bits.inst.rd\n//     // Must respond with the appropriate tag or undefined behavior\n//   io.resp.bits.data :\u003d accum\n//     // Semantics is to always send out prior accumulator register value\n\n//   io.busy :\u003d cmd.valid || busy.reduce(_||_)\n//     // Be busy when have pending memory requests or committed possibility of pending requests\n//   io.interrupt :\u003d Bool(false)\n//     // Set this true to trigger an interrupt on the processor (please refer to supervisor documentation)\n\n//   // MEMORY REQUEST INTERFACE\n//   io.mem.req.valid :\u003d cmd.valid \u0026\u0026 doLoad \u0026\u0026 !stallReg \u0026\u0026 !stallResp\n//   io.mem.req.bits.addr :\u003d addend\n//   io.mem.req.bits.tag :\u003d addr\n//   io.mem.req.bits.cmd :\u003d M_XRD // perform a load (M_XWR for stores)\n//   io.mem.req.bits.typ :\u003d MT_D // D \u003d 8 bytes, W \u003d 4, H \u003d 2, B \u003d 1\n//   io.mem.req.bits.data :\u003d Bits(0) // we\u0027re not performing any stores...\n//   io.mem.req.bits.phys :\u003d Bool(false)\n// }\n\nclass  TranslatorExample(opcodes: OpcodeSet)(implicit p: Parameters) extends LazyRoCC(opcodes, nPTWPorts \u003d 1) {\n  override lazy val module \u003d new TranslatorExampleModuleImp(this)\n}\n\nclass TranslatorExampleModuleImp(outer: TranslatorExample)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n    with HasCoreParameters {\n  val req_addr \u003d Reg(UInt(width \u003d coreMaxAddrBits))\n  val req_rd \u003d Reg(io.resp.bits.rd)\n  val req_offset \u003d req_addr(pgIdxBits - 1, 0)\n  val req_vpn \u003d req_addr(coreMaxAddrBits - 1, pgIdxBits)\n  val pte \u003d Reg(new PTE)\n\n  val s_idle :: s_ptw_req :: s_ptw_resp :: s_resp :: Nil \u003d Enum(Bits(), 4)\n  val state \u003d Reg(init \u003d s_idle)\n\n  io.cmd.ready :\u003d (state \u003d\u003d\u003d s_idle)\n\n  when (io.cmd.fire()) {\n    req_rd :\u003d io.cmd.bits.inst.rd\n    req_addr :\u003d io.cmd.bits.rs1\n    state :\u003d s_ptw_req\n  }\n\n  private val ptw \u003d io.ptw(0)\n\n  when (ptw.req.fire()) { state :\u003d s_ptw_resp }\n\n  when (state \u003d\u003d\u003d s_ptw_resp \u0026\u0026 ptw.resp.valid) {\n    pte :\u003d ptw.resp.bits.pte\n    state :\u003d s_resp\n  }\n\n  when (io.resp.fire()) { state :\u003d s_idle }\n\n  ptw.req.valid :\u003d (state \u003d\u003d\u003d s_ptw_req)\n  ptw.req.bits.valid :\u003d true.B\n  ptw.req.bits.bits.addr :\u003d req_vpn\n\n  io.resp.valid :\u003d (state \u003d\u003d\u003d s_resp)\n  io.resp.bits.rd :\u003d req_rd\n  io.resp.bits.data :\u003d Mux(pte.leaf(), Cat(pte.ppn, req_offset), SInt(-1, xLen).asUInt)\n\n  io.busy :\u003d (state \u003d/\u003d s_idle)\n  io.interrupt :\u003d Bool(false)\n  io.mem.req.valid :\u003d Bool(false)\n}\n\nclass  CharacterCountExample(opcodes: OpcodeSet)(implicit p: Parameters) extends LazyRoCC(opcodes) {\n  override lazy val module \u003d new CharacterCountExampleModuleImp(this)\n  override val atlNode \u003d TLClientNode(Seq(TLClientPortParameters(Seq(TLClientParameters(\"CharacterCountRoCC\")))))\n}\n\nclass CharacterCountExampleModuleImp(outer: CharacterCountExample)(implicit p: Parameters) extends LazyRoCCModuleImp(outer)\n  with HasCoreParameters\n  with HasL1CacheParameters {\n  val cacheParams \u003d tileParams.icache.get\n\n  private val blockOffset \u003d blockOffBits\n  private val beatOffset \u003d log2Up(cacheDataBits/8)\n\n  val needle \u003d Reg(UInt(width \u003d 8))\n  val addr \u003d Reg(UInt(width \u003d coreMaxAddrBits))\n  val count \u003d Reg(UInt(width \u003d xLen))\n  val resp_rd \u003d Reg(io.resp.bits.rd)\n\n  val addr_block \u003d addr(coreMaxAddrBits - 1, blockOffset)\n  val offset \u003d addr(blockOffset - 1, 0)\n  val next_addr \u003d (addr_block + UInt(1)) \u003c\u003c UInt(blockOffset)\n\n  val s_idle :: s_acq :: s_gnt :: s_check :: s_resp :: Nil \u003d Enum(Bits(), 5)\n  val state \u003d Reg(init \u003d s_idle)\n\n  val (tl_out, edgesOut) \u003d outer.atlNode.out(0)\n  val gnt \u003d tl_out.d.bits\n  val recv_data \u003d Reg(UInt(width \u003d cacheDataBits))\n  val recv_beat \u003d Reg(UInt(width \u003d log2Up(cacheDataBeats+1)), init \u003d UInt(0))\n\n  val data_bytes \u003d Vec.tabulate(cacheDataBits/8) { i \u003d\u003e recv_data(8 * (i + 1) - 1, 8 * i) }\n  val zero_match \u003d data_bytes.map(_ \u003d\u003d\u003d UInt(0))\n  val needle_match \u003d data_bytes.map(_ \u003d\u003d\u003d needle)\n  val first_zero \u003d PriorityEncoder(zero_match)\n\n  val chars_found \u003d PopCount(needle_match.zipWithIndex.map {\n    case (matches, i) \u003d\u003e\n      val idx \u003d Cat(recv_beat - UInt(1), UInt(i, beatOffset))\n      matches \u0026\u0026 idx \u003e\u003d offset \u0026\u0026 UInt(i) \u003c\u003d first_zero\n  })\n  val zero_found \u003d zero_match.reduce(_ || _)\n  val finished \u003d Reg(Bool())\n\n  io.cmd.ready :\u003d (state \u003d\u003d\u003d s_idle)\n  io.resp.valid :\u003d (state \u003d\u003d\u003d s_resp)\n  io.resp.bits.rd :\u003d resp_rd\n  io.resp.bits.data :\u003d count\n  tl_out.a.valid :\u003d (state \u003d\u003d\u003d s_acq)\n  tl_out.a.bits :\u003d edgesOut.Get(\n                       fromSource \u003d UInt(0),\n                       toAddress \u003d addr_block \u003c\u003c blockOffset,\n                       lgSize \u003d UInt(lgCacheBlockBytes))._2\n  tl_out.d.ready :\u003d (state \u003d\u003d\u003d s_gnt)\n\n  when (io.cmd.fire()) {\n    addr :\u003d io.cmd.bits.rs1\n    needle :\u003d io.cmd.bits.rs2\n    resp_rd :\u003d io.cmd.bits.inst.rd\n    count :\u003d UInt(0)\n    finished :\u003d Bool(false)\n    state :\u003d s_acq\n  }\n\n  when (tl_out.a.fire()) { state :\u003d s_gnt }\n\n  when (tl_out.d.fire()) {\n    recv_beat :\u003d recv_beat + UInt(1)\n    recv_data :\u003d gnt.data\n    state :\u003d s_check\n  }\n\n  when (state \u003d\u003d\u003d s_check) {\n    when (!finished) {\n      count :\u003d count + chars_found\n    }\n    when (zero_found) { finished :\u003d Bool(true) }\n    when (recv_beat \u003d\u003d\u003d UInt(cacheDataBeats)) {\n      addr :\u003d next_addr\n      state :\u003d Mux(zero_found || finished, s_resp, s_acq)\n    } .otherwise {\n      state :\u003d s_gnt\n    }\n  }\n\n  when (io.resp.fire()) { state :\u003d s_idle }\n\n  io.busy :\u003d (state \u003d/\u003d s_idle)\n  io.interrupt :\u003d Bool(false)\n  io.mem.req.valid :\u003d Bool(false)\n  // Tie off unused channels\n  tl_out.b.ready :\u003d Bool(true)\n  tl_out.c.valid :\u003d Bool(false)\n  tl_out.e.valid :\u003d Bool(false)\n}\n\nclass OpcodeSet(val opcodes: Seq[UInt]) {\n  def |(set: OpcodeSet) \u003d\n    new OpcodeSet(this.opcodes ++ set.opcodes)\n\n  def matches(oc: UInt) \u003d opcodes.map(_ \u003d\u003d\u003d oc).reduce(_ || _)\n}\n\nobject OpcodeSet {\n  def custom0 \u003d new OpcodeSet(Seq(Bits(\"b0001011\")))\n  def custom1 \u003d new OpcodeSet(Seq(Bits(\"b0101011\")))\n  def custom2 \u003d new OpcodeSet(Seq(Bits(\"b1011011\")))\n  def custom3 \u003d new OpcodeSet(Seq(Bits(\"b1111011\")))\n  def all \u003d custom0 | custom1 | custom2 | custom3\n}\n\nclass RoccCommandRouter(opcodes: Seq[OpcodeSet])(implicit p: Parameters)\n    extends CoreModule()(p) {\n  val io \u003d new Bundle {\n    val in \u003d Decoupled(new RoCCCommand).flip\n    val out \u003d Vec(opcodes.size, Decoupled(new RoCCCommand))\n    val busy \u003d Bool(OUTPUT)\n  }\n\n  val cmd \u003d Queue(io.in)\n  val cmdReadys \u003d io.out.zip(opcodes).map { case (out, opcode) \u003d\u003e\n    val me \u003d opcode.matches(cmd.bits.inst.opcode)\n    out.valid :\u003d cmd.valid \u0026\u0026 me\n    out.bits :\u003d cmd.bits\n    out.ready \u0026\u0026 me\n  }\n  cmd.ready :\u003d cmdReadys.reduce(_ || _)\n  io.busy :\u003d cmd.valid\n\n  assert(PopCount(cmdReadys) \u003c\u003d UInt(1),\n    \"Custom opcode matched for more than one accelerator\")\n}\n"
      }
    ]
  }
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:511)
	at java.util.concurrent.FutureTask.run(FutureTask.java:266)
	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
	at java.lang.Thread.run(Thread.java:748)
Caused by: java.lang.reflect.InvocationTargetException
	at sun.reflect.GeneratedMethodAccessor8.invoke(Unknown Source)
	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.lang.reflect.Method.invoke(Method.java:498)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.lang.OutOfMemoryError: GC overhead limit exceeded

Apr 10, 2022 5:35:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2786
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2797
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2796
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2800
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2801
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2813
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2814
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2815
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2811
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2819
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2820
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2821
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2830
2022.04.10 05:35:32 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2762
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2833
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2831
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2835
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2837
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2838
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2766
Apr 10, 2022 5:35:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2842
2022.04.10 05:35:32 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2843
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2844
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2845
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2848
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2849
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2851
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2840
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2846
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2854
2022.04.10 05:35:32 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2859
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2860
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2868
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2866
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2869
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2871
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2874
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2875
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2877
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2880
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2881
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2882
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2873
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2884
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2886
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2887
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2889
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2891
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2885
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2895
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2899
2022.04.10 05:35:32 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2904
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2905
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2834
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2841
Apr 10, 2022 5:35:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2906
2022.04.11 00:27:29 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/lsp.trace.json or /home/wxrqw/.cache/metals/lsp.trace.json
2022.04.11 00:27:31 INFO  logging to file /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/metals.log
2022.04.11 00:27:31 INFO  Started: Metals version 0.11.2 in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main' for client Visual Studio Code 1.64.2.
2022.04.11 00:27:34 INFO  time: initialize in 3.08s
2022.04.11 00:27:35 WARN  Build server is not auto-connectable.
2022.04.11 00:27:35 WARN  no build tool detected in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. 
2022.04.11 00:27:36 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.11 00:27:44 INFO  no build target found for /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala. Using presentation compiler with project's scala-library version: 3.1.1
Apr 11, 2022 12:27:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2
Apr 11, 2022 12:27:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6
Apr 11, 2022 12:27:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7
Apr 11, 2022 12:27:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10
2022.04.11 00:27:53 INFO  time: code lens generation in 12s
Apr 13, 2022 11:23:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 56
Apr 13, 2022 11:23:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 57
Apr 13, 2022 11:23:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 64
2022.04.13 23:24:01 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 13, 2022 11:24:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 195
Apr 13, 2022 11:24:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 196
Apr 13, 2022 11:24:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 214
2022.04.13 23:26:29 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.13 23:27:06 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.13 23:34:06 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.13 23:34:14 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.13 23:39:18 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 13, 2022 11:45:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1047
2022.04.13 23:46:17 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.13 23:51:09 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 13, 2022 11:51:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1505
Apr 13, 2022 11:51:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1547
2022.04.13 23:54:25 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.13 23:57:20 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.13 23:57:34 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.13 23:57:37 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:00:18 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1970
2022.04.14 00:00:43 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:00:55 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:01:16 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:01:24 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:01:25 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:02:45 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:02:49 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:03:52 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:04:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2510
2022.04.14 00:05:02 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:05:48 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:05:54 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:05:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2733
2022.04.14 00:06:08 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:06:16 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:06:29 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:08:00 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:09:47 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:09:56 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:10:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3144
Apr 14, 2022 12:10:09 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3187
2022.04.14 00:10:11 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:11:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3282
Apr 14, 2022 12:13:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3300
2022.04.14 00:13:44 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:16:45 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3495
Apr 14, 2022 12:16:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3509
2022.04.14 00:16:52 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:17:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3551
Apr 14, 2022 12:17:28 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3666
Apr 14, 2022 12:17:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3681
2022.04.14 00:17:43 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:18:10 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:18:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3845
Apr 14, 2022 12:18:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3846
2022.04.14 00:18:25 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:18:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3901
2022.04.14 00:18:38 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:19:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4041
2022.04.14 00:19:30 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:19:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4152
Apr 14, 2022 12:19:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4154
2022.04.14 00:20:03 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:20:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4277
Apr 14, 2022 12:20:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4283
Apr 14, 2022 12:20:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4292
2022.04.14 00:20:35 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:20:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4535
2022.04.14 00:21:05 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:21:18 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4652
Apr 14, 2022 12:21:44 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4797
2022.04.14 00:22:08 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:23:06 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:24:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5294
Apr 14, 2022 12:24:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5300
Apr 14, 2022 12:24:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5309
Apr 14, 2022 12:24:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5308
Apr 14, 2022 12:24:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5316
Apr 14, 2022 12:24:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5312
Apr 14, 2022 12:24:56 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5320
2022.04.14 00:25:04 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:25:11 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:25:13 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5382
Apr 14, 2022 12:25:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5429
Apr 14, 2022 12:26:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5465
Apr 14, 2022 12:26:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5466
Apr 14, 2022 12:26:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5506
Apr 14, 2022 12:26:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5507
2022.04.14 00:26:21 INFO  time: code lens generation in 1.09s
Apr 14, 2022 12:26:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5530
Apr 14, 2022 12:26:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5532
Apr 14, 2022 12:26:29 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5543
Apr 14, 2022 12:26:34 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5562
Apr 14, 2022 12:26:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5571
Apr 14, 2022 12:26:39 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5602
2022.04.14 00:26:41 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:26:44 INFO  time: code lens generation in 2.64s
Apr 14, 2022 12:26:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5653
2022.04.14 00:26:57 INFO  time: code lens generation in 1.36s
Apr 14, 2022 12:26:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5683
Apr 14, 2022 12:26:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5685
Apr 14, 2022 12:26:59 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5693
2022.04.14 00:27:00 INFO  time: code lens generation in 1.22s
Apr 14, 2022 12:27:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5702
Apr 14, 2022 12:27:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5701
Apr 14, 2022 12:27:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5695
Apr 14, 2022 12:27:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5697
Apr 14, 2022 12:27:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5710
Apr 14, 2022 12:27:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5713
2022.04.14 00:27:04 INFO  time: code lens generation in 1.69s
Apr 14, 2022 12:27:04 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5714
Apr 14, 2022 12:27:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5715
Apr 14, 2022 12:27:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5716
Apr 14, 2022 12:27:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5709
Apr 14, 2022 12:27:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5708
Apr 14, 2022 12:27:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5723
Apr 14, 2022 12:27:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5719
2022.04.14 00:27:15 INFO  time: code lens generation in 1.52s
Apr 14, 2022 12:27:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5789
Apr 14, 2022 12:27:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5790
Apr 14, 2022 12:27:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5812
Apr 14, 2022 12:27:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5842
Apr 14, 2022 12:28:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5904
Apr 14, 2022 12:28:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5902
Apr 14, 2022 12:28:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5910
Apr 14, 2022 12:28:10 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5911
Apr 14, 2022 12:28:11 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5912
Apr 14, 2022 12:28:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5914
Apr 14, 2022 12:28:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5908
2022.04.14 00:28:15 INFO  time: code lens generation in 3.72s
Apr 14, 2022 12:28:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5915
Apr 14, 2022 12:28:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5916
2022.04.14 00:28:26 INFO  time: code lens generation in 9.69s
Apr 14, 2022 12:28:37 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5882
Apr 14, 2022 12:28:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5939
Apr 14, 2022 12:28:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5923
Exception in thread "pool-1-thread-161" java.lang.OutOfMemoryError: Java heap space
	at java.util.Arrays.copyOf(Arrays.java:3181)
	at java.util.ArrayList.grow(ArrayList.java:267)
	at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:241)
	at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:233)
	at java.util.ArrayList.add(ArrayList.java:464)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.pushToken$1(ScalametaTokenizer.scala:31)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.pushLegacyToken$1(ScalametaTokenizer.scala:178)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.emitToken$1(ScalametaTokenizer.scala:203)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.loop$1(ScalametaTokenizer.scala:208)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.uncachedTokenize(ScalametaTokenizer.scala:316)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.$anonfun$tokenize$1(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$Lambda$1135/2124336579.apply(Unknown Source)
	at scala.collection.concurrent.TrieMap.getOrElseUpdate(TrieMap.scala:895)
	at scala.meta.internal.tokenizers.ScalametaTokenizer.tokenize(ScalametaTokenizer.scala:17)
	at scala.meta.internal.tokenizers.ScalametaTokenizer$$anon$2.apply(ScalametaTokenizer.scala:334)
	at scala.meta.tokenizers.Api$XtensionTokenizeDialectInput.tokenize(Api.scala:25)
	at scala.meta.internal.parsing.Trees.tokenized(Trees.scala:112)
	at scala.meta.internal.parsing.TokenEditDistance$.$anonfun$apply$4(TokenEditDistance.scala:384)
	at scala.meta.internal.parsing.TokenEditDistance$$$Lambda$3738/891308688.apply(Unknown Source)
	at scala.Option.flatMap(Option.scala:271)
	at scala.meta.internal.parsing.TokenEditDistance$.apply(TokenEditDistance.scala:383)
	at scala.meta.internal.metals.Buffers.tokenEditDistance(Buffers.scala:30)
	at scala.meta.internal.metals.codelenses.RunTestCodeLens.codeLenses(RunTestCodeLens.scala:63)
	at scala.meta.internal.metals.CodeLensProvider.$anonfun$findLenses$3(CodeLensProvider.scala:26)
	at scala.meta.internal.metals.CodeLensProvider$$Lambda$3694/796390864.apply(Unknown Source)
	at scala.collection.immutable.List.flatMap(List.scala:366)
	at scala.meta.internal.metals.CodeLensProvider.$anonfun$findLenses$2(CodeLensProvider.scala:26)
	at scala.meta.internal.metals.CodeLensProvider$$Lambda$3692/1496118746.apply(Unknown Source)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.CodeLensProvider.findLenses(CodeLensProvider.scala:24)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$codeLens$2(MetalsLanguageServer.scala:1628)
	at scala.meta.internal.metals.MetalsLanguageServer$$Lambda$2409/805229426.apply(Unknown Source)
Apr 14, 2022 12:36:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5941
2022.04.14 00:37:12 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/lsp.trace.json or /home/wxrqw/.cache/metals/lsp.trace.json
2022.04.14 00:37:13 INFO  logging to file /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/metals.log
2022.04.14 00:37:13 INFO  Started: Metals version 0.11.2 in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main' for client Visual Studio Code 1.64.2.
2022.04.14 00:37:16 INFO  time: initialize in 2.32s
2022.04.14 00:37:17 WARN  Build server is not auto-connectable.
2022.04.14 00:37:17 WARN  no build tool detected in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. 
2022.04.14 00:37:18 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:37:22 INFO  no build target found for /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala. Using presentation compiler with project's scala-library version: 3.1.1
Apr 14, 2022 12:37:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25
Apr 14, 2022 12:37:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 102
2022.04.14 00:37:32 INFO  time: code lens generation in 6.46s
2022.04.14 00:37:32 INFO  time: code lens generation in 9.62s
2022.04.14 00:37:32 INFO  time: code lens generation in 4.92s
2022.04.14 00:37:32 INFO  time: code lens generation in 10s
2022.04.14 00:37:32 INFO  time: code lens generation in 5.66s
2022.04.14 00:37:33 INFO  time: code lens generation in 9.14s
2022.04.14 00:37:33 INFO  time: code lens generation in 7.65s
Apr 14, 2022 12:37:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 72
Apr 14, 2022 12:37:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 107
Apr 14, 2022 12:37:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 129
2022.04.14 00:37:37 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:37:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 152
Apr 14, 2022 12:37:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 157
Apr 14, 2022 12:37:41 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 177
Apr 14, 2022 12:37:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 241
Apr 14, 2022 12:37:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 242
Apr 14, 2022 12:38:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 284
Apr 14, 2022 12:38:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 311
Apr 14, 2022 12:38:08 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 328
2022.04.14 00:38:16 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:38:22 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 441
Apr 14, 2022 12:38:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 555
Apr 14, 2022 12:38:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 557
Apr 14, 2022 12:38:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 561
Apr 14, 2022 12:38:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 566
Apr 14, 2022 12:38:48 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 686
2022.04.14 00:38:50 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:38:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 720
Apr 14, 2022 12:38:52 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 729
Apr 14, 2022 12:38:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 757
Apr 14, 2022 12:38:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 774
Apr 14, 2022 12:38:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 809
Apr 14, 2022 12:39:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 834
Apr 14, 2022 12:39:00 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 845
Apr 14, 2022 12:39:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 862
Apr 14, 2022 12:39:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 875
Apr 14, 2022 12:42:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1014
Apr 14, 2022 12:43:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1054
Apr 14, 2022 12:43:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1062
Apr 14, 2022 12:43:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1112
Apr 14, 2022 12:43:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1113
Apr 14, 2022 12:43:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1141
Apr 14, 2022 12:43:18 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1159
Apr 14, 2022 12:43:18 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1160
Apr 14, 2022 12:43:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1219
Apr 14, 2022 12:43:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1220
Apr 14, 2022 12:43:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1309
Apr 14, 2022 12:43:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1327
Apr 14, 2022 12:43:43 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1361
Apr 14, 2022 12:43:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1380
Apr 14, 2022 12:43:46 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1381
Apr 14, 2022 12:43:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1430
Apr 14, 2022 12:43:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1432
Apr 14, 2022 12:43:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1434
Apr 14, 2022 12:43:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1436
Apr 14, 2022 12:43:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1437
Apr 14, 2022 12:43:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1466
Apr 14, 2022 12:44:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1499
Apr 14, 2022 12:44:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1565
Apr 14, 2022 12:44:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1566
Apr 14, 2022 12:44:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1594
Apr 14, 2022 12:44:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1691
Apr 14, 2022 12:44:27 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1692
Apr 14, 2022 12:44:32 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1734
2022.04.14 00:44:35 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:44:47 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1794
Apr 14, 2022 12:44:50 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1824
Apr 14, 2022 12:44:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1886
Apr 14, 2022 12:44:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1887
Apr 14, 2022 12:45:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1915
Apr 14, 2022 12:45:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1934
Apr 14, 2022 12:45:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1961
Apr 14, 2022 12:45:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1964
Apr 14, 2022 12:45:06 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1965
2022.04.14 00:45:14 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:47:59 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:57:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2174
2022.04.14 00:58:08 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 00:58:13 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 12:58:25 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2296
Apr 14, 2022 12:58:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2306
Apr 14, 2022 12:58:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2307
Apr 14, 2022 12:58:26 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2308
2022.04.14 00:59:12 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 01:05:53 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 01:06:19 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 1:07:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2559
Apr 14, 2022 1:07:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2562
2022.04.14 01:07:31 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 01:08:22 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 01:21:06 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 1:21:16 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2738
Apr 14, 2022 1:21:17 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2747
Apr 14, 2022 1:21:18 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2763
Apr 14, 2022 1:21:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2770
Apr 14, 2022 1:21:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2775
Apr 14, 2022 1:21:19 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2779
Apr 14, 2022 1:21:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2792
Apr 14, 2022 1:21:21 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2805
2022.04.14 01:21:29 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 1:22:01 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2981
Apr 14, 2022 1:22:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3058
2022.04.14 01:22:22 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 1:27:38 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3213
2022.04.14 01:28:07 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 01:28:23 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 2:54:15 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3511
Apr 14, 2022 2:54:40 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3668
2022.04.14 02:54:46 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 02:55:01 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 02:55:57 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
Apr 14, 2022 4:05:12 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3943
2022.04.14 04:05:51 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/rocket/RocketCore.scala
2022.04.14 04:06:03 INFO  time: code lens generation in 2.31s
Apr 14, 2022 4:08:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4027
Apr 14, 2022 4:16:30 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4081
Apr 14, 2022 4:16:31 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4086
Apr 14, 2022 4:16:33 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4091
Apr 14, 2022 4:16:35 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4098
Apr 14, 2022 4:18:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4130
Apr 14, 2022 4:18:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4131
Apr 14, 2022 4:18:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4132
Apr 14, 2022 4:18:53 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4133
Apr 14, 2022 4:18:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4139
Apr 14, 2022 4:18:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4140
Apr 14, 2022 4:18:54 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4142
Apr 14, 2022 4:18:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4146
Apr 14, 2022 4:18:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4147
Apr 14, 2022 4:18:55 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4148
Apr 14, 2022 4:18:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4153
Apr 14, 2022 4:18:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4155
Apr 14, 2022 4:18:57 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4156
Apr 14, 2022 4:18:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4160
Apr 14, 2022 4:18:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4161
Apr 14, 2022 4:18:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4162
Apr 14, 2022 4:18:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4163
Apr 14, 2022 4:18:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4164
Apr 14, 2022 4:18:58 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4165
Apr 14, 2022 4:19:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4173
Apr 14, 2022 4:19:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4174
Apr 14, 2022 4:19:02 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4175
Apr 14, 2022 4:19:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4176
Apr 14, 2022 4:19:03 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4177
Apr 14, 2022 4:19:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4180
Apr 14, 2022 4:19:05 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4181
Apr 14, 2022 4:19:07 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4187
Apr 14, 2022 4:19:23 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4198
2022.04.14 04:21:51 INFO  tracing is disabled for protocol LSP, to enable tracing of incoming and outgoing JSON messages create an empty file at /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/lsp.trace.json or /home/wxrqw/.cache/metals/lsp.trace.json
2022.04.14 04:21:55 INFO  logging to file /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/.metals/metals.log
2022.04.14 04:21:55 INFO  Started: Metals version 0.11.2 in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main' for client Visual Studio Code 1.64.2.
2022.04.14 04:21:58 INFO  time: initialize in 2.9s
2022.04.14 04:22:03 WARN  Build server is not auto-connectable.
2022.04.14 04:22:03 WARN  no build tool detected in workspace '/home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. 
2022.04.14 04:22:03 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala
2022.04.14 04:22:03 WARN  no build target for: /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/rocket/RocketCore.scala
2022.04.14 04:22:08 INFO  no build target found for /home/wxrqw/rocket/freedom-configsty/rocket-chip/src/main/scala/tile/LazyRoCC.scala. Using presentation compiler with project's scala-library version: 3.1.1
2022.04.14 04:22:17 INFO  time: code lens generation in 9.41s
2022.04.14 04:22:54 INFO  shutting down Metals
